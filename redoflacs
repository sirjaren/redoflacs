#!/usr/bin/env bash
#-------------------------------------------------------------------------------
# redoflacs - Parallel BASH commandline FLAC compressor, verifier, organizer,
#             analyzer, and retagger
#-------------------------------------------------------------------------------
# ~ THIS IS THE UNIX/LINUX/BSD VERSION OF REDOFLACS ~
#-------------------------------------------------------------------------------
# Copyright (C) 2010-2014  Jaren Stangret
#-------------------------------------------------------------------------------
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#-------------------------------------------------------------------------------
# You can follow development of this script on Github at:
# https://github.com/sirjaren/redoflacs
#
# Please submit requests/changes/patches and/or comments
#-------------------------------------------------------------------------------
# File Descriptors used in this script:
#    0: STDIN
#    1: STDOUT
#    2: STDERR
#    3: FIFO process manager
#    4: auCDtect's STDOUT output
#-------------------------------------------------------------------------------

__info()  { printf " ${green}*${normal} ${@}"  ;}   # Bold green message
__warn()  { printf " ${yellow}*${normal} ${@}" ;}   # Yellow message
__error() { printf " ${red}*${normal} ${@}"    ;}   # Bold red message

#-------------------------------------------------------------------------------

__display_missing_commands_header() {
   # Display message that system is missing vital programs
   #--
   __error "You seem to be missing one or more necessary programs\n"
   __error "to run this script reliably.  Below shows the program(s)\n"
   __error "missing, as well as where you can install them from:\n"
} >&2

#-------------------------------------------------------------------------------

__long_help() {
   # Display a lot of help
   #--
   long_help=".TH \"REDOFLACS\" 1
.SH NAME
redoflacs \\- Parallel BASH commandline FLAC compressor, verifier, organizer, analyzer, and retagger
.SH SYNOPSIS
.B redoflacs
.RI [operations]
.RI [options]
.RI [target]
.RI ...
.SH DESCRIPTION
redoflacs is a BASH commandline program providing a series of operations to help
manage and verify a user's FLAC music library.  One of the key features of
redoflacs is it's ability to process a great number of FLAC files in parallel,
using as many jobs to complete an operation as possible, very similar to 'GNU
make'.

redoflacs searches for a config file (if run as a user) in:

.br
        \\fB~/.config/redoflacs/config\\fP

.br
or (if run as root) in:

.br
        \\fB/etc/redoflacs.conf\\fP

If a config file is not found (in either place), one is created.

More information can be found at <\\fBhttps://github.com/sirjaren/redoflacs\\fP>.
.SH OPERATIONS
.TP
.BI -c, --compress
Compress the FLAC files with the user-specified level of compression defined
from the configuration file as 'compression_level' and verify the resultant
files.

The default is 8, with the range of values starting from 1 to 8 with the
smallest compression at 1, and the highest at 8.  This option will add a tag
(VORBIS_COMMENT) to all successfully verified FLAC files.  Below shows the
default COMPRESSION tag added to each successfully compressed (and verified)
FLAC file:

        COMPRESSION=8

If any FLAC files already have the defined compression_level tag (a good
indicator the files are already compressed at that level), the script will
instead test the FLAC files for any errors.  This is useful to check your entire
music library to make sure all the FLAC files are compressed at the level
specified as well as make sure they are intact (ie, not corrupt).

If any files are found to be corrupt, this script will quit upon finishing the
compression of any other files and produce an error log.
.TP
.BI -C, --compress-notest
Same as the '-c, --compress' option, but if any FLAC files already have the
defined compression_level tag, the script will skip the file and continue on to
the next without testing the FLAC file's integrity.  This is useful for checking
if all your FLAC files are compressed at the level specified.
.TP
.BI -t, --test
Same as '-c, --compress' but instead of compressing the FLAC files, this script
just verfies the integrity of them.  This option will NOT add the COMPRESSION
tag to the files.

As with the '-c, --compress' option, this will produce an error log if any FLAC
files are found to be corrupt.
.TP
.BI -a, --aucdtect
Use the auCDtect program by Oleg Berngardt and Alexander Djourik to analyze
FLAC files and check with fairly accurate precision whether the FLAC files are
lossy sourced or not.  For example, an MP3 file converted to FLAC is no longer
lossless therefore lossy sourced.

While this program isn't foolproof, it gives a good idea which FLAC files will
need further investigation (ie, a spectrogram).  This program does not work on
FLAC files which have a bit depth of more than a typical audio CD (16bit), and
will skip the files that have a higher bit depth.

If any files are found to not be perfect (ie, 100% CDDA via auCDtect), a log
will be created with the questionable FLAC files recorded in it.
.TP
.BI -A, --aucdtect-spectrogram
Same as '-a, --aucdtect' with the addition of creating a spectrogram for each
FLAC file that fails auCDtect, that is, any FLAC file that does not return 100%
CDDA from auCDtect will be scanned and a spectrogram will be created.

Any FLAC file skipped (due to having a higher bit depth than 16), will NOT have
a spectrogram created.

By default, each spectrogram will be created in the same folder as the tested
FLAC file name as follows:

        [<# of current file processed>] <filename>.png

An example of this:

        [ FLAC file (7th file processed) ]
              03 - Some FLAC File.flac

        [ Spectrogram Image ]
              [7] 03 - Some FLAC File.png

The user can change the location of where to store the created spectrogram
images by changing the value of 'spectrogram_location' defined in the
configuration file.  The location defined by the user will be tested to see if
it exists before starting the script.  If the location does NOT exist, the
script will warn the user and exit.

The created PNG file is large in resolution to best capture the FLAC file's
waveform (roughly 1800x513).

The spectrogram is created using the program SoX.  If the user tries to use this
option without having SoX installed, the script will warn the user that SoX is
missing and exit.
.TP
.BI -m, --md5check
Check the FLAC files for unset MD5 Signatures and log the output of any unset
signatures.  An unset MD5 signature doesn't necessarily mean a FLAC file is
corrupt, and MAY be repaired with a re-encoding of said FLAC file.
.TP
.BI -e, --extract-artwork
Run through each FLAC file and extract any and all artwork that's embedded
within the PICTURE block.  This is useful in the event a user wants to save any
artwork before using the '-p, --prune' option to remove the artwork.

By default, each extracted image will be placed in a subdirectory where the FLAC
file is located.  The subdirectory will have the same name as the current FLAC
being processed with a fairly unique string appended to it.  For example:

        [ Current FLAC file ]
              /path/to/music/01_file.flac

        [ Example subdirectory ]
              /path/to/music/01_file.flac_[redoflacs_art]_4342/

The user can change the location of where to store the extracted images by
changing the value of 'artwork_location' defined in the configuration file.  The
location defined by the user will be tested to see if it exists before starting
the script.  If the location does not exist, the script will warn the user and
exit.

This operation supports all the various types of embedded artwork that
\`metaflac' supports:

         0: Other
.br
         1: 32x32 pixels 'file icon' (PNG only)
.br
         2: Other file icon
.br
         3: Cover (front)
.br
         4: Cover (back)
.br
         5: Leaflet page
.br
         6: Media (e.g. label side of CD)
.br
         7: Lead artist/lead performer/soloist
.br
         8: Artist/performer
.br
         9: Conductor
.br
        10: Band/Orchestra
.br
        11: Composer
.br
        12: Lyricist/text writer
.br
        13: Recording Location
.br
        14: During recording
.br
        15: During performance
.br
        16: Movie/video screen capture
.br
        17: A bright coloured fish
.br
        18: Illustration
.br
        19: Band/artist logotype
.br
        20: Publisher/Studio logotype

If there is more than one image of the same type, this operation will append a
number after the image filename to prevent clobbering:

        [ Example subdirectory ]
              /path/to/music/01_file.flac_[redoflacs_art]_4342/

        [ More than image in subdirectory ]
              Cover (front) (1).jpg
              Cover (front) (2).jpg
              Cover (front) (3).jpg
              Cover (front) (4).jpg
              Cover (front) (5).jpg
.TP
.BI -p, --prune
Delete every METADATA block in each FLAC file except the STREAMINFO and
VORBIS_COMMENT block.  If 'remove_artwork' is not set as 'true', defined in the
configuration file, then the PICTURE block will NOT be removed.
.TP
.BI -g, --replaygain
Add ReplayGain values to FLAC files.  ReplayGain is calculated for ALBUM and
TRACK values and applied via VORBIS_COMMENTS and as such, will require the
'-r, --retag' option to have these tags kept (see '-r, --retag' option) in order
to preserve the added ReplayGain values.  The tags added are:

        REPLAYGAIN_REFERENCE_LOUDNESS
.br
        REPLAYGAIN_TRACK_GAIN
.br
        REPLAYGAIN_TRACK_PEAK
.br
        REPLAYGAIN_ALBUM_GAIN
.br
        REPLAYGAIN_ALBUM_PEAK

This option ignores any ReplayGain tags that may already be set, removing
existing values before applying new ones.

In order for ReplayGain values to be applied correctly, the script has to
determine which FLAC files to add values to by looking at the directory housing
said files.  That is, the script must add ReplayGain values by working off the
FLAC files' parent directory.  If there are some FLAC files found, the script
will move up one directory and begin applying ReplayGain values.  This is
necessary in order to get the REPLAYGAIN_ALBUM_GAIN and REPLAYGAIN_ALBUM_PEAK
values set correctly.  Without doing this, the ALBUM and TRACK values would be
identical.

If a user has many FLAC files under one directory (of different albums/artists),
the ReplayGain ALBUM values are going to be incorrect as the script will
perceive all those FLAC files to essentially be from the same album.  This is
mitigated by having each album in a separate directory.  Keep in mind,
multi-disc albums must be in separate directories in order to be processed with
different ALBUM GAIN and ALBUM PEAK values.

If there are any errors found while generating and/or applying ReplayGain
values, an error log will be produced.
.TP
.BI -G, --replaygain-noforce
Same as '-g, --replaygain' but will check for existing ReplayGain tags before
re-applying new ones.  If any one of the five ReplayGain tags are missing from
any FLAC file (mentioned above), the script will apply new values to each FLAC
file in that directory (first removing the old ReplayGain tags -- if any).

If all five ReplayGain tags are intact in every FLAC file (in a given
directory), that directory will be skipped and no new ReplayGain tags will be
added.
.TP
.BI -r, --retag
Extract the configured tags in each FLAC file and clear the rest before
retagging the file.  The default tags kept are:

        TITLE
.br
        ARTIST
.br
        ALBUM
.br
        DISCNUMBER
.br
        DATE
.br
        TRACKNUMBER
.br
        TRACKTOTAL
.br
        GENRE
.br
        COMPRESSION
.br
        RELEASETYPE
.br
        SOURCE
.br
        MASTERING
.br
        REPLAYGAIN_REFERENCE_LOUDNESS
.br
        REPLAYGAIN_TRACK_GAIN
.br
        REPLAYGAIN_TRACK_PEAK
.br
        REPLAYGAIN_ALBUM_GAIN
.br
        REPLAYGAIN_ALBUM_PEAK

If any FLAC files have missing tags (from those configured to be kept), the file
and the missing tag will be recorded in a log.

The tags that can be kept are essentially infinite, as long as the tags to be
kept are set in the TAGGING SECTION of the configuration file.

If this option is specified, a warning will appear upon script execution.  This
warning will show which of the configured TAG fields to keep when re-tagging the
FLAC files.  A countdown will appear giving the user 10 seconds to abort the
script, after which, the program will begin running it's course.
.TP
.BI -l, --all
This option is short for:

        -c, --compress
.br
        -m, --md5check
.br
        -p, --prune
.br
        -g, --replaygain
.br
        -r, --retag
.TP
.BI -L, --reallyall
This option is short for:

        -c, --compress
.br
        -m, --md5check
.br
        -p, --prune
.br
        -g, --replaygain
.br
        -r, --retag
.br
        -A, --aucdtect-spectrogram
.SH OPTIONS
.TP
.BI -j[N], --jobs[=N]
Set the number of parallel jobs to run on script invocation.  If this is not
set, this script will attempt to find the number of CPU cores available,
using the number found as the number of parallel jobs to run.

If the script is unable to find the number of CPU cores available, the number of
jobs will be set to two (2), by default.
.TP
.BI -n, --no-color
Turn off color output.
.TP
.BI -o, --new-config
Force the creation of a new configuration file.  This option does _NOT_
overwrite any existing configuration file.
.TP
.BI -v, --version
Display script version and exit.
.TP
.BI -h, --help
Shows this help message.
.SH FILES
.TP
.BI ~/.config/redoflacs/config
User configuration file.
.TP
.BI /etc/redoflacs.conf
System configuration file.
.SH BUGS
If you find a bug, please report it at:
<\\fBhttps://github.com/sirjaren/redoflacs/issues/new\\fP>
.SH AUTHOR
Jaren Stangret <sirjaren@gmail.com>
.SH THANKS
Thanks to all the people whom have provided feedback and support!
.br
.SH REVISION
[ 4 ]"

   # Print out help to temporary file which will read by 'man'
   printf "%s\n" "${long_help}" > "${tmp_man_page}"
}

#-------------------------------------------------------------------------------

__short_help() {
   # Display short help
   #--
   printf " Usage: redoflacs [operations] [options] [target] ...\n"
   printf " Operations:\n"
   printf "   -c, --compress\n"
   printf "   -C, --compress-notest\n"
   printf "   -t, --test\n"
   printf "   -m, --md5check\n"
   printf "   -a, --aucdtect\n"
   printf "   -A, --aucdtect-spectrogram\n"
   printf "   -e, --extract-artwork\n"
   printf "   -p, --prune\n"
   printf "   -g, --replaygain\n"
   printf "   -G, --replaygain-noforce\n"
   printf "   -r, --retag\n"
   printf "   -l, --all\n"
   printf "   -L, --reallyall\n"
   printf " Options:\n"
   printf "   -j[N], --jobs[=N]\n"
   printf "   -n, --no-color\n"
   printf "   -o, --new-config\n"
   printf "   -v, --version\n"
   printf "   -h, --help\n"
   printf " This is the short help; for details use 'redoflacs --help' or 'redoflacs -h'\n"
}

#-------------------------------------------------------------------------------

# Display usage
__usage() { printf " Usage: redoflacs [operations] [options] [target] ...\n" ;} >&2

#-------------------------------------------------------------------------------

__message_log_exists() {
   # Print out the correct operational message regarding a log file's existence
   # and what infomration that log may contain
   #
   # $1 determines the log file to use, as well as how many lines are printed
   # out to correctly set the current row.  Possible values:
   #   aucdtect          aucdtect_spectrogram        md5_check
   #   compress_verify   compress_no_test            test
   #   replaygain_test   replaygain_force_apply      replaygain_apply
   #   retag_analyze     retag_apply                 extract_images
   #   prune
   #--
   case "$1" in
      'aucdtect'*)
         __error "Some FLAC files may be lossy sourced, please check:\n"
      ;;
      'md5_check')
         __error "The MD5 Signature is unset for some FLAC files or there were\n"
         __error "issues with some of the FLAC files, please check:\n"
      ;;
      'compress_'*|'test'|'replaygain_test'|'extract_images'|'prune')
         __error "There were issues with some of the FLAC files,\n"
         __error "please check:\n"
      ;;
      'replaygain'*'apply')
         __error "There were issues adding ReplayGain values,\n"
         __error "please check:\n"
      ;;
      'retag_'*)
         __error "Some FLAC files have missing tags or there were\n"
         __error "issues with some of the FLAC files, please check:\n"
      ;;
   esac

   # Print the bottom half of the message (uniform across all operations)
   __error "${cyan}${log_file}${normal}\n"
   __error "for details.\n"
} >&2

#-------------------------------------------------------------------------------

__create_log() {
   # Take log file from the current operation, prepending a header to it as
   # as well as formatting/aligning log lines
   #
   # $1 determines the log file to create, and is any one of these values:
   #   aucdtect          aucdtect_spectrogram        md5_check
   #   compress_verify   compress_no_test            test
   #   replaygain_test   replaygain_force_apply      replaygain_apply
   #   retag_analyze     retag_apply                 extract_images
   #   prune
   #--
   # Set up local variables/arrays
   declare    error_msg  filename  line
   declare -i length
   declare -a header     log_array

   # Set log file and the type of header to prepend based on how this function
   # was called, via $1
   case "${1}" in
      'aucdtect'*)
         header=(
            "--------------------------------------------------------------------------------"
            "                            [ Aucdtect Report Log ]"
            ""
            "      This log details which FLAC files have errors when running auCDtect"
            "--------------------------------------------------------------------------------"
         ) ;;
      'md5_check')
         header=(
            "--------------------------------------------------------------------------------"
            "                            [ Md5 Check Error Log ]"
            ""
            " This log details which FLAC files have errors when checking the MD5 signature"
            "--------------------------------------------------------------------------------"
         ) ;;
      'compress_'*)
         header=(
            "--------------------------------------------------------------------------------"
            "                        [ Compress & Verify Error Log ]"
            ""
            " This log details which FLAC files have errors when compressing and/or verifying"
            "--------------------------------------------------------------------------------"
         ) ;;
      'test')
         header=(
            "--------------------------------------------------------------------------------"
            "                               [ Test Error Log ]"
            ""
            "          This log details which FLAC files have errors when testing"
            "--------------------------------------------------------------------------------"
         ) ;;
      'replaygain_test')
         header=(
            "--------------------------------------------------------------------------------"
            "                         [ ReplayGain Test Error Log ]"
            ""
            " This log details which FLAC files have errors when testing for ReplayGain"
            " compatability"
            "--------------------------------------------------------------------------------"
         ) ;;
      'replaygain'*'apply')
         header=(
            "--------------------------------------------------------------------------------"
            "                        [ ReplayGain Apply Error Log ]"
            ""
            " This log details which directories have FLAC files that have errors when"
            " applying ReplayGain values"
            "--------------------------------------------------------------------------------"
         ) ;;
      'retag_'*)
         header=(
            "--------------------------------------------------------------------------------"
            "                              [ Retag Error Log ]"
            ""
            "         This log details which FLAC files have errors when retagging"
            "--------------------------------------------------------------------------------"
         ) ;;
      'extract_images')
         header=(
            "--------------------------------------------------------------------------------"
            "                         [ Extract Images Error Log ]"
            ""
            " This log details which FLAC files have errors when extracting artwork images"
            "--------------------------------------------------------------------------------"
         ) ;;
      'prune')
         header=(
            "--------------------------------------------------------------------------------"
            "                              [ Prune Error Log ]"
            ""
            " This log details which FLAC files have errors when pruning METADATA blocks"
            "--------------------------------------------------------------------------------"
         ) ;;
   esac

   # Create array of current log file
   mapfile -n0 -t log_array < "${log_file}"

   for line in "${log_array[@]}" ; do
      # Find the longest filename in the log file, and store it's length
      #--
      # 'path/to/file.flac__redoflacs::delimiter__error message' -> 'path/to/file.flac'
      filename="${line%%__redoflacs::delimiter__*}"

      # Use 'wc -L' for apparent length, not number of characters
      if (( $(wc -L <<< ${filename}) > length )) ; then
         length=$(wc -L <<< ${filename})
      fi
   done

   # Log header, truncating old log
   printf "%s\n" "${header[@]}" > "${log_file}"

   for line in "${log_array[@]}" ; do
      # Left align filenames and line up error messages before appending to
      # log file
      #--
      # 'path/to/file.flac__redoflacs::delimiter__error message' -> 'path/to/file.flac'
      filename="${line%%__redoflacs::delimiter__*}"

      # Use 'wc -L' for apparent length, not number of characters
      filename_length=$(wc -L <<< "${filename}")

      # 'path/to/file.flac__redoflacs::delimiter__error message' -> 'error message'
      error_msg="${line##*__redoflacs::delimiter__}"

      # Example line: /media/Music/Artist/Album/file.flac  ->  Error Message
      printf "%s%$((length - filename_length))s  ->  %s\n" "${filename}" "" "${error_msg}" >> "${log_file}"
   done
}

#-------------------------------------------------------------------------------

__message() {
   # Print out current operation message.
   #
   # $1 determines which title message to print (if any).  Possible values:
   #   aucdtect          aucdtect_spectrogram        md5_check
   #   compress_verify   compress_no_test            test
   #   replaygain_test   replaygain_force_apply      replaygain_apply
   #   retag_analyze     retag_apply                 extract_images
   #   prune
   #--
   # Set up local variables
   declare message sub_message

   # Print title message if $1 is not NULL
   if [[ -n "${1}" ]] ; then
      case "${1}" in
         'aucdtect')            message="Validating FLAC files with auCDtect..."                                         ;;
         'md5_check')           message="Verifying FLAC files MD5 Signature..."                                          ;;
         'compress_verify')     message="Compressing & Verifying FLAC files [Compression Lvl: ${compression_level}]..."  ;;
         'compress_no_test')    message="Compressing FLAC files [Compression Lvl: ${compression_level}]..."              ;;
         'test')                message="Testing integrity of FLAC files..."                                             ;;
         'replaygain_'*)
            if [[ "${1}" == 'replaygain_test' ]] ; then
               message="Generating & Applying ReplayGain to FLAC files..."
               sub_message="Testing"
            else  #  'replaygain'*'apply'
               sub_message="Applying"
            fi
         ;;
         'retag_'*)
            if [[ "${1}" == 'retag_analyze' ]] ; then
               message="Re-Tagging FLAC files..."
               sub_message="Analyzing"
            else  #  'retag_apply'
               sub_message="Re-Tagging"
            fi
         ;;
         'extract_images')      message="Extracting artwork from FLAC files..."   ;;
         'prune')
            if [[ "${remove_artwork}" != "true" ]] ; then
               # Keep artwork
               message="Removing METADATA blocks [Except: STREAMINFO,VORBIS_COMMENT,PICTURE]..."
            else
               # Remove artwork
               message="Removing METADATA blocks [Except: STREAMINFO,VORBIS_COMMENT]..."
            fi
         ;;
      esac

      # Print title message, if applicable
      if [[ -n "${message}" ]] ; then
         printf "\033[$(__row)H ${green}*${normal} ${message}\n"
      fi

      # Print sub title message, if applicable
      if [[ -n "${sub_message}" ]] ; then
         printf "\033[$(__row);3H${green}>>${normal} ${sub_message}\n"
      fi
   fi
}

#-------------------------------------------------------------------------------

__update_operation_status () {
   # Update $operation_summary[@] with the current operation status
   #
   # $1 determines which operational index to update; possible values:
   #   aucdtect          aucdtect_spectrogram        md5_check
   #   compress_verify   compress_no_test            test
   #   replaygain_test   replaygain_force_apply      replaygain_apply
   #   retag_analyze     retag_apply                 extract_images
   #   prune
   #
   # $2 is the operational status, the values of which, can be:
   #   Operation Completed       Operation Interrupted
   #   Operation Did Not Run     <integer> Issues
   #--
   case "${1}" in
      'aucdtect'*)          operation_summary['Validate with auCDtect']="${2}" ;;
      'md5_check')          operation_summary['Check MD5 Signature']="${2}"    ;;
      'compress_'*)         operation_summary['Compress FLACs']="${2}"         ;;
      'test')               operation_summary['Test FLACs']="${2}"             ;;
      'replaygain_test')    operation_summary['>> Testing']="${2}"             ;;
      'replaygain'*'apply') operation_summary['>> Applying']="${2}"            ;;
      'retag_analyze')      operation_summary['>> Analyzing']="${2}"           ;;
      'retag_apply')        operation_summary['>> Re-Tagging']="${2}"          ;;
      'extract_images')     operation_summary['Extracting Artwork']="${2}"     ;;
      'prune')              operation_summary['Prune METADATA Blocks']="${2}"  ;;
   esac
}

#-------------------------------------------------------------------------------

__print_item() {
   # $1 is the filename to print
   # $2 is the filename length
   # $3 is the number completed, ie [12/345]
   # $4 determines whether this is a sub operational item to print
   #--
   # Set up local variables
   declare -i  print_spacing='1'

   (( max_length >= $2 )) && print_spacing=$(( max_length - $2 ))

   case "$4" in
      '')
         #       08 - track.flac                           [12/345]
         printf "\033[${placement};9H%s%${print_spacing}s${magenta}%s${normal}" \
            "$1" '' "${3}"
      ;;
      'sub')
         #      50% 08 - track.flac                        [12/345]
         printf "\033[${placement};6H${yellow}%s${normal} %s%${print_spacing}s${magenta}%s${normal}" \
            " 50%" "$1" '' "${3}"
      ;;
      'half')
         #   50% 08 - track.flac                           [12/345]
         printf "\033[${placement};4H${yellow}%s${normal} %s%${print_spacing}s${magenta}%s${normal}" \
            " 50%" "$1" '' "${3}"
      ;;
      'decode')
         #       [decoding->WAV] 08 - track.flac           [12/345]
         print_spacing=$(( print_spacing - 16 ))
         printf "\033[${placement};9H${cyan}[decoding->WAV]${normal} %s%${print_spacing}s${magenta}%s${normal}" \
            "$1" '' "${3}"
      ;;
      'aucdtect_fast')
         #       [auCDtect:fast] 08 - track.flac           [12/345]
         print_spacing=$(( print_spacing - 16 ))
         printf "\033[${placement};9H${cyan}[auCDtect:fast]${normal} %s%${print_spacing}s${magenta}%s${normal}" \
            "$1" '' "${3}"
      ;;
      'aucdtect_slow')
         #       [auCDtect:slow] 08 - track.flac           [12/345]
         print_spacing=$(( print_spacing - 16 ))
         printf "\033[${placement};9H${cyan}[auCDtect:slow]${normal} %s%${print_spacing}s${magenta}%s${normal}" \
            "$1" '' "${3}"
      ;;
      'spectrogram')
         #       [spectral->PNG] 08 - track.flac           [12/345]
         print_spacing=$(( print_spacing - 16 ))
         printf "\033[${placement};9H${cyan}[spectral->PNG]${normal} %s%${print_spacing}s${magenta}%s${normal}" \
            "$1" '' "${3}"
      ;;
   esac
}

#-------------------------------------------------------------------------------

__print_status() {
   # $1 is the file/dir operation result, of which, can be:
   #   ok   fail   issue   skip
   # $2 is the basename of the file/dir
   # $3 is the filename length
   # $4 determines whether this is a sub operational message to print
   # $5 determines the action that's printed per item
   #--
   # Set up local variables
   declare -i print_spacing='0' column_placement='4'

   case "$1" in
      'ok')     color="${green}"   result="100%"  ;;
      'fail')   color="${red}"     result="fail"  ;;
      'issue')  color="${yellow}"  result="chck"  ;;
      'skip')   color="${yellow}"  result="skip"  ;;
   esac

   (( max_length >= $3 )) && print_spacing=$(( max_length - $3 ))
   [[ "$4" == 'sub' ]] && column_placement='6'

   case "$5" in
      'decode')
         action="${cyan}[decoding->WAV]${normal} "
         (( print_spacing != 0 )) && print_spacing=$(( print_spacing - 16 ))
      ;;
      'aucdtect_fast')
         action="${cyan}[auCDtect:fast]${normal} "
         (( print_spacing != 0 )) && print_spacing=$(( print_spacing - 16 ))
      ;;
      'aucdtect_slow')
         action="${cyan}[auCDtect:slow]${normal} "
         (( print_spacing != 0 )) && print_spacing=$(( print_spacing - 16 ))
      ;;
      'spectrogram')
         action="${cyan}[spectral->PNG]${normal} "
         (( print_spacing != 0 )) && print_spacing=$(( print_spacing - 16 ))
      ;;
   esac

   printf "\033[${placement};${column_placement}H${color}%s${normal} ${action}%s%${print_spacing}s" \
      "${result}" "$2" ""
}

#-------------------------------------------------------------------------------

__print_progress() {
   # Display filename and current progress of operation
   #--
   # $1 is:
   #   aucdtect          aucdtect_spectrogram        md5_check
   #   compress_verify   compress_no_test            test
   #   replaygain_test   replaygain_force_apply      replaygain_apply
   #   retag_analyze     retag_apply                 extract_images
   #   prune             decode
   #
   # $2 is percent
   # $3 is filename to print (may be truncated)
   # $4 is filename length
   #--
   # This is the length of the progress bar represented as the maxmimum
   # filename we can use.  The progress bar is displayed by taking the
   # percentage completed thus far and using the percentage to display that
   # same percentage of the filename's length (including spaces that may appear
   # after it)
   #progress_bar_length=$(( ( max_length * $2 ) / 100 ))

   case "$5" in
      'decode')
         action="${cyan}[decoding->WAV]${normal} "
         # max_length - 16: '[decoding -> WAV] ' is 18 characters long
         progress_bar_length=$(( ( ( max_length - 16 ) * $2 ) / 100 ))
      ;;
      'aucdtect_fast')
         action="${cyan}[auCDtect:fast]${normal} "
         # max_length - 16: '[auCDtect - fast] ' is 18 characters long
         progress_bar_length=$(( ( ( max_length - 16 ) * $2 ) / 100 ))
      ;;
      'aucdtect_slow')
         action="${cyan}[auCDtect:slow]${normal} "
         # max_length - 16: '[auCDtect: slow] ' is 16 characters long
         progress_bar_length=$(( ( ( max_length - 16 ) * $2 ) / 100 ))
      ;;
      'spectrogram')
         action="${cyan}[spectral->PNG]${normal} "
         # max_length - 16: '[spectral->PNG] ' is 16 characters long
         progress_bar_length=$(( ( ( max_length - 16 ) * $2 ) / 100 ))
      ;;
      '')
         progress_bar_length=$(( ( max_length * $2 ) / 100 ))
      ;;
   esac

   # If the progress bar to display is less than or equal to the filename's
   # length, print out the part of the filename that matches the percentage
   # completed, inverting the colors.  Otherwise, print out the filename,
   # inverted as well as the percentage of spacing that may be after the
   # filename (matching the percentage of completed); also inverted
   if (( progress_bar_length < $4 )) ; then
      # Below takes the current filename and 'trims' off the part of the
      # filename that hasn't doesn't match the percentage length of what's
      # completed so far (trim meaning, not highlighting that portion of the
      # filename)
      printf "\033[${placement};4H${yellow}%4s${normal} ${action}${invert}%s${normal}" \
         "${2}%" "${3:0:${progress_bar_length}}"
   else
#
#      # This prints out the the filename, inverted, as well as the current
#      # progress bar length.  Used only if the filename is less than the width
#      # of the progress bar maximum's length
      printf "\033[${placement};4H${yellow}%4s${normal} ${action}${invert}%s%$(( progress_bar_length - $4 ))s${normal}" \
         "${2}%" "${3}" ""
   fi
}

#-------------------------------------------------------------------------------

# Display the filename, clearing the progress bar and display the progress as an
# error in yellow color (for sub messages)
__print_sub_progress_issue() {
   printf "\033[${placement};6H${yellow}%s${normal} %s" \
   "chck" "${filename}"
}

#-------------------------------------------------------------------------------

# Display the filename, clearing the progress bar and display the progress
# percentage as 100% (since FLAC stops at 99%) in green (for sub messages)
__print_sub_progress_ok() {
   printf "\033[${placement};6H${green}%s${normal} %s" \
   "100%" "${filename}"
}

#-------------------------------------------------------------------------------

# Display the filename, clearing the progress bar and display the progress as an
# error in red color (for sub messages)
__print_sub_progress_failed() {
   printf "\033[${placement};6H${red}%s${normal} %s" \
   "fail" "${filename}"
}

#-------------------------------------------------------------------------------

__trap_sigint() {
   # Kill any children process and display the correct interrupt message when
   # a user sends SIGINT during script execution.
   #
   # $1 is where to place the cursor (row-wise) in order to not overwrite
   # files/directories displayed already.
   #
   # $2 determines which additional cleanup may need to be performed when
   # starting '__exit_cleanup'.  Possible values:
   #   aucdtect          aucdtect_spectrogram        md5_check
   #   compress_verify   compress_no_test            test
   #   replaygain_test   replaygain_force_apply      replaygain_apply
   #   retag_analyze     retag_apply                 extract_images
   #   prune
   #--
   __kill_jobs "$(jobs -rp)"

   # If $1 is NULL, it means that the user invoked SIGINT before any operation
   # started (eg, retag countdown or config countdown)
   if [[ -n "${1}" ]] ; then
      printf "\033[${1};2H${green}*${normal} Control-C received, generating summary. Please wait...\n"
   else
      printf "\n ${green}*${normal} Control-C received, generating summary. Please wait...\n"
   fi

   __exit_cleanup "${2}"
}

#-------------------------------------------------------------------------------

__exit_cleanup() {
   # Do any additional cleanup and check for the existence of a log file before
   # exiting script.
   #
   # $1 determines which operation requires additional cleanup.  This value is
   # normally obtained from $2 in the '__trap_sigint' function.  Possible
   # values:
   #   aucdtect          aucdtect_spectrogram        md5_check
   #   compress_verify   compress_no_test            test
   #   replaygain_test   replaygain_force_apply      replaygain_apply
   #   retag_analyze     retag_apply                 extract_images
   #   prune
   #--
   case "${1}" in
      'aucdtect'*)
         # Remove temporarily created WAV files (if any)
         rm -f "${directory}"/**/*_redoflacs_"$$".wav
      ;;
      'compress_'*)
         # Remove temporarily encoded FLAC files
         rm -f "${directory}"/**/*.tmp,fl-ac+en\'c
      ;;
   esac

   # Update status for the current operation
   __update_operation_status "${1}" 'Operation Interrupted'

   if [[ -f "${log_file}" ]] ; then
      # Print out log exists to STDERR
      __message_log_exists "${1}"

      # Create and format log
      __create_log "${1}"
   fi

   # Restore old stty settings, make stty happy
   # by redirecting /dev/stderr
   stty ${old_stty} < /dev/stderr

   # Restore the cursor
   printf "\033[?25h"

   # Remove temporary FIFO and leave just the file
   # descriptor available
   rm -f "${tmp_fifo}"

   # Display Summary Of Operations
   __summary

   exit 130
}

#-------------------------------------------------------------------------------

# Display script version
__print_version() { printf "Version %s\n" "${version}" ;}

#-------------------------------------------------------------------------------

__metaflac_version() {
   # Obtain metaflac version information to test on
   #--
   # Metaflacs version (ie: '2' in 1.2.1)
   IFS='.' read -r _ metaflac_version _ < <(metaflac --version)

   # Return the above integer
   printf "%s" "${metaflac_version}"
}

#-------------------------------------------------------------------------------

__kill_jobs() {
   # Kill any children process (obtained via $@), hiding errors and suppressing
   # the shell's notification of terminated jobs
   #--
   for pid in $@ ; do
      kill $pid 2>/dev/null
      wait $pid 2>/dev/null
   done
}

#-------------------------------------------------------------------------------

__row() {
   # Print out the current cursor row position
   #--
   declare old_stty  row_pos        # Intialize local variables
   exec < /dev/tty                  # Set a new TTY to read in STDIN
   old_stty="$(stty -g)"            # Store current TTY settings
   stty raw -echo min 0             # Current TTY set at an absolute minimum
   printf "\033[6n" > /dev/tty      # Send escape into new TTY

   # Read in escape sequence output from TTY.  The escape sequence looks like:
   #   ^[<integer>;<integer>R
   #--
   # This is what is read in below:  ^[<integer>
   IFS=';' read -r -d'R' row_pos _ < /dev/tty 

   stty "${old_stty}"               # Restore the old TTY settings
   printf "%s" "${row_pos#??}"      # Return row position (removes: ^[)
}

#-------------------------------------------------------------------------------

# Check if we need to scroll the terminal up depending on how much room is left,
# relative to the number of jobs to process
__scroll_terminal() {
   # Grab the first line of 'stty -a' output
   # Redirecting '/dev/stderr' to 'stty' allows valid arguments
   read -r _ _ _ _ lines _ columns _ < <(stty -a < /dev/stderr)

   # Remove semicolons from obtain columns and lines
   #--
   # Terminal width
   columns="${columns%;}"

   # Terminal height
   lines="${lines%;}"

   # If the total number of files to process is less than jobs specified,
   # then set the number of lines to remove from the terminal scroll as the
   # difference of the number of jobs minus the total number of files
   if (( ${#total_items[@]} < jobs )) ; then
      # This variable will be used for '__scroll_terminal' as ${1}
      local remove_from_scroll="$(( jobs - ${#total_items[@]} ))"
   fi

   # If ${remove_from_scroll} is NULL, then the remaining lines we have left is
   # the number of lines available (in the terminal) minus the row we are
   # currently on.  If ${remove_from_scroll} is _NOT_ NULL, the remaining lines
   # we have left is the same with the addition of ${remove_from_scroll}.  This
   # enforces we are able to scroll the terminal correctly in the event the user
   # specified more jobs than there are files/directories to process
   if [[ -z "${remove_from_scroll}" ]] ; then
      # Obtain the remaining lines left in the current terminal
      remaining_lines=$(( lines - $(__row) ))
   else
      # Obtain the remaining lines left in the current terminal as well as
      # adding in the the number of lines we don't want to scroll
      remaining_lines=$(( lines - $(__row) + remove_from_scroll ))
   fi

   # If the remaining lines is less than the jobs used, the terminal will not
   # have enough room for the script to place lines, so we will have to
   # non-descructively scroll the terminal up enough lines to allow for the
   # current operations to be printed correctly
   if (( remaining_lines < jobs )) ; then
      # Obtain the number of lines need to equal the current number of jobs
      local lines_to_scroll=$(( jobs - remaining_lines ))

      # This scrolls the terminal up by the number of lines to scroll
      # This can be accomplished via (not very portable):
      #   printf "\033[<integer>S"    # Doesn't work in screen/tmux
      for ((i=1 ; i<=lines_to_scroll ; i++)) ; do
         printf "\n"
      done

      # The cursor is set to the difference of the lines to scroll
      printf "\033[$(( $(__row) - lines_to_scroll ))H"
   fi
}

#-------------------------------------------------------------------------------

__get_percent_complete() {
   # $1 is the operation to choose how to obtain the percentage, which can be:
   #   aucdtect          aucdtect_spectrogram        md5_check
   #   compress_verify   compress_no_test            test
   #   replaygain_test   replaygain_force_apply      replaygain_apply
   #   retag_analyze     retag_apply                 extract_images
   #   prune             decode
   #
   # $2 is a (possibly multiline) string of text from a command binary's output
   # with the percentage contained within
   #--
   case "$1" in
      'compress_'*)
         percent="${2//$'\b'/}"                        # Remove backspaces
         percent="${percent##*: }"                     # complete0, ratio=0.307
         percent="${percent##*complete, ratio=?.???}"  # Percent (integer)
      ;;
      'test')
         percent="${2##* }"                            # Percent (integer)
      ;;
      'decode')
         percent="${2//$'\b'}"                         # Remove backspaces
         percent="${percent##*: }"                     # complete0
         percent="${percent##*complete}"               # Percent (integer)
      ;;
      'aucdtect')
         percent="${2##*[}"                            # Percent (integer)
      ;;
      'spectrogram')
         percent="${2##*In:}"                          # Percent (floating)
         percent="${percent%%.*}"                      # Percent (integer)
      ;;
   esac

   # Default to '0' if percentage is not an integer
   if [[ "${percent}" =~ ^[[:digit:]]+$ ]] ; then
      printf "%d" $percent
   else
      printf "%d" 0
   fi
}

#-------------------------------------------------------------------------------

# Store the position of the current job being displayed
__store_position() {
   # If the current job(s) are the first set, we'll use the iteration
   # (starting at 0 -- hence the minus 1) of the job to start
   if (( iteration <= jobs )) ; then
      printf "$(( iteration - 1 ))\n" >&3
   else
      # Print the position of the current jobs into file descriptor (3) to be
      # stored by 'read' upon starting the next job
      printf "${previous_placement}\n" >&3
   fi
}

#-------------------------------------------------------------------------------

# Force the creation of a new configuration file
__new_config() {
   # Check if configuration file exists based of ${EUID}.  If it doesn't
   # exist, create one
   if (( EUID == 0 )) ; then
      # User is root
      #
      # Configuration file location
      config_file="/etc/redoflacs.conf"

      # If there already is a configuration file, do not overwrite it
      if [[ -f "${config_file}" ]] ; then
         config_file="/etc/_$$.redoflacs.conf"
      fi
   else
      # User is _NOT_ root
      #
      # Configuration file location
      config_file="${HOME}/.config/redoflacs/config"

      # If there already is a configuration file, do not overwrite it
      if [[ -f "${config_file}" ]] ; then
         config_file="${HOME}/.config/redoflacs/_$$.config"
      fi
   fi

   # Creates the (new) configuration file
   __create_config

   # Explain to user where to find the new configuration file
   __info "A new configuration file has been created here:\n"
   __info "${cyan}${config_file}${normal}\n\n"

   __info "It's recommended to review the new configuration file\n"
   __info "and transfer over any changes you made in your old\n"
   __info "configuration file.\n\n"

   __info "After making the changes (if any), rename the new\n"
   __info "configuration file to your old configuration file\n"
   __info "name.  Here is the command you could use:\n"

   if (( EUID == 0 )) ; then
      __info "${cyan}mv${normal} ${cyan}${config_file}${normal} ${cyan}/etc/redoflacs.conf${normal}\n"
   else
      __info "${cyan}mv${normal} ${cyan}${config_file}${normal} ${cyan}${HOME}/.config/redoflacs/config${normal}\n"
   fi
}

#-------------------------------------------------------------------------------

# Create a configuration file
__create_config() {
   create_config="################################################################################
#                                                                              #
#                         REDOFLACS USER CONFIGURATION                         #
#                         ----------------------------                         #
#                                                                              #
#  Any line that is _NOT_ prepended with a '#' will be interpreted as an       #
#  option (except for blank lines -- these are not interpreted)                #
#                                                                              #
#  See \`redoflacs --help\` for a detailed description of each parameter         #
#                                                                              #
################################################################################

#-------------------------------------------------------------------------------
#  :: TAGGING SECTION ::
#-------------------------------------------------------------------------------
# List the tags to be kept in each FLAC file.  The default is listed below.
#
# Another common tag not added by default is ALBUMARTIST.  Uncomment ALBUMARTIST
# below to allow script to keep this tag.

TITLE
ARTIST
#ALBUMARTIST
ALBUM
DISCNUMBER
DATE
TRACKNUMBER
TRACKTOTAL
GENRE

# The COMPRESSION tag is a custom tag to allow the script to determine which
# level of compression the FLAC file(s) has/have been compressed at.
COMPRESSION

# The RELEASETYPE tag is a custom tag the author of this script uses to
# catalogue what kind of release the album is (ie, Full Length, EP, Demo, etc.).
RELEASETYPE

# The SOURCE tag is a custom tag the author of this script uses to catalogue
# which source the album has derived from (ie, CD, Vinyl, Digital, etc.).
SOURCE

# The MASTERING tag is a custom tag the author of this script uses to catalogue
# how the album has been mastered (ie, Lossless, or Lossy).
MASTERING

# The REPLAYGAIN tags below, are added by the '-g, --replaygain' or
# '-G, --replaygain-noforce' argument.  If you want to keep the replaygain tags,
# make sure you leave these here.
REPLAYGAIN_REFERENCE_LOUDNESS
REPLAYGAIN_TRACK_GAIN
REPLAYGAIN_TRACK_PEAK
REPLAYGAIN_ALBUM_GAIN
REPLAYGAIN_ALBUM_PEAK

#== :: END TAGGING SECTION :: ==================================================

#-------------------------------------------------------------------------------
#  :: OPTIONS ::
#-------------------------------------------------------------------------------
#~~~~~~~~~~~~~~~~~~
#  REMOVE ARTWORK
#~~~~~~~~~~~~~~~~~~
# Set whether to remove embedded artwork within FLAC files.  By default, this
# script will remove any artwork it can find, whether it's in the legacy
# COVERART tag or METADATA_BLOCK_PICTURE.  Set 'remove_artwork' as 'true' to
# remove embedded artwork.  All other values are intepreted as 'false'.
remove_artwork=\"true\"

#~~~~~~~~~~~~~~~~~~~
#  SET COMPRESSION
#~~~~~~~~~~~~~~~~~~~
# Set the type of COMPRESSION to compress the FLAC files.  Numbers range from
# '1-8', with '1' being the lowest compression and '8' being the highest
# compression.  The default is '8'.
compression_level=\"8\"

#~~~~~~~~~~~~~~~~~~~~~~~
#  ERROR LOG DIRECTORY
#~~~~~~~~~~~~~~~~~~~~~~~
# Set the where you want the error logs to be placed.  By default, they are
# placed in the user's HOME directory.
error_log=\"\${HOME}\"

#~~~~~~~~~~~~~~~~~~~~~~~
#  AUCDTECT SKIP LOSSY
#~~~~~~~~~~~~~~~~~~~~~~~
# Set whether FLAC files should be skipped if the MASTERING tag is already set
# as 'Lossy' when analyzed with auCDtect.  Set 'skip_lossy' as 'true' to to skip
# FLAC files that have the tag: 'MASTERING=Lossy'.  All other values are
# intepreted as 'false'.
skip_lossy=\"true\"

#~~~~~~~~~~~~~~~~~~~~~~~~~
#  SPECTROGRAM DIRECTORY
#~~~~~~~~~~~~~~~~~~~~~~~~~
# Set where the created spectrogram files should be placed.  By default, the
# spectrogram images will be placed in the same directory as the tested FLAC
# files. Each image will have the same name as the tested FLAC file but with
# the extension '.png'.
#
# All values for 'spectrogram_location' are interpreted as a directory.  If left
# blank, the default location will be used.
#
# An example of a user-defined location:
#    spectrogram_location=\"\${HOME}/Spectrogram_Images\"
#
# See '--help' or '-h' for more information.
spectrogram_location=\"\"

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#  EXTRACTED ARTWORK DIRECTORY
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Set where the extracted artwork images should be placed.  By default, the
# extracted images will be placed in a subdirectory where the FLAC file is
# located.  The subdirectory has the same name as the FLAC file that's processed
# with a unique string appended to it:
#
#    [ Default directory example ]
#    /path/to/music/01_file.flac                          # FLAC with artwork
#    /path/to/music/01_file.flac_[redoflacs_art]_4342/    # Example subdirectory
#
# All values for 'artwork_location' are interpreted as a directory.  If left
# blank, the default location will be used.
#
# If there is a user-defined location, the extracted images will be placed in a
# subdirectory in that location with a naming scheme similar to the above
# example, but prefaced with the current number of FLAC files being processed:
#
#    [ User-defined location ]
#    artwork_location=\"\${HOME}/artwork\"
#
#    [ FLAC file to be processed ]
#    /path/to/music/01_file.flac
#
#    [ Resultant subdirectory with extracted artwork ]
#    \${HOME}/artwork/[1] 01_file.flac_[redoflacs_art]_4342/
#
# See '--help' or '-h' for more information.
artwork_location=\"\"

#~~~~~~~~~~~~~~~~~~~~~~~~
#  PREPEND TRACK NUMBER
#~~~~~~~~~~~~~~~~~~~~~~~~
# Change whether the '-r, --retag' operation will re-tag singular track numbers
# and track totals from:
#    [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
# to
#    [ 01, 02, 03, 04, 05, 06, 07, 08, 09 ]
#
# For example, if you had:
#    TRACKNUMBER=4
#     TRACKTOTAL=9
#
# You would end up with:
#    TRACKNUMBER=04
#     TRACKTOTAL=09
#
# This is enabled by setting 'prepend_zero' option as 'true'.  All other values
# are interpreted as 'false'.
prepend_zero=\"false\"

#== :: END OPTIONS :: ====== DO NOT DELETE THIS LINE! ====== :: REVISION 2 :: =="

   # Print out the configuration file to the specified location (either system-
   # wide or local)
   printf "%s\n" "${create_config}" > "${config_file}"
}

#-------------------------------------------------------------------------------

__parse_config() {
   # Parse the user/system configuration file
   #
   # Load the config file into an array and process each line, grabbing the
   # user-specified FLAC tags and setting up the configuration variables
   #--
   mapfile -n0 -t config_array < "${config_file}"

   for line in "${config_array[@]}" ; do
      # Run through the array, evaluating the configuration option into the
      # current enviroment and storing the tag fields into an array
      #--
      # Test and use only the tag and config options
      if [[ -n "${line###*}" && -n "${line}" ]] ; then
         config_option="${line//*=*/}"  # Null if line is a config option

         if [[ -n "${config_option}" ]] ; then
            tags+=( "${line^^}" )      # Store uppercase tag in array
         else
            eval "${line}"             # Put config option in environment
         fi
      fi
   done
}

#-------------------------------------------------------------------------------

__check_config_version() {
   # Check current configuration, if the version in the script is newer
   # warn user and display a countdown before starting script
   #--
   # Check if configuration file exists based of ${EUID}.  If it doesn't
   # exist, create one
   if (( EUID == 0 )) ; then
      # User is root
      #
      # Configuration file location
      config_file="/etc/redoflacs.conf"
   else
      # User is _NOT_ root
      #
      # Configuration file location
      config_file="${HOME}/.config/redoflacs/config"
   fi

   # Load configuration file into an array
   mapfile -n0 -t config_array < "${config_file}"

   # Obtain only the last line of the config
   config_last_line="${config_array[$(( ${#config_array[@]} - 1 ))]}"

   # Remove everything from the last line, except the REVISION number
   #
   # Below leaves:
   #  '<revision number> :: =='
   user_config_revision="${config_last_line#*REVISION }"
   # Obtains REVISION number
   user_config_revision="${user_config_revision% ::*}"

   # Check if ${user_config_revision} is an integer.  If not, display countdown
   # and warn user of new config file, else test if the user config revision is
   # less than the script config revision
   if [[ "${user_config_revision}" =~ ^[[:digit:]]+$ ]] ; then
      # If ${script_config_revision} is greater than ${user_config_revision}
      # warn user and display countdown
      if (( script_config_revision > user_config_revision )) ; then
         # Display warning and countdown
         __countdown_config ; printf '\n\n'
      fi
   else
      # Display warning and countdown
      __countdown_config ; printf '\n\n'
   fi
}

#-------------------------------------------------------------------------------

__truncate_filename() {
   # Truncate the processed item's filename if it's bigger than terminal width,
   # returning the filename (possibly truncated) as well as the length of the
   # filename (in characters)
   #
   # $1 is the filename to truncate/process
   #--
   # Set up local variables
   declare    filename
   declare -i filename_length  truncated_length

   # Basename of file/directory
   if [[ "${1#"${1%?}"}" == '/' ]] ; then  # Last character is a '/'
      # Directory
      filename="${1%?}"                    # Remove last character
      filename="${filename##*/}/"          # Basename of directory, append '/'
   else
      # File
      filename="${1##*/}"                  # Basename of file
   fi

   filename="${filename//$'\n'/?}"         # Replace '\n' with '?'

   # Column length of filename. 'wc -L' handles multi-byte characters correctly
   filename_length="$(wc -L <<< "${filename}")"

   # If filename is longer than the width allowed in the terminal, truncate it
   if (( filename_length > max_length )) ; then
      # Truncate filename by $max_length and grab the _real_ length
      truncated_length="$(wc -L <<< "${filename:0:${max_length}}")"

      until (( truncated_length == max_length )) ; do
         # Multibyte characters can make $truncated_length smaller than
         # $max_length, so keep slicing a character off $max_length
         # until $truncated_length equals $max_length
         #--
         ((--max_length))
         truncated_length="$(wc -L <<< "${filename:0:${max_length}}")"
      done

      # Return truncated filename with ellipsis and filename length
      printf "%s${unit_separator}%d" "${filename:0:$((max_length - 2))}" "${filename_length}"
   else
      # Return filename and filename length
      printf "%s${unit_separator}%d" "${filename}" "${filename_length}"
   fi
}

#-------------------------------------------------------------------------------

# Determine number of jobs to run via the number
# of CPUs/cores available
__find_cores() {
   # Check if /proc is mounted by comparing device numbers of
   # /proc and / and see if they don't match (ie, /proc is mounted)
   if (( $(stat -c %d /proc) == $(stat -c %d /) )) ; then
      # /proc is not mounted, default to 2 jobs
      jobs_display="(Default)"
      jobs=2
   else
      # /proc is mounted, check for cpuinfo
      if [[ ! -f /proc/cpuinfo ]] ; then
         # /proc/cpuinfo doesn't exist
         jobs_display="(Default)"
         jobs=2
      else
         # /proc/cpuinfo exists, find total number
         # of cores to use

         # Store contents of /proc/cpuinfo into
         # cores_array
         mapfile -n0 -t cores_array < /proc/cpuinfo

         # For each line, if matched string is found,
         # add processor number to jobs variable
         for i in "${cores_array[@]}" ; do
            if [[ "${i}" == processor$'\t':\ * ]] ; then
               jobs="${i#processor$'\t': }"
            fi
         done

         # Add +1 to jobs since the number of useable cores
         # starts at 0
         ((jobs++))
         jobs_display="(/proc/cpuinfo)"
      fi
   fi
}

#-------------------------------------------------------------------------------

# Find all the artwork blocks in the current FLAC file, storing each instance in
# an array to be processed
__find_artwork() {
   # Grab all the PICTURE blocks from current FLAC file, storing into an array
   mapfile -n0 -t artwork_blocks < <(metaflac --list --block-type=PICTURE "${1}")

   # Run through each line obtained above (stored into an array) and parse out
   # the block type we want
   for j in "${!artwork_blocks[@]}" ; do

      # If the current line has shows the type of block but isn't (PICTURE),
      # then we have the correct line (block type)
      if [[ "${artwork_blocks[${j}]}" == '  type: '* ]] && [[ "${artwork_blocks[${j}]}" != '  type: 6 (PICTURE)' ]] ; then

         # Obtain the METADATA block ID (4 lines above matched line)
         artwork_block_id="${artwork_blocks[$(( j - 4 ))]##* #}"

         # Obtain the MIME type of the image stored in the METADATA block,
         # to be used as the file extension
         artwork_extension="${artwork_blocks[$(( j + 1 ))]##  MIME type: */}"

         # If the image found is 'jpeg', use 'jpg' instead for consistency
         artwork_extension="${artwork_extension/jpeg/jpg}"

         # Obtain the PICTURE type, represented as a number
         artwork_type_number="${artwork_blocks[${j}]#  type: }"
         artwork_type_number="${artwork_type_number%% *}"

         # Obtain the PICTURE type, represented as a string/description.  All
         # forward slashes '/' are converted to hyphens '-', since this
         # description will be used as part of the image filename
         artwork_type_description="${artwork_blocks[${j}]#  type: * (}"
         artwork_type_description="${artwork_type_description%)}"
         artwork_type_description="${artwork_type_description//\//-}"

         # Check the PICTURE number we obtained and store the PICTURE
         # description and image extension into it's own array.  This will
         # allow for multiple artwork images of the same type to be stored
         # successfully and extracted
         case "${artwork_type_number}" in
            0)
               # [Artwork Description] Other
               artwork_other+=( "${artwork_type_description}.${artwork_extension}" )
            ;;
            1)
               # [Artwork Description] 32x32 pixels 'file icon' (PNG only)
               artwork_file_icon+=( "${artwork_type_description}.${artwork_extension}" )
            ;;
            2)
               # [Artwork Description] Other file icon
               artwork_other_file_icon+=( "${artwork_type_description}.${artwork_extension}" )
            ;;
            3)
               # [Artwork Description] Cover (front)
               artwork_cover_front+=( "${artwork_type_description}.${artwork_extension}" )
            ;;
            4)
               # [Artwork Description] Cover (back)
               artwork_cover_back+=( "${artwork_type_description}.${artwork_extension}" )
            ;;
            5)
               # [Artwork Description] Leaflet page
               artwork_leaflet+=( "${artwork_type_description}.${artwork_extension}" )
            ;;
            6)
               # [Artwork Description] Media (e.g. label side of CD)
               artwork_media_label+=( "${artwork_type_description}.${artwork_extension}" )
            ;;
            7)
               # [Artwork Description] Lead artist/lead performer/soloist
               artwork_lead_artist+=( "${artwork_type_description}.${artwork_extension}" )
            ;;
            8)
               # [Artwork Description] Artist/performer
               artwork_artist+=( "${artwork_type_description}.${artwork_extension}" )
            ;;
            9)
               # [Artwork Description] Conductor
               artwork_conductor+=( "${artwork_type_description}.${artwork_extension}" )
            ;;
            10)
               # [Artwork Description] Band/Orchestra
               artwork_band+=( "${artwork_type_description}.${artwork_extension}" )
            ;;
            11)
               # [Artwork Description] Composer
               artwork_composer+=( "${artwork_type_description}.${artwork_extension}" )
            ;;
            12)
               # [Artwork Description] Lyricist/text writer
               artwork_lyricist+=( "${artwork_type_description}.${artwork_extension}" )
            ;;
            13)
               # [Artwork Description] Recording Location
               artwork_recording_location+=( "${artwork_type_description}.${artwork_extension}" )
            ;;
            14)
               # [Artwork Description] During recording
               artwork_during_recording+=( "${artwork_type_description}.${artwork_extension}" )
            ;;
            15)
               # [Artwork Description] During performance
               artwork_during_performance+=( "${artwork_type_description}.${artwork_extension}" )
            ;;
            16)
               # [Artwork Description] Movie/video screen capture
               artwork_movie+=( "${artwork_type_description}.${artwork_extension}" )
            ;;
            17)
               # [Artwork Description] A bright coloured fish
               artwork_fish+=( "${artwork_type_description}.${artwork_extension}" )
            ;;
            18)
               # [Artwork Description] Illustration
               artwork_illustration+=( "${artwork_type_description}.${artwork_extension}" )
            ;;
            19)
               # [Artwork Description] Band/artist logotype
               artwork_band_logo+=( "${artwork_type_description}.${artwork_extension}" )
            ;;
            20)
               # [Artwork Description] Publisher/Studio logotype
               artwork_publisher_logo+=( "${artwork_type_description}.${artwork_extension}" )
            ;;
            *)
               # Shouldn't happen as the valid artwork types are only 0-20
               __error "This is a BUG! Please report to:\n" >&2
               __error "${cyan}https://github.com/sirjaren/redoflacs/issues/new${normal}\n" >&2

               exit 1
            ;;
         esac
      fi
   done
}

#-------------------------------------------------------------------------------

# Extract artwork image from the specified artwork block ID in the PICTURE block
# of the current FLAC file
__do_extract() {
   # $@ is the name of the artwork filename with the extension
   metaflac \
      --block-number="${artwork_block_id}" \
      --export-picture-to="${artwork_directory}/${@}" \
      "${i}"
}

#-------------------------------------------------------------------------------

# Top banner displaying invocation settings
__top_banner() {
   # If Redo Tags is called, create the necessary spacing
   if [[ "${retag_flac}" == "true" ]] ; then
      printf '\n\n'
   fi

   # Find FLAC version
   read -r _ flac_version < <(flac --version)

   # Top title line
   printf " ${blue}%s${normal}\n" \
      "---------------------------------------------------"

   # Title
   printf "%16sRuntime Information\n"

   # Bottom title line
   printf " ${blue}%s${normal}\n" \
      "-------------------------+-------------------------"

   # Script version
   printf "                redoflacs ${blue}|${normal} ${cyan}%s${normal}\n" \
      "${version}"

   # FLAC version
   printf "                     FLAC ${blue}|${normal} ${cyan}%s${normal}\n" \
      "${flac_version}"

   # Number of Jobs
   printf "                     Jobs ${blue}|${normal} ${cyan}%s %s${normal}\n" \
      "${jobs}" "${jobs_display}"

   # Log directory
   printf "            Log Directory ${blue}|${normal} ${cyan}%s${normal}\n" \
      "${error_log}/"

   # Configuration directory
   if (( EUID == 0 )) ; then
      # Root: System-wide configuration
      config_directory="/etc/"
   else
      # Non root: User configuration
      config_directory="~/.config/redoflacs/"
   fi
   printf "         Config Directory ${blue}|${normal} ${cyan}%s${normal}\n" \
      "${config_directory}"

   # Bottom banner line
   printf " ${blue}%s${normal}\n" \
      "-------------------------+-------------------------"

   # Message indicating the searching of FLAC files
   __info "Finding FLAC files to process..."
}

# Below creates the '[ ok ]' message to print after the info
# line above.  This will be displayed when all the FLAC files
# have been mapped to an array
__processed_flacs_ok() {
   printf "%11s${blue}[ ${green}ok${blue} ]${normal}\n" ""
}

#-------------------------------------------------------------------------------

# Create a countdown function for the metadata
# to allow user to quit script safely
__countdown_metadata() {
   # Trap SIGINT (Control-C) to abort cleanly
   trap __trap_sigint SIGINT

   # Warning message
   __error "${yellow}CAUTION!${normal} These are the tag fields that will be kept\n" >&2
   __error "when re-tagging the selected files:\n" >&2

   # Creates the listing of tags to be kept
   for i in "${tags[@]}" ; do
      printf "     ${i}\n" >&2
   done

   # Warning message about embedded coverart
   __error "By default, this script will ${cyan}REMOVE${normal} the legacy ${cyan}COVERART${normal} tag.\n" >&2
   __error "Add the ${cyan}COVERART${normal} tag to the list of tags to be kept in the\n" >&2
   __error "${cyan}TAGGING SECTION${normal} of the configuration file.\n\n" >&2

   __error "Keep in mind, if the ${cyan}remove_artwork${normal} option is set to ${cyan}false${normal},\n" >&2
   __error "embedded artwork in the ${cyan}PICTURE${normal} block will be kept when using\n" >&2
   __error "the ${cyan}-p, --prune${normal} option as well.\n\n" >&2

   __warn "Waiting ${red}10${normal} seconds before starting program...\n" >&2
   __warn "Ctrl+C (Control-C) to abort...\n" >&2
   __info "Starting in: "

   # 10 second countdown
   for count in {10..1} ; do
      printf "${red}%d ${normal}" "$count"
      read -t1  # Sleep 1
   done

   printf '\n'  # Advance countdown to next line
}

#-------------------------------------------------------------------------------

# Displays a countdown after a newer config is found than what
# the user has.  Allows user to quit script before proceeding
__countdown_config() {
   # Trap SIGINT (Control-C) to abort cleanly
   trap __trap_sigint SIGINT

   # Warning message
   __info "There is a newer configuration file available!\n\n"

   __warn "It is recommended you generate a new configuration\n" >&2
   __warn "file for use with this program.\n\n" >&2

   __warn "To generate a new configuration file, run:\n" >&2
   __warn "${cyan}redoflacs --new-config${normal}\n\n" >&2

   __warn "The above command will _NOT_ overwrite your\n" >&2
   __warn "current configuration file.\n\n" >&2

   __warn "Waiting 10 seconds before starting program...\n" >&2
   __warn "Ctrl+C (Control-C) to abort...\n" >&2
   __info "Starting in: "

   # 10 second countdown
   for count in {10..1} ; do
      printf "${red}%s${normal}%s" "$count" " "
      read -t1 # Sleep 1
   done
}

#-------------------------------------------------------------------------------

__get_directory_list() {
   # Return a listing of the total base directories housing all the found FLACs
   #--
   declare     previous_dir  current_dir  #  Set up local variable(s)
   declare -ga total_dirs                 #  Set up global array

   for flac in "$@" ; do
      # Run through total FLAC files array, printing out each unique directory
      #--
      current_dir="${flac%/*}"
      if [[ "${previous_dir}" != "${current_dir}" ]] ; then
         total_dirs+=( "${current_dir}/" )
      fi
      previous_dir="${current_dir}"  # Set current directory to previous
   done
}

#-------------------------------------------------------------------------------

# Clear old file descriptor (3) and create a new
# FIFO that's tied to file discriptor 3
__clear_tmp_fd() {
   # Close FIFO (if already open)
   exec 3<&- 3>&-

   # Open FIFO for reading and writing on file descriptor '3'
   exec 3<>"${tmp_fifo}"
}

#-------------------------------------------------------------------------------

__num_issues() {
   # Display the number of issues an operation may have by reading in the
   # number of ticks from the temporary issues_count file, returning the proper
   # message for use with the Summary Of Operations table
   #--
   read -r fail_count < "${issue_ticks}"   # Read in number of issue ticks

   if (( ${#fail_count} == 1 )) ; then
      printf "%s Issue\n" "${#fail_count}"
   else
      printf "%s Issues\n" "${#fail_count}"
   fi
}

#-------------------------------------------------------------------------------

# Obtain and process the positional parameters invoked
# with the script
__process_positional_parameters() {
   # If no arguments are made to the script show usage & short help
   if (( ${#} == 0 )) ; then
      __short_help
      exit 1
   fi

   # Add case where only one argument is specified
   if (( ${#} == 1 )) ; then
      case "${1}" in
         '--version'|'-v')     __print_version ; exit 0 ;;
         '--help'|'-h')
            # Create the temporary file in which a man page will be
            # generated
            tmp_man_page="/tmp/redoflacs_man_$$.1"

            # Generate the man page to the above temporary location
            __long_help

            # Read the man page with 'man'
            man "${tmp_man_page}"

            # After reading, remove temporary file and exit
            rm -f "${tmp_man_page}"

            exit 0
         ;;
         '--new-config'|'-o')  __new_config ; exit 0 ;;
         *)                __usage      ; exit 1 ;;
      esac
   fi

   # Add case where two arguments are specified and the
   # arguments called are not to have anything after them
   if (( ${#} == 2 )) ; then
      case "${1}" in
         '--jobs='[[:digit:]]*|'-j'[[:digit:]]*)  __usage ; exit 1 ;;
         '--no-color'|'-n')                       __usage ; exit 1 ;;
         '--version'|'-v')                        __usage ; exit 1 ;;
         '--new-config'|'-o')                     __usage ; exit 1 ;;
         '--help'|'-h')                           __usage ; exit 1 ;;
      esac
   fi

   # Separate the long and short style arguments into their
   # own arrays as well as capture the last non-arguements, to
   # prevent multiple directories being called
   for i in "${@}" ; do
      if [[ "${i}" == --* ]] ; then
         long_style_arguments_array+=( "${i}" )
      elif [[ "${i}" == -* ]] ; then
         short_style_arguments_array+=( "${i}" )
      else
         non_arguments_array+=( "${i}" )
      fi
   done

   # If there are 0 (zero) directories or more than 1, exit script
   if (( ${#non_arguments_array[@]} == 0 || ${#non_arguments_array[@]} > 1 )) ; then
      __usage
      exit 1
   fi

   # If there were any long style arguments called, convert them
   # to short style in order for getopts to be able to process
   # them correctly (ignoring '--help', '--version', '--new-config' since
   # this is taken care of above).  Add invalid arguments to it's
   # own array

   if [[ -n "${long_style_arguments_array[@]}" ]] ; then
      for i in "${long_style_arguments_array[@]}" ; do
         case "${i}" in
            '--aucdtect')             converted_arguments_array+=( -a )   ;;
            '--aucdtect-spectrogram') converted_arguments_array+=( -A )   ;;
            '--md5check')             converted_arguments_array+=( -m )   ;;
            '--compress')             converted_arguments_array+=( -c )   ;;
            '--compress-notest')      converted_arguments_array+=( -C )   ;;
            '--test')                 converted_arguments_array+=( -t )   ;;
            '--replaygain')           converted_arguments_array+=( -g )   ;;
            '--replaygain-noforce')   converted_arguments_array+=( -G )   ;;
            '--retag')                converted_arguments_array+=( -r )   ;;
            '--extract-artwork')      converted_arguments_array+=( -e )   ;;
            '--prune')                converted_arguments_array+=( -p )   ;;
            '--all')                  converted_arguments_array+=( -l )   ;;
            '--reallyall')            converted_arguments_array+=( -L )   ;;
            '--no-color')             converted_arguments_array+=( -n )   ;;

            # Set number of jobs to run via the required
            # integer argument after '-j'
            '--jobs='[[:digit:]]*)    jobs="${i##*=}"                     ;;

            '--version')     __usage ; exit 1 ;;
            '--help')        __usage ; exit 1 ;;
            '--new-config')  __usage ; exit 1 ;;
            *)
               # Set invalid argument into array
               invalid_arguments_array+=( "${i}" )
            ;;
         esac
      done
   fi

   # If there were any short style arguments called, go through
   # them, adding the valid arguments to the "converted_arguments"
   # array and adding invalid arguments to it's own array
   if [[ -n "${short_style_arguments_array[@]}" ]] ; then
      while getopts ":LlcCtgGaAmeprnj:hvo" arguments "${short_style_arguments_array[@]}" ; do
         case "${arguments}" in
            L) converted_arguments_array+=( -L ) ;;
            a) converted_arguments_array+=( -a ) ;;
            A) converted_arguments_array+=( -A ) ;;
            m) converted_arguments_array+=( -m ) ;;
            c) converted_arguments_array+=( -c ) ;;
            C) converted_arguments_array+=( -C ) ;;
            t) converted_arguments_array+=( -t ) ;;
            g) converted_arguments_array+=( -g ) ;;
            G) converted_arguments_array+=( -G ) ;;
            r) converted_arguments_array+=( -r ) ;;
            e) converted_arguments_array+=( -e ) ;;
            p) converted_arguments_array+=( -p ) ;;
            l) converted_arguments_array+=( -l ) ;;
            n) converted_arguments_array+=( -n ) ;;

            j)
               # Set number of jobs to run via the required
               # integer argument after '-j'
               jobs="${OPTARG}"

               # Do not allow jobs to be '0'
               if (( jobs == 0 )) ; then
                  # Currently, this is just for '-j' so we can explicity
                  # specify it
                  parameter_errors_array+=( "${cyan}-j${normal} requires a non-zero integer after it (eg. ${cyan}-j11${normal})." )
               else
                  converted_arguments_array+=( -j )
               fi
            ;;

            h) converted_arguments_array+=( -h ) ;;
            v) converted_arguments_array+=( -v ) ;;
            o) converted_arguments_array+=( -o ) ;;

            :)
               # Currently, this is just for '-j' so we can explicity
               # specify it
               parameter_errors_array+=( "${cyan}-${OPTARG}${normal} requires a non-zero integer after it (eg. ${cyan}-${OPTARG}11${normal})." )
            ;;
            ?)
               # Set invalid argument from getopts into array using
               # ${OPTARG}
               invalid_arguments_array+=( "-${OPTARG}" )
            ;;
         esac
      done
   fi

   # If there were invalid arguments called, display them and
   # exit script
   if [[ -n "${invalid_arguments_array[@]}" || -n "${parameter_errors_array[@]}" ]] ; then
      __usage

      if [[ -n "${invalid_arguments_array[@]}" ]] ; then
         __error "\nInvalid options:" >&2

         for i in "${invalid_arguments_array[@]}" ; do
            printf " ${cyan}${i}${normal}" >&2
         done

         printf '\n' >&2
      fi

      if [[ -n "${parameter_errors_array[@]}" ]] ; then
         printf '\n' >&2

         for i in "${parameter_errors_array[@]}" ; do
            __error "${i}\n" >&2
         done
      fi

      exit 1
   fi

   # Run through all the converted arguments and set up the correct
   # values based on what the user called, thereby allowing the
   # script to process said values and execute the corresponding
   # functions
   for i in "${converted_arguments_array[@]}" ; do
      case "${i}" in
         '-l') all="true"                            ;;
         '-L') reallyall="true"                      ;;
         '-a') operations[0]='aucdtect'              ;;
         '-A')
            #operations[1]='aucdtect_spectrogram'
            operations[1]='aucdtect'
            create_spectrogram='true'
         ;;
         '-m') operations[2]='md5_check'             ;;
         '-c') operations[3]='compress_verify'       ;;
         '-C') operations[4]='compress_no_test'      ;;
         '-t') operations[5]='test'                  ;;
         '-g'|'-G')
            operations[6]='replaygain_test'
            if [[ "${i}" == '-g' ]] ; then
               operations[7]='replaygain_force_apply'
            else  # '-G'
               operations[7]='replaygain_apply'
            fi
         ;;
         '-r')
            operations[8]='retag_analyze'
            operations[9]='retag_apply'
         ;;
         '-e')
            operations[10]='extract_images'
            check_artwork_dir="true"
         ;;
         '-p') operations[11]='prune'                ;;
         '-n') no_color="true"                       ;;
         '-j')
            # Do nothing, ${jobs} has already been stored
            # in previous getopts loop
            :
         ;;
         '-v') __usage ; exit 1 ;;
         '-h') __usage ; exit 1 ;;
         '-o') __usage ; exit 1 ;;
      esac
   done

   # Put all the called arguments into an array
   called_arguments_array=( "${@}" )

   # Set the last argument as the directory and remove the
   # ending slash (if any) to prevent double slashes from
   # appearing
   #
   # This may appear if the directory chosen is the direct
   # parent directory to the FLAC files to be processed.
   #
   # BASH 4.2 allows negative indices (ie):
   #   directory="${called_arguments_array[-1]%/}"
   directory="${called_arguments_array[$(( ${#called_arguments_array[@]} - 1 ))]%/}"
}

#-------------------------------------------------------------------------------

# Check for missing programs vital to this script
__check_missing_programs() {
   # Check if each command can be found in $PATH
   rm_exists="$(type -P rm)"
   stty_exists="$(type -P stty)"
   stat_exists="$(type -P stat)"
   mkdir_exists="$(type -P mkdir)"
   mkfifo_exists="$(type -P mkfifo)"
   wc_exists="$(type -P wc)"
   metaflac_exists="$(type -P metaflac)"
   flac_exists="$(type -P flac)"

   # Go through and test if each command was found (by displaying its $PATH).  If
   # it's empty, add where you can find the package to an array to be displayed.
   if [[ -z "${rm_exists}" ]] ; then
      command_exists_array+=( "   Missing ${cyan}rm${normal}        ->  Part of ${cyan}coreutils${normal}" )
   fi

   if [[ -z "${stty_exists}" ]] ; then
      command_exists_array+=( "   Missing ${cyan}stty${normal}      ->  Part of ${cyan}coreutils${normal}" )
   fi

   if [[ -z "${stat_exists}" ]] ; then
      command_exists_array+=( "   Missing ${cyan}stat${normal}      ->  Part of ${cyan}coreutils${normal}" )
   fi

   if [[ -z "${mkdir_exists}" ]] ; then
      command_exists_array+=( "   Missing ${cyan}mkdir${normal}     ->  Part of ${cyan}coreutils${normal}" )
   fi

   if [[ -z "${mkfifo_exists}" ]] ; then
      command_exists_array+=( "   Missing ${cyan}mkfifo${normal}    ->  Part of ${cyan}coreutils${normal}" )
   fi

   if [[ -z "${wc_exists}" ]] ; then
      command_exists_array+=( "   Missing ${cyan}wc${normal}        ->  Part of ${cyan}coreutils${normal}" )
   fi

   if [[ -z "${metaflac_exists}" ]] ; then
      command_exists_array+=( "   Missing ${cyan}metaflac${normal}  ->  Part of ${cyan}flac${normal}" )
   fi

   if [[ -z "${flac_exists}" ]] ; then
      command_exists_array+=( "   Missing ${cyan}flac${normal}      ->  Part of ${cyan}flac${normal}" )
   fi

   # If all the programs above were found, continue with script.  Else
   # display warning and exit script, printing out which package has
   # the missing programs
   if [[ -n "${command_exists_array[@]}" ]] ; then
      __display_missing_commands_header

      # Iterate through array and print each value
      for i in "${command_exists_array[@]}" ; do
         __warn "${i}\n" >&2
      done

      exit 1
   fi

   # FIXME
   # If auCDtect operation was specified, check
   # if auCDtect is found/installed
   if [[ "${aucdtect_flac}" == "true" ]] ; then
      aucdtect_exists="$(type -P auCDtect)"

      if [[ -z "${aucdtect_exists}" ]] ; then
         # Check alternate spelling
         aucdtect_exists="$(type -P aucdtect)"
      fi

      if [[ -z "${aucdtect_exists}" ]] ; then
         # auCDtect can't be found, exit
         __error "It appears ${cyan}auCDtect${normal} is not installed. Please verify you\n" >&2
         __error "have this program installed and can be found in ${cyan}\$PATH${normal}\n" >&2

         exit 1
      else
         # Check if auCDtect is executable and warn user if it isn't
         if [[ ! -x "${aucdtect_exists}" ]] ; then
            __error "It appears ${cyan}auCDtect${normal} is not executable.  In order to make\n" >&2
            __error "${cyan}auCDtect${normal} executable, run:\n" >&2
            __error "${cyan}chmod +x \"${aucdtect_exists}\"${normal}\n" >&2

            exit 1
         fi

         # Set up auCDtect command
         aucdtect_command="${aucdtect_exists}"
      fi
   fi

   # If "-A, --aucdtect-spectrogram" was called
   # make sure SoX is installed before starting
   if [[ "${create_spectrogram}" == "true" ]] ; then
      # Check if SoX is found/installed
      sox_exists="$(type -P sox)"

      if [[ -z "${sox_exists}" ]] ; then
         # SoX can't be found, exit
         __error "It appears ${cyan}SoX${normal} is not installed. Please verify you\n" >&2
         __error "have this program installed and can be found in ${cyan}\$PATH${normal}\n" >&2

         exit 1
      else
         # Set up SoX command
         sox_command="${sox_exists}"
      fi
   fi
}

#-------------------------------------------------------------------------------

# Check for any conflicting operations/arguments
__check_conflicting_operations() {
   # If "-l, --all" and "-L, --reallyall" are both called, warn and exit
   if [[ "${all}" == "true" && "${reallyall}" == "true" ]] ; then
      __error "Running both ${cyan}-l, --all${normal} and ${cyan}-L, --reallyall${normal} conflict!\n" >&2
      __error "Please choose one or the other.\n" >&2

      exit 1
   fi

   # If "-l, --all" or "-L, --reallyall" was called, check if arguments
   # were called that already will be performed by the above argument(s).
   # If any were called, display a warning and exit the script
   if [[ "${all}" == "true" || "${reallyall}" == "true" ]] ; then

      # Check for "-c, --compress".  If used add it to array
      if [[ "${compress_flac}" == "true" && "${skip_test}" == "false" ]] ; then
         argument_conflict_array+=( "-c, --compress" )
      # Check for "-C, --compress-notest".  If used add it to array
      elif [[ "${compress_flac}" == "true" && "${skip_test}" == "true" ]] ; then
         argument_conflict_array+=( "-C, --compress-notest" )
      fi

      # Check for "-t, --test".  If used add it to array
      if [[ "${test_flac}" == "true" ]] ; then
         argument_conflict_array+=( "-t, --test" )
      fi

      # Check for "-m, --md5check".  If used add it to array
      if [[ "${md5_check_flac}" == "true" ]] ; then
         argument_conflict_array+=( "-m, --md5check" )
      fi

      # Check for "-p, --prune".  If used add it to array
      if [[ "${prune_flac}" == "true" ]] ; then
         argument_conflict_array+=( "-p, --prune" )
      fi

      # Check for "-g, --replaygain".  If used add it to array
      if [[ "${replaygain_flac}" == "true" && "${replaygain_noforce}" != "true" ]] ; then
         argument_conflict_array+=( "-g, --replaygain" )
      # Check for "-G, --replaygain-noforce".  If used add it to array
      elif [[ "${replaygain_flac}" == "true" && "${replaygain_noforce}" == "true" ]] ; then
         argument_conflict_array+=( "-G, --replaygain-noforce" )
      fi

      # Check for "-r, --retag".  If used add it to array
      if [[ "${retag_flac}" == "true" ]] ; then
         argument_conflict_array+=( "-r, --retag" )
      fi

      # If "-L, --reallyall" was called, check for the various forms of calling
      # auCDtect.  If it was called, add it to array
      if [[ "${reallyall}" == "true" ]] ; then
         if [[ "${aucdtect_flac}" == "true" && "${create_spectrogram}" == "true" ]] ; then
            argument_conflict_array+=( "-A, --aucdtect-spectrogram" )
         elif [[ "${aucdtect_flac}" == "true" && "${create_spectrogram}" != "true" ]] ; then
            argument_conflict_array+=( "-a, --aucdtect" )
         fi
      fi

      # If the array is not empty, the user called some incompatible options with
      # "-l, --all" or "-L, --reallyall", so print which options were called that
      # are incompatible and exit script
      if [[ -n "${argument_conflict_array[@]}" ]] ; then
         # "-l, --all"
         if [[ "${all}" == "true" ]] ; then
            __error "The below options conflict with ${cyan}-l, --all${normal}:\n" >&2
         # "-L, --reallyall"
         elif [[ "${reallyall}" == "true" ]] ; then
            __error "The below options conflict with ${cyan}-L, --reallyall${normal}:\n" >&2
         fi

         # Iterate through array and print each value
         for i in "${argument_conflict_array[@]}" ; do
            __error "     ${cyan}${i}${normal}\n" >&2
         done

         __error "Please remove incompatible options.\n" >&2

         exit 1
      fi
   fi

   # If "-C, --compress-notest" and "-c, --compress" are both called, warn and exit
   if [[ "${skip_test}" == "true" && "${compress_test}" == "true" ]] ; then
      __error "Running both ${cyan}-c, --compress${normal} and ${cyan}-C, --compress-notest${normal} conflict!\n" >&2
      __error "Please choose one or the other.\n" >&2
      exit 1
   fi

   # If "-c, --compress" and "-t, --test" are both called, warn and exit
   if [[ "${compress_test}" == "true" && "${test_flac}" == "true" ]] ; then
      __error "Running both ${cyan}-c, --compress${normal} and ${cyan}-t, --test${normal} conflict!\n" >&2
      __error "Please choose one or the other.\n" >&2
      exit 1
   fi

   # If "-g, --replaygain" and "-G, --replaygain-noforce" are both called, warn and exit
   if [[ "${replaygain_force}" == "true" && "${replaygain_noforce}" == "true" ]] ; then
      __error "Running both ${cyan}-g, --replaygain${normal} and ${cyan}-G, --replaygain-noforce${normal} conflict!\n" >&2
      __error "Please choose one or the other.\n" >&2
      exit 1
   fi

   # If "-a, --aucdtect" and "-A, --aucdtect-spectrogram" are both called, warn and exit
   if [[ "${no_spectrogram}" == "true"  && "${create_spectrogram}" == "true" ]] ; then
      __error "Running both ${cyan}-a, --aucdtect${normal} and ${cyan}-A, --aucdtect-spectrogram${normal} conflict!\n" >&2
      __error "Please choose one or the other.\n" >&2
      exit 1
   fi

   # If "-l, --all" or "-L, --reallyall" was called,
   # enable the various arguments to allow script to
   # run them
   if [[ "${all}" == "true" ]] ; then
      compress_flac="true"
      md5_check_flac="true"
      prune_flac="true"
      replaygain_flac="true"
      retag_flac="true"
   elif [[ "${reallyall}" == "true" ]] ; then
      compress_flac="true"
      md5_check_flac="true"
      prune_flac="true"
      replaygain_flac="true"
      retag_flac="true"
      aucdtect_flac="true"
      # This is needed to let script know that we want auCDtect
      # to create a spectrogram (ie "-A, --aucdtect-spectrogram")
      create_spectrogram="true"
   fi
}

#-------------------------------------------------------------------------------

__summary() {
   # Display the summary of operations chart
   #--
   # Set up local variables/arrays
   declare     operation  sub_message
   declare -a  operation_keys

   # Title
   printf "\033[$(__row);2H${blue}%s${normal}\n" \
   "---------------------------------------------------"
   printf "                Summary Of Operations\n"
   printf "${normal} ${blue}%s${normal}\n" \
   "-------------------------+-------------------------"

   # Correct order to display operational status to process
   operation_keys=(
      'Validate with auCDtect'
      'Check MD5 Signature'
      'Compress FLACs'
      'Test FLACs'
      '>> Testing'
      '>> Applying'
      '>> Analyzing'
      '>> Re-Tagging'
      'Extracting Artwork'
      'Prune METADATA Blocks'
   )

   for operation in "${operation_keys[@]}" ; do
      # Display each operational line with the status of that operation, if it
      # was called
      #--
      if [[ -n "${operation_summary[$operation]}" ]] ; then
         # Check for sub messages, and apply additional formatting
         if [[ "${operation}" == '>> '* ]] ; then
            if [[ "${operation}" == '>> Testing' ]] ; then
               printf "${yellow}%25s ${blue}|${normal}\n" 'Applying ReplayGain'
            elif [[ "${operation}" == '>> Analyzing' ]] ; then
               printf "${yellow}%25s ${blue}|${normal}\n" 'Retagging FLACs'
            fi

            printf -v sub_message "%25s" "${operation}"  # Store right aligned message

            # Color '>>' as yellow and message as magenta
            printf "${yellow}%s${magenta}%s ${blue}|${normal}" \
               "${sub_message%%>> *}>>" "${sub_message##*>>}"
         else
            printf "${yellow}%25s ${blue}|${normal}" "${operation}"
         fi

         # Colorize the operational status
         case "${operation_summary[$operation]}" in
            'Operation Completed')
               printf " ${green}%s${normal}\n" "${operation_summary[$operation]}"
            ;;
            'Operation Interrupted')
               printf " ${cyan}%s${normal}\n" "${operation_summary[$operation]}"
            ;;
            'Operation Did Not Run')
               printf " ${magenta}%s${normal}\n" "${operation_summary[$operation]}"
            ;;
            *'Issue'*)
               printf " ${red}%s${normal}\n" "${operation_summary[$operation]}"
            ;;
         esac
      fi
   done

   # Last line of chart
   printf " ${blue}%s${normal}\n" \
      "-------------------------+-------------------------"

   # Remove temporary FIFOs and files
   rm -f "${tmp_fifo}" "${tmp_aucdtect_fd}" "${issue_ticks}"

   printf "\033[?25h"   # Restore cursor
}

#-------------------------------------------------------------------------------

__run_parallel() {
   # Run a given operation with a specified number of jobs
   #
   # $1 is the operational function to run multiple jobs, which can be:
   #   aucdtect          aucdtect_spectrogram     md5_check
   #   compress_verify   compress_no_test         test
   #   replaygain_test   replaygain_force_apply   replaygain_apply
   #   retag_analyze     retag_apply              extract_artwork
   #   prune
   #--
   # Set up local variables/arrays
   declare      item
   declare  -i  row_state  placement  previous_placement  iteration=0

   case "$1" in
      replaygain_* | retag_*)  spacing='11'  ;;
      *)                       spacing='9'   ;;
   esac

   # This is the current item processed out of the total items:
   #number_completed="[${iteration}/${#total_items[@]}]"  # eg. [56/213]

   # This is the maximum length of a string to be displayed based on column width,
   # obtained via the number of columns minus the length of displayed characters:
   #
   #             ${columns}:  Width of terminal
   #   ${#number_completed}:  FLACs processed and total FLACs, ie: [56/213]
   #                     11:  Length of:
   #                            (4) Spaces
   #                            (1) Gap and ellipsis: ''
   #                            (6) Percentage: '  100%' or '    3%'
   #max_length="$(( columns - ${#number_completed} - 9 ))"

   row_state=$(__row)                       # Current cursor row position state

   for item in "${total_items[@]:0:${jobs}}" ; do
      # Run as many operations (from $total_items[@]) in the background,
      # specified via $jobs
      #--
      placement=$((row_state + iteration))  # Placement of file/dir processed
      ((iteration++))                       # After placement to not print 0
      number_completed="[${iteration}/${#total_items[@]}]"  # eg. [56/213]

      # Max filename allowed (to fit within screen)
      max_length="$(( columns - ${#number_completed} - spacing ))"
      __$1 "${item}" "$1" "${number_completed}" &           # Fork operation
   done

   # Continue only if there are more items than jobs specified
   if (( ${#total_items[@]} > jobs )) ; then
      while read -r previous_placement ; do
         # An operation is completed with an integer and newline sent to a FIFO.
         # The integer is that row position an operation was on.  For each
         # newline read in, process another file/dir from $total_items[@]
         #--
         # Placement of file/dir relative to previous operation's placement
         placement=$((row_state + previous_placement))

         # If current number of FLACs to process is less than total FLACs
         # found, add another FLAC to process
         if (( iteration < ${#total_items[@]} )) ; then
            item="${total_items[${iteration}]}"  # Current file/dir to process
            ((iteration++))                      # Increase count
            number_completed="[${iteration}/${#total_items[@]}]"  # eg. [56/213]

            # Max filename allowed (to fit within screen)
            max_length="$(( columns - ${#number_completed} - spacing ))"
            __$1 "${item}" "$1" "${number_completed}" &           # Fork operation
         else
            break                                # Prevent read hanging FIFO
         fi
      done <&3                                   # Read from FIFO
   fi

   wait  # Wait for children processes
}

#-------------------------------------------------------------------------------

__replaygain_test() {
   # Test FLAC file's for ReplayGain application
   #--
   # $1 is the filename
   # $2 is the operation that's currently being run, of which, can be:
   #   aucdtect          aucdtect_spectrogram     md5_check
   #   compress_verify   compress_no_test         test
   #   replaygain_test   replaygain_force_apply   replaygain_apply
   #   retag_analyze     retag_apply              extract_artwork
   #   prune
   # $3 is a string representing number items processed, eg: [43/439]
   #--
   trap '__kill_jobs "$(jobs -rp)"' EXIT

   # Set up local variables
   declare    file_basename
   declare -i file_length

   # Truncate file, if necessary, and grab file information, splitting on
   # Unit Separator (\037)
   IFS=$'\037' read -r file_basename file_length < <(__truncate_filename "$1")

   # Print current FLAC being processed
   __print_item "${file_basename}" "${file_length}" "$3" 'sub'

   # Check if file is a FLAC file (capture output) via obtaining the sample
   # rate of the current file.  The sample rate captured will be tested against
   # later on.  Hide STDERR as we'll test the exit code instead
   current_sample_rate="$(metaflac --show-sample-rate "${1}" 2>/dev/null)"

   # Exit code 1 implies failure (130 is SIGINT)
   if (( ${?} == 1 )) ; then
      # Error with FLAC file, display failed/error
      __print_status 'fail' "${file_basename}" "${file_length}" 'sub'

      # Log FLAC failure
      printf "%s__redoflacs::delimiter__Not a real FLAC file\n" "${1}" \
         >> "${log_file}"

      # Add one to fail fd
      printf '.' >> "${issue_ticks}"
   else
      # File is OK, test if sample rate is above 48kHz and the version of
      # `metaflac' installed is greater than 1.2.1
      if (( current_sample_rate > 48000 )) ; then

         # Sample rate is greater than 48kHz, so check to make sure the
         # version of `metaflac' is greater than 1.2.1
         if (( $(__metaflac_version) < 3 )) ; then
            # Old version of `metaflac' installed, display skipped
            __print_status 'skip' "${file_basename}" "${file_length}" 'sub'

            # The `metaflac' version installed is NOT greater than 1.2.1 so
            # skip processing current FLAC file, logging why it was skipped
            printf "%s__redoflacs::delimiter__FLAC 1.3.0 or higher needed for sample rates >48kHz\n" "${1}" \
               >> "${log_file}"

            # Add one to fail fd
            printf '.' >> "${issue_ticks}"
         else
            # FLAC is ok, display ok
            __print_status 'ok' "${file_basename}" "${file_length}" 'sub'

         fi
      else
         # FLAC is ok, display ok
         __print_status 'ok' "${file_basename}" "${file_length}" 'sub'
      fi
   fi

   # Store the position of where the line of the FLAC file is displayed in file
   # descriptor (3), to be used by the next job, terminated by a newline to
   # indicate job completed
   __store_position
}

#-------------------------------------------------------------------------------

__replaygain_apply() {
   # Apply ReplayGain to each directory of FLAC files (if values are missing)
   #--
   # $1 is the directory
   # $2 is the operation that's currently being run, of which, can be:
   #   aucdtect          aucdtect_spectrogram     md5_check
   #   compress_verify   compress_no_test         test
   #   replaygain_test   replaygain_force_apply   replaygain_apply
   #   retag_analyze     retag_apply              extract_artwork
   #   prune
   # $3 is a string representing number items processed, eg: [43/439]
   #--
   trap '__kill_jobs "$(jobs -rp)"' EXIT

   # Set up local variables
   declare file_basename percent_complete
   declare -i file_length
   declare -a replaygain_tags

   # Truncate file, if necessary, and grab file information, splitting on
   # Unit Separator (\037)
   IFS=$'\037' read -r file_basename file_length < <(__truncate_filename "$1")

   # Print current FLAC being processed
   __print_item "${file_basename}" "${file_length}" "$3" 'sub'

   # ${j} is a FLAC file -> under a directory, ${1}
   for j in "${1}"/*${flac_extension} ; do
      # Grab all of the ReplayGain tags
      mapfile -n0 -t replaygain_tags < \
      <(
         metaflac \
            --show-tag=REPLAYGAIN_REFERENCE_LOUDNESS \
            --show-tag=REPLAYGAIN_TRACK_GAIN \
            --show-tag=REPLAYGAIN_TRACK_PEAK \
            --show-tag=REPLAYGAIN_ALBUM_GAIN \
            --show-tag=REPLAYGAIN_ALBUM_PEAK \
            "${j}"
      )

      # Test if any ReplayGain values are empty (if there are less
      # than 5 values in the replaygain array)
      if (( ${#replaygain_tags[@]} < 5 )) ; then
         # At _least_ one tag is missing from current file, so
         # apply new ReplayGain values
         #
         # Add ReplayGain to FLAC files under directory.  Metaflac
         # automatically removes old ReplayGain values (if any) before
         # proceeding
         metaflac --add-replay-gain "${1}"/*${flac_extension} >/dev/null 2>&1

         # Exit code 130 is SIGINT so only check for exit code '1'
         if (( ${?} == 1 )) ; then
            # Failed applying ReplayGain values, display failed/error
            __print_status 'fail' "${file_basename}" "${file_length}" 'sub'

            # Log ReplayGain error
            printf "%s__redoflacs::delimiter__Corrupt FLAC(s) or differing sample rates (album ReplayGain)\n" "${1}" \
               >> "${log_file}"

            # Add one to fail fd
            printf '.' >> "${issue_ticks}"

            # Placeholder variable tested after this loop if the loop completes
            # with 'break'
            broke_out_of_loop="true"

            # Break out of loop and on to next directory
            break
         else
            # Applied ReplayGain successfully
            __print_status 'ok' "${file_basename}" "${file_length}" 'sub'
         fi
      else
         # All FLACs have ReplayGain applied
         __print_status 'ok' "${file_basename}" "${file_length}" 'sub'
      fi
   done

   # Store the position of where the line of the FLAC file is displayed in file
   # descriptor (3), to be used by the next job, terminated by a newline to
   # indicate job completed
   __store_position
}

#-------------------------------------------------------------------------------

__replaygain_force_apply() {
   # Apply ReplayGain to each directory of FLAC files (force new values)
   #--
   # $1 is the directory
   # $2 is the operation that's currently being run, of which, can be:
   #   aucdtect          aucdtect_spectrogram     md5_check
   #   compress_verify   compress_no_test         test
   #   replaygain_test   replaygain_force_apply   replaygain_apply
   #   retag_analyze     retag_apply              extract_artwork
   #   prune
   # $3 is a string representing number items processed, eg: [43/439]
   #--
   trap '__kill_jobs "$(jobs -rp)"' EXIT

   # Set up local variables
   declare    file_basename  percent_complete
   declare -i file_length

   # Truncate file, if necessary, and grab file information, splitting on
   # Unit Separator (\037)
   IFS=$'\037' read -r file_basename file_length < <(__truncate_filename "$1")

   # Print current FLAC being processed
   __print_item "${file_basename}" "${file_length}" "$3" 'sub'

   # Add ReplayGain to FLAC files under directory
   metaflac --add-replay-gain "${1}"/*${flac_extension} >/dev/null 2>&1

   # Exit code 130 is SIGINT so only check for exit code '1'
   if (( ${?} == 1 )) ; then
      # Failed applying ReplayGain values, display failed/error
      __print_status 'fail' "${file_basename}" "${file_length}" 'sub'

      # Log ReplayGain error
      printf "%s__redoflacs::delimiter__Corrupt FLAC(s) or differing sample rates (album ReplayGain)\n" "${1}" \
         >> "${log_file}"

      # Add one to fail fd
      printf '.' >> "${issue_ticks}"
   else
      # Applied ReplayGain successfully
      __print_status 'ok' "${file_basename}" "${file_length}" 'sub'
   fi

   # Store the position of where the line of the FLAC file is displayed in file
   # descriptor (3), to be used by the next job, terminated by a newline to
   # indicate job completed
   __store_position
}

#-------------------------------------------------------------------------------

__compress_verify() {
   # Compress FLACs with user-defined compression level, verifying its integrity
   #--
   # $1 is the directory
   # $2 is the operation that's currently being run, of which, can be:
   #   aucdtect          aucdtect_spectrogram     md5_check
   #   compress_verify   compress_no_test         test
   #   replaygain_test   replaygain_force_apply   replaygain_apply
   #   retag_analyze     retag_apply              extract_artwork
   #   prune
   # $3 is a string representing number items processed, eg: [43/439]
   #--
   trap '__kill_jobs "$(jobs -rp)"' EXIT

   # Set up local variables
   declare    file_basename percent_complete
   declare -i file_length

   # Truncate file, if necessary, and grab file information, splitting on
   # Unit Separator (\037)
   IFS=$'\037' read -r file_basename file_length < <(__truncate_filename "$1")

   # Print current FLAC being processed
   __print_item "${file_basename}" "${file_length}" "$3"

   # Test for COMPRESSION level in FLAC file. Hide error output since
   # we'll be verifying the FLAC file later
   COMPRESSION="$(metaflac --show-tag=COMPRESSION "${1}" 2> /dev/null)"
   COMPRESSION="${COMPRESSION#*=}"

   if (( COMPRESSION != compression_level )) ; then
      flac --no-error-on-compression-fail -f -${compression_level} -V "${1}" 2> >(while read -r -d'%' percent_complete ; do
         # Compress given FLAC file, verifying with a progress bar
         #--
         # Current percent complete
         percent_complete="$( __get_percent_complete "$2" "${percent_complete}" )"

         # Print operation progress bar and percent complete
         __print_progress "$2" "${percent_complete}" "${file_basename}" "${file_length}"
      done) >/dev/null

      # Exit code 1 implies failure (130 is SIGINT)
      if (( ${?} == 1 )) ; then
         # Error with FLAC file, display failed/error
         __print_status 'fail' "${file_basename}" "${file_length}"

         # Log FLAC failure
         printf "%s__redoflacs::delimiter__Failed verification\n" "${1}" \
            >> "${log_file}"

         # Add one to fail fd
         printf '.' >> "${issue_ticks}"
      else
         metaflac \
            --remove-tag=COMPRESSION \
            --set-tag=COMPRESSION=${compression_level} "${1}"

         # FLAC is ok, display ok
         __print_status 'ok' "${file_basename}" "${file_length}"
      fi
   else
      # If already at compression_level, test the FLAC file instead
      flac -t "${1}" 2> >(while read -r -d'%' percent_complete ; do
         # Test given FLAC file, with a progress bar
         #--
         # Current percent complete
         percent_complete="$( __get_percent_complete 'test' "${percent_complete}" )"

         # Print operation progress bar and percent complete
         __print_progress 'test' "${percent_complete}" "${file_basename}" "${file_length}"
      done) >/dev/null

      # Exit code 1 implies failure (130 is SIGINT)
      if (( ${?} == 1 )) ; then
         # Error with FLAC file, display failed/error
         __print_status 'fail' "${file_basename}" "${file_length}"

         # Log FLAC failure
         printf "%s__redoflacs::delimiter__Failed verification\n" "${i}" \
            >> "${log_file}"

         # Add one to fail fd
         printf '.' >> "${issue_ticks}"
      else
         # FLAC is ok, display ok
         __print_status 'ok' "${file_basename}" "${file_length}"
      fi
   fi

   # Store the position of where the line of the FLAC file is displayed in file
   # descriptor (3), to be used by the next job, terminated by a newline to
   # indicate job completed
   __store_position
}

#-------------------------------------------------------------------------------

__compress_no_test() {
   # Compress FLACs with user-defined compression level, verifying its integrity
   # and _not_ falling back to __test() if the compression level is already set
   #--
   # $1 is the directory
   # $2 is the operation that's currently being run, of which, can be:
   #   aucdtect          aucdtect_spectrogram     md5_check
   #   compress_verify   compress_no_test         test
   #   replaygain_test   replaygain_force_apply   replaygain_apply
   #   retag_analyze     retag_apply              extract_artwork
   #   prune
   # $3 is a string representing number items processed, eg: [43/439]
   #--
   trap '__kill_jobs "$(jobs -rp)"' EXIT

   # Set up local variables
   declare    file_basename percent_complete
   declare -i file_length

   # Truncate file, if necessary, and grab file information, splitting on
   # Unit Separator (\037)
   IFS=$'\037' read -r file_basename file_length < <(__truncate_filename "$1")

   # Print current FLAC being processed
   __print_item "${file_basename}" "${file_length}" "$3"

   # Test for COMPRESSION level in FLAC file. Hide error output since
   # we'll be verifying the FLAC file later
   COMPRESSION="$(metaflac --show-tag=COMPRESSION "${1}" 2> /dev/null)"
   COMPRESSION="${COMPRESSION#*=}"

   if (( COMPRESSION != compression_level )) ; then
      flac --no-error-on-compression-fail -f -${compression_level} -V "${1}" 2> >(while read -r -d'%' percent_complete ; do
         # Compress given FLAC file, verifying with a progress bar
         #--
         # Current percent complete
         percent_complete="$( __get_percent_complete "$2" "${percent_complete}" )"

         # Print operation progress bar and percent complete
         __print_progress "$2" "${percent_complete}" "${file_basename}" "${file_length}"
      done) >/dev/null

      # Exit code 1 implies failure (130 is SIGINT)
      if (( ${?} == 1 )) ; then
         # Error with FLAC file, display failed/error
         __print_status 'fail' "${file_basename}" "${file_length}"

         # Log FLAC failure
         printf "%s__redoflacs::delimiter__Failed verification\n" "${1}" \
            >> "${log_file}"

         # Add one to fail fd
         printf '.' >> "${issue_ticks}"
      else
         metaflac \
            --remove-tag=COMPRESSION \
            --set-tag=COMPRESSION=${compression_level} "${1}"

         # FLAC is ok, display ok
         __print_status 'ok' "${file_basename}" "${file_length}"
      fi
   else
      # Already at compression_level, print skipped FLAC file
      __print_status 'skip' "${file_basename}" "${file_length}"
   fi

   # Store the position of where the line of the FLAC file is displayed in file
   # descriptor (3), to be used by the next job, terminated by a newline to
   # indicate job completed
   __store_position
}

#-------------------------------------------------------------------------------

__test() {
   # Test FLAC file integrity
   #--
   # $1 is the filename
   # $2 is the operation that's currently being run, of which, can be:
   #   aucdtect          aucdtect_spectrogram     md5_check
   #   compress_verify   compress_no_test         test
   #   replaygain_test   replaygain_force_apply   replaygain_apply
   #   retag_analyze     retag_apply              extract_artwork
   #   prune
   # $3 is a string representing number items processed, eg: [43/439]
   #--
   trap '__kill_jobs "$(jobs -rp)"' EXIT

   # Set up local variables
   declare    file_basename percent_complete
   declare -i file_length

   # Truncate file, if necessary, and grab file information, splitting on
   # Unit Separator (\037)
   IFS=$'\037' read -r file_basename file_length < <(__truncate_filename "$1")

   # Print current FLAC being processed
   __print_item "${file_basename}" "${file_length}" "$3"

   flac -t "${1}" 2> >(while read -r -d'%' percent_complete ; do
      # Test given FLAC file, with a progress bar
      #--
      # Current percent complete
      percent_complete="$( __get_percent_complete "$2" "${percent_complete}" )"

      # Print operation progress bar and percent complete
      __print_progress "$2" "${percent_complete}" "${file_basename}" "${file_length}"
   done) >/dev/null

   # Exit code 1 implies failure (130 is SIGINT)
   if (( ${?} == 1 )) ; then
      # Error with FLAC file, display failed/error
      __print_status 'fail' "${file_basename}" "${file_length}"

      # Log FLAC failure
      printf "%s__redoflacs::delimiter__Failed testing\n" "${i}" >> "${log_file}"

      # Add one to fail fd
      printf '.' >> "${issue_ticks}"
   else
      # FLAC is ok, display ok
      __print_status 'ok' "${file_basename}" "${file_length}"
   fi

   # Store the position of where the line of the FLAC file is displayed in file
   # descriptor (3), to be used by the next job, terminated by a newline to
   # indicate job completed
   __store_position
}

#-------------------------------------------------------------------------------

__aucdtect() {
   # Test FLAC validity with auCDtect
   #--
   # $1 is the filename
   # $2 is the operation that's currently being run, of which, can be:
   #   aucdtect          aucdtect_spectrogram     md5_check
   #   compress_verify   compress_no_test         test
   #   replaygain_test   replaygain_force_apply   replaygain_apply
   #   retag_analyze     retag_apply              extract_artwork
   #   prune
   # $3 is a string representing number items processed, eg: [43/439]
   #--
   trap '__kill_jobs "$(jobs -rp)"' EXIT

   # Set up local arrays/variables
   declare    file_basename percent_complete
   declare -i file_length
   declare -a bits_mastering

   # Truncate file, if necessary, and grab file information, splitting on
   # Unit Separator (\037)
   IFS=$'\037' read -r file_basename file_length < <(__truncate_filename "$1")

   # Print current FLAC being processed
   __print_item "${file_basename}" "${file_length}" "$3"

   # Get the bit depth and MASTERING tag of a FLAC file.  Also used to check if
   # FLAC file is real.  Hide STDERR output.  The array indices are:
   #   bits_mastering[0] = bit depth (eg, 16)
   #   bits_mastering[1] = MASTERING tag & value (eg, MASTERING=Lossy)
   bits_mastering=( $(metaflac --show-bps --show-tag=MASTERING "$1" 2>/dev/null) )

   # Exit code 1 implies failure (130 is SIGINT)
   if (( ${?} == 1 )) ; then
      # Error with FLAC file, display failed/error
      __print_status 'fail' "${file_basename}" "${file_length}"

      # Log FLAC failure
      printf "%s__redoflacs::delimiter__Not a real FLAC file\n" "$1" \
         >> "${log_file}"

      # Add one to fail fd
      printf '.' >> "${issue_ticks}"

   # Skip the FLAC file if it has a bit depth greater
   # than 16 since auCDtect doesn't support audio
   # files with a higher resolution than a CD.
   elif (( ${bits_mastering[0]} > 16 )) ; then
      # Print skipped FLAC
      __print_status 'skip' "${file_basename}" "${file_length}"

      # Log skipped FLAC file
      printf "%s__redoflacs::delimiter__auCDtect does not support a bit depth >16\n" "$1" \
         >> "${log_file}"

      # Add one to fail fd
      printf '.' >> "${issue_ticks}"

   # Skip the FLAC file if it already has the 'Lossy' value set for the
   # MASTERING tag.  This is only done if the value of 'skip_lossy' is 'true',
   # set in the configuration file.  We make sure to remove 'MASTERING=' before
   # testing the tag field
   elif [[ "${bits_mastering[1]#*=}" == 'Lossy' ]] ; then
      # Print skipped FLAC
      __print_status 'skip' "${file_basename}" "${file_length}"

      # Log skipped FLAC file
      printf "%s__redoflacs::delimiter__MASTERING=Lossy value found; skipping ('skip_lossy' configuration)\n" "${1}" \
         >> "${log_file}"

      # Add one to fail fd
      printf '.' >> "${issue_ticks}"

   # FLAC checks out, continue processing
   else
      # Print current FLAC being processed
      __print_item "${file_basename}" "${file_length}" "$3" 'decode'

      # The WAV file to be created from current FLAC file
      decoded_wav="${1%${flac_extension}}_redoflacs_$$.wav"

      flac -d "${1}" -o "${decoded_wav}" 2> >(while read -r -d'%' percent_complete ; do
         # Decode FLAC to WAV so auCDtect can read the audio file
         #--
         # Current percent complete
         percent_complete="$( __get_percent_complete 'decode' "${percent_complete}" )"

         # Print operation progress bar and percent complete
         __print_progress "$2" "${percent_complete}" "${file_basename}" "${file_length}" 'decode'
      done) >/dev/null

      # Exit code 130 is SIGINT so only check for exit code '1'.  If FLAC file
      # failed decoding to WAV, log error, otherwise continue processing
      if (( ${?} == 1 )) ; then
         # Error with FLAC file, display failed/error
         __print_status 'fail' "${file_basename}" "${file_length}" '' 'decode'

         # Log FLAC failure
         printf "%s__redoflacs::delimiter__Failed decoding to WAV\n" "${1}" \
            >> "${log_file}"

         # Add one to fail fd
         printf '.' >> "${issue_ticks}"
      else
         # Decoded FLAC is ok, display ok
         __print_status 'ok' "${file_basename}" "${file_length}" '' 'decode'

         # Print current FLAC being processed, auCDtect: fast
         __print_item "${file_basename}" "${file_length}" "$3" 'aucdtect_fast'

         # 'export MALLOC_CHECK_' allows the dynamic linked version of
         # `auCDTECT' to run without throwing errors
         export MALLOC_CHECK_="0"

         # The actual auCDtect command with medium accuracy setting (for
         # speed).  STDOUT is sent to file descriptor '4'
         auCDtect -m20 "${decoded_wav}" 2> >(while read -r -d'%' percent_complete ; do
            # Check FLAC validity by checking decoded WAV via auCDtect (fast)
            #--
            # Current percent complete
            percent_complete="$( __get_percent_complete "$2" "${percent_complete}" )"

            # Print operation progress bar and percent complete
            __print_progress "$2" "${percent_complete}" "${file_basename}" "${file_length}" 'aucdtect_fast'
         done) >&4

         # Exit code 130 is SIGINT so only check for exit code '1'
         if (( ${?} == 1 )) ; then
            # Error with FLAC file, display failed/error
            __print_status 'fail' "${file_basename}" "${file_length}" '' 'aucdtect_fast'

            # Log FLAC failure
            printf "%s__redoflacs::delimiter__Failed analyzing decoded FLAC\n" "${1}" \
               >> "${log_file}"

            # Add one to fail fd
            printf '.' >> "${issue_ticks}"
         else
            # Grab the conclusion of auCDtect's command
            # Below options prevents hanging FIFO by only reading
            # what is necessary:
            #    -s7:  Discard first seven lines from auCDtect's output
            #    -n2:  Only grab 2 lines from auCDtect's output
            #     -t:  Remove trailing newlines from auCDtect's output
            #    -u4:  Obtain auCDtect's output from file descriptor '4'
            #  array:  Store captured output into 'aucdtect_check_array'
            mapfile -s7 -n2 -t -u4 aucdtect_check_array

            # If there is an issue with the processed FLAC file, run
            # auCDtect once again with highest setting
            if [[ "${aucdtect_check_array[0]}" != 'This track looks like CDDA with probability 100%' ]] ; then
               # Print current FLAC being processed, auCDtect: slow
               __print_item "${file_basename}" "${file_length}" "$3" 'aucdtect_slow'

               # The actual auCDtect command with highest accuracy setting.
               # STDOUT is sent to file descriptor '4'
               auCDtect -m0 "${decoded_wav}" 2> >(while read -r -d'%' percent_complete ; do
                  # Check FLAC validity by checking decoded WAV via auCDtect (slow)
                  #--
                  # Current percent complete
                  percent_complete="$( __get_percent_complete "$2" "${percent_complete}" )"

                  # Print operation progress bar and percent complete
                  __print_progress "$2" "${percent_complete}" "${file_basename}" "${file_length}" 'aucdtect_slow'
               done) >&4

               # Exit code 130 is SIGINT so only check for exit code '1'
               if (( ${?} == 1 )) ; then
                  # Error with FLAC file, display failed/error
                  __print_status 'fail' "${file_basename}" "${file_length}" '' 'aucdtect_slow'

                  # Log FLAC failure
                  printf "%s__redoflacs::delimiter__Failed analyzing decoded FLAC\n" "${1}" \
                     >> "${log_file}"

                  # Add one to fail fd
                  printf '.' >> "${issue_ticks}"

               else
                  # Grab the conclusion of auCDtect's command
                  # Below options prevents hanging FIFO by only reading
                  # what is necessary:
                  #    -s7:  Discard first seven lines from auCDtect's output
                  #    -n2:  Only grab 2 lines from auCDtect's output
                  #     -t:  Remove trailing newlines from auCDtect's output
                  #    -u4:  Obtain auCDtect's output from file descriptor '4'
                  #  array:  Store captured output into 'aucdtect_check_array'
                  mapfile -s7 -n2 -t -u4 aucdtect_check_array

                  # There is an issue with the processed FLAC file
                  if [[ "${aucdtect_check_array[0]}" != 'This track looks like CDDA with probability 100%' ]] ; then
                     # If user specified '-A, --aucdtect-spectrogram', then
                     # create a spectrogram with SoX and change logging accordingly
                     if [[ "${create_spectrogram}" == 'true' ]] ; then
                        # Check whether to place spectrogram images in user-defined location
                        if [[ -z "${spectrogram_location}" ]] ; then
                           # Obtain basename of current FLAC file
                           flac_file="${1##*/}"

                           # Obtain dirname of current FLAC file
                           spectrogram_dirname="${1%/*}"

                           # Create the spectrogram with '.png' as the
                           # file extension, placed in the same
                           # directory as the current FLAC file
                           spectrogram_picture="${spectrogram_dirname}/[${iteration}] ${flac_file%${flac_extension}}.png"
                        else
                           # Obtain basename of current FLAC file
                           flac_file="${1##*/}"

                           # Create the spectrogram with '.png' as the
                           # file extension, placed in the user-defined
                           # location
                           spectrogram_picture="${spectrogram_location}/[${iteration}] ${flac_file%${flac_extension}}.png"
                        fi

                        # Print current FLAC being processed
                        __print_item "${file_basename}" "${file_length}" "$3" 'spectrogram'

                        # SoX command to create the spectrogram and
                        # place it in spectrogram_picture.  Use the
                        # following arguments to create the highest
                        # resolution spectrograms:
                        #   -x 5000
                        #   -y 1025
                        sox "${decoded_wav}" \
                           -S \
                           -n spectrogram \
                           -c '' \
                           -t "${i}" \
                           -p 1 \
                           -z 90 \
                           -Z 0 \
                           -q 249 \
                           -w Hann \
                           -x 1800 \
                           -y 513 \
                           -o "${spectrogram_picture}" 2> >(
                              while read -r -d'%' percent_complete ; do
                                 # Create spectrogram PNG image of given FLAC
                                 #--
                                 # Current percent complete
                                 percent_complete="$( __get_percent_complete "$2" "${percent_complete}" )"

                                 # Print operation progress bar and percent complete
                                 __print_progress "$2" "${percent_complete}" "${file_basename}" "${file_length}" 'spectrogram'
                              done
                           ) >/dev/null

                        # Error creating spectrogram, display issue
                        __print_status 'issue' "${file_basename}" "${file_length}" '' 'spectrogram'

                        # Log auCDtect report
                        printf "%s__redoflacs::delimiter__%s (%s)\n" "$1" "${aucdtect_check_array[0]}" "${spectrogram_picture}" \
                           >> "${log_file}"

                        # Add one to fail fd
                        printf '.' >> "${issue_ticks}"
                     else
                        # Issue with FLAC authenticity, display issue
                        __print_status 'issue' "${file_basename}" "${file_length}" '' 'aucdtect_slow'

                        # Log auCDtect report
                        printf "%s__redoflacs::delimiter__%s\n" "$1" "${aucdtect_check_array[0]}" \
                           >> "${log_file}"

                        # Add one to fail fd
                        printf '.' >> "${issue_ticks}"
                     fi
                  else
                     # FLAC is ok, display ok
                     __print_status 'ok' "${file_basename}" "${file_length}" '' 'aucdtect_slow'
                  fi
               fi
            else
               # FLAC is ok, display ok
               __print_status 'ok' "${file_basename}" "${file_length}" '' 'aucdtect_fast'
            fi

            # Remove temporary WAV file
            rm "${decoded_wav}"
         fi
      fi
   fi

   # Store the position of where the line of the FLAC file is displayed in file
   # descriptor (3), to be used by the next job, terminated by a newline to
   # indicate job completed
   __store_position
}

#-------------------------------------------------------------------------------

__md5_check() {
   # Check for valid MD5 checksum in FLAC file
   #--
   # $1 is the filename
   # $2 is the operation that's currently being run, of which, can be:
   #   aucdtect          aucdtect_spectrogram     md5_check
   #   compress_verify   compress_no_test         test
   #   replaygain_test   replaygain_force_apply   replaygain_apply
   #   retag_analyze     retag_apply              extract_artwork
   #   prune
   # $3 is a string representing number items processed, eg: [43/439]
   #--
   trap '__kill_jobs "$(jobs -rp)"' EXIT

   # Set up local variables
   declare    file_basename percent_complete md5_sum
   declare -i file_length

   # Truncate file, if necessary, and grab file information, splitting on
   # Unit Separator (\037)
   IFS=$'\037' read -r file_basename file_length < <(__truncate_filename "$1")

   # Print current FLAC being processed
   __print_item "${file_basename}" "${file_length}" "$3"

   # Get the MD5 checksum (hide stderr output).  Also
   # used to check if FLAC file is real
   md5_sum="$(metaflac --show-md5sum "$1" 2>/dev/null)"

   # Exit code 1 implies failure (130 is SIGINT)
   if (( ${?} == 1 )) ; then
      # Error with FLAC file, display failed/error
      __print_status 'fail' "${file_basename}" "${file_length}"

      # Log FLAC failure
      printf "%s__redoflacs::delimiter__Not a real FLAC file\n" "${1}" \
         >> "${log_file}"

      # Add one to fail fd
      printf '.' >> "${issue_ticks}"
   # FLAC file is real, check for unset MD5 checksum.  We cannot use an
   # arithmetic expression as any amount of 0's will equal the expression
   # below
   elif [[ "${md5_sum}" == "00000000000000000000000000000000" ]] ; then
      # Error with FLAC file, display failed/error
      __print_status 'fail' "${file_basename}" "${file_length}"

      # Log FLAC failure
      printf "%s__redoflacs::delimiter__Unset MD5 signature (00000000000000000000000000000000)\n" "${1}" \
         >> "${log_file}"

      # Add one to fail fd
      printf '.' >> "${issue_ticks}"
   else
      # FLAC is ok, display ok
      __print_status 'ok' "${file_basename}" "${file_length}"
   fi

   # Store the position of where the line of the FLAC file is displayed in file
   # descriptor (3), to be used by the next job, terminated by a newline to
   # indicate job completed
   __store_position
}

#-------------------------------------------------------------------------------

__retag_analyze() {
   # Check for missing VORBIS tags from a given FLAC
   #--
   # $1 is the filename
   # $2 is the operation that's currently being run, of which, can be:
   #   aucdtect          aucdtect_spectrogram     md5_check
   #   compress_verify   compress_no_test         test
   #   replaygain_test   replaygain_force_apply   replaygain_apply
   #   retag_analyze     retag_apply              extract_artwork
   #   prune
   # $3 is a string representing number items processed, eg: [43/439]
   #--
   trap '__kill_jobs "$(jobs -rp)"' EXIT

   # Set up local variables
   declare    file_basename
   declare -i file_length

   # Truncate file, if necessary, and grab file information, splitting on
   # Unit Separator (\037)
   IFS=$'\037' read -r file_basename file_length < <(__truncate_filename "$1")

   # Print current FLAC being processed
   __print_item "${file_basename}" "${file_length}" "$3" 'sub'

   # Check if file is a FLAC file (variable hides output)
   check_flac="$(metaflac --show-md5sum "${1}" 2>&1)"

   # Exit code 1 implies failure (130 is SIGINT)
   if (( ${?} == 1 )) ; then
      # Error with FLAC file, display failed/error
      __print_status 'fail' "${file_basename}" "${file_length}" 'sub'

      # Log FLAC failure
      printf "%s__redoflacs::delimiter__Not a real FLAC file\n" "${1}" \
         >> "${log_file}"

      # Add one to fail fd
      printf '.' >> "${issue_ticks}"
   else
      # Iterate through each tag field and check if tag is missing
      for j in "${tags[@]}" ; do
         # Check if ALBUMARTIST is in tag array and apply operations on
         # the tag field if it exists
         if [[ "${j}" == "ALBUMARTIST" ]] ; then
            # ALBUMARTIST exists in tag array so allow script to check the
            # various naming conventions within the FLAC files (ie,
            # 'ALBUM ARTIST' or 'ALBUM_ARTIST')

            # "ALBUMARTIST" or "ALBUM ARTIST" or "ALBUM_ARTIST", case-insensitive
            if [[ -n "$(metaflac --show-tag=ALBUMARTIST "${1}")" ]] ; then
               show_tag_list+=( "--show-tag=ALBUMARTIST" )

            elif [[ -n "$(metaflac --show-tag="ALBUM ARTIST" "${1}")" ]] ; then
               show_tag_list+=( "--show-tag='ALBUM ARTIST'" )

            elif [[ -n "$(metaflac --show-tag="ALBUM_ARTIST" "${1}")" ]] ; then
               show_tag_list+=( "--show-tag=ALBUM_ARTIST" )
            fi
         else
            # Build up metaflac '--show-tag=' list
            show_tag_list+=( "--show-tag=${j}" )
         fi
      done

      # Load up all the tag values for current file
      mapfile -n0 -t metaflac_tag_array < \
      <(
         metaflac \
            "${show_tag_list[@]}" \
            "${1}"
      )

      # Take above tag values and create an associative
      # array using TAG_FIELD=TAG_VALUE as the key/value pair
      #
      # Specifically declare an empty associative array
      declare -A temp_tag_array

      # Run through the tag array from above and store
      # the values into a temporary tag array
      for tag_field_value in "${metaflac_tag_array[@]}" ; do
         # This is the tag field (eg. TITLE)
         tag_field="${tag_field_value%%=*}"

         # Enforce the tag field to be uppercase
         # ${tag_field_value} below is the tag value
         temp_tag_array+=( ["${tag_field^^}"]="${tag_field_value#*=}" )
      done

      # Run through the tags array and test each tag value from
      # ${temp_tag_array} with the currently processed tag in ${tag[@]}.  For
      # each match found, test if the tag value is null, reporting any missing
      # tags. Then remove the tag field (index) from the ${temp_tag_array}, so
      # the next iteration is faster and we can check for missing tags (tag
      # fields)
      for j in "${tags[@]}" ; do

         # If the total # of indices in the temporary tag array is above
         # 0, continue testing, else store missing tag (${j}) into the
         # missing tags array
         if (( ${#temp_tag_array[@]} > 0 )) ; then

            # Compare each tag field from the temporary array to ${j},
            # checking if they are equal and if so, check for missing
            # tag values
            for temp_tag_field in "${!temp_tag_array[@]}" ; do
               # Both tag fields are equal
               if [[ "${j}" == "${temp_tag_field}" ]] ; then
                  # Check if tag value is null, logging missing tags if so
                  if [[ -z "${temp_tag_array[${temp_tag_field}]}" ]] ; then
                     missing_tags+="${j}, "
                  fi

                  # Remove the current tag field from the temporary tag
                  # array since it's been matched already
                  unset -v temp_tag_array[${temp_tag_field}]

                  # This variable let's the script know that the current
                  # tag, ${j} has been matched up with a tag field in
                  # ${temp_tag_array[@]}
                  tag_match="true"

                  # Break out of loop since the tag fields have been
                  # matched, continuing on to the next iteration of ${j}
                  break
               fi
            done

            # If there wasn't a tag field in the temporary tag array
            # ( eg. ${temp_tag_array[@]} ) that matched ${j}, the FLAC file
            # must have a missing tag, so log it by throwing the missing tag
            # into the missing tags array
            if [[ "${tag_match}" != "true" ]] ; then
               missing_tags+="${j}, "
            fi

            # Reset the value of tag match (if any) for the next iteration
            # of ${j}
            unset -v tag_match

         # The total # of indices in the temporary tag array is 0, so
         # whatever is left in ${tags[@]} represented by ${j} is logged
         # as missing
         else
            missing_tags+="${j}, "
         fi
      done

      # If missing_tags_array is not empty, there are missing
      # tags in the current file so log output
      if [[ -n "${missing_tags}" ]] ; then
         # Error with FLAC file, display failed/error
         __print_status 'fail' "${file_basename}" "${file_length}" 'sub'

         # Log the missing tags
         printf "%s__redoflacs::delimiter__Missing tags: ${missing_tags%, }\n" "${1}" \
            >> "${log_file}"

         # Add one to fail fd
         printf '.' >> "${issue_ticks}"
      else
         # There are no missing tags, display ok
         __print_status 'ok' "${file_basename}" "${file_length}" 'sub'
      fi
   fi

   # Store the position of where the line of the FLAC file is displayed in file
   # descriptor (3), to be used by the next job, terminated by a newline to
   # indicate job completed
   __store_position
}

#-------------------------------------------------------------------------------

__retag_apply() {
   # Re-apply the VORBIS tags specified in the config file, removing all others
   #--
   # $1 is the filename
   # $2 is the operation that's currently being run, of which, can be:
   #   aucdtect          aucdtect_spectrogram     md5_check
   #   compress_verify   compress_no_test         test
   #   replaygain_test   replaygain_force_apply   replaygain_apply
   #   retag_analyze     retag_apply              extract_artwork
   #   prune
   # $3 is a string representing number items processed, eg: [43/439]
   #--
   trap '__kill_jobs "$(jobs -rp)"' EXIT

   # Set up local variables
   declare    file_basename
   declare -i file_length

   # Truncate file, if necessary, and grab file information, splitting on
   # Unit Separator (\037)
   IFS=$'\037' read -r file_basename file_length < <(__truncate_filename "$1")

   # Print current FLAC being processed
   __print_item "${file_basename}" "${file_length}" "$3" 'sub'

   # Remove and set new tags
   #
   # Iterate through the tag array and set a variable for each tag
   for j in "${tags[@]}" ; do
      # Check if ALBUMARTIST is in tag array and apply operations on
      # the tag field if it exists
      if [[ "${j}" == "ALBUMARTIST" ]] ; then
         # ALBUMARTIST exists in tag array so allow script to check the
         # various naming conventions within the FLAC files (ie,
         # 'ALBUM ARTIST' or 'ALBUM_ARTIST')

         # "ALBUMARTIST"
         if [[ -n "$(metaflac --show-tag=ALBUMARTIST "${1}")" ]] ; then
            show_tag_list+=( "--show-tag=ALBUMARTIST" )

         elif [[ -n "$(metaflac --show-tag="ALBUM ARTIST" "${1}")" ]] ; then
            show_tag_list+=( "--show-tag='ALBUM ARTIST'" )

         elif [[ -n "$(metaflac --show-tag="ALBUM_ARTIST" "${1}")" ]] ; then
            show_tag_list+=( "--show-tag=ALBUM_ARTIST" )
         fi
      else
         # Build up metaflac '--show-tag=' list
         show_tag_list+=( "--show-tag=${j}" )
      fi
   done

   # Load up all the tag values for current file
   mapfile -n0 -t metaflac_tag_array < \
   <(
      metaflac \
         "${show_tag_list[@]}" \
         "${1}"
   )

   # Create a copy of ${metaflac_tag_array[@]} with just the tag fields
   # and force the tag fields to be uppercase
   tag_field_array=( "${metaflac_tag_array[@]%%=*}" )
   tag_field_array=( "${tag_field_array[@]^^}" )

   # Create a copy of ${metaflac_tag_array[@]} with just the tag values
   tag_values_array=( "${metaflac_tag_array[@]#*=}" )

   # Re-create ${metaflac_tag_array[@]}, this time enforcing the tag
   # fields are uppercase
   #
   # Clear ${metaflac_tag_array[@]}
   metaflac_tag_array=()

   # If the user specified 'true' to the 'prepend_zero' option in the
   # configuration file, enforce the TRACKNUMBER and TRACKTOTAL tags to have a
   # '0' prepended before singular numbers
   if [[ "${prepend_zero}" == "true" ]] ; then
      # Prepend a '0' for TRACKNUMBER and TRACKTOTAL
      for j in "${!tag_field_array[@]}" ; do
         # Add in the tag field and value as an index
         if [[ "${tag_field_array[${j}]}" == "TRACKNUMBER" ||
              "${tag_field_array[${j}]}" == "TRACKTOTAL" ]] ; then
            # Format tag value with '0' prepended for single values.  We
            # force arithmetic expansion and explicitly specify base 10
            # in order to prevent octal errors if the value is either '08'
            # or '09'
            prepend_tag_value="$( printf %02d $(( 10#${tag_values_array[${j}]} )) )"

            metaflac_tag_array+=(
               # Tag field (eg. TRACKNUMBER) = Tag value (eg. 03)
               "${tag_field_array[${j}]}=${prepend_tag_value}"
            )
         else
            metaflac_tag_array+=(
               # Tag field (eg. ARTIST) = Tag value (eg. Kamelot)
               "${tag_field_array[${j}]}=${tag_values_array[${j}]}"
            )
         fi
      done
   else
      # ${prepend_zero} is not set as 'true', add each tag field and tag value
      # into ${metaflac_tag_array[@]}
      for j in "${!tag_field_array[@]}" ; do
         # Add in the tag field and value as an index
         metaflac_tag_array+=(
            # Tag field (eg. ARTIST) = Tag value (eg. Kamelot)
            "${tag_field_array[${j}]}=${tag_values_array[${j}]}"
         )
      done
   fi

   # Add the saved tags back, by printing each tag field and value
   # on a separate line to STDOUT.  This will be read in by metaflac.
   # Use process substitution to allow this to finish if user
   # invokes SIGINT
   metaflac --remove-all-tags --import-tags-from=- "${1}" < \
   <(
      # This prints each tag key and value pair
      # (eg. ARTIST=Kamelot)
      printf "%s\n" "${metaflac_tag_array[@]}"
   )

   # Display ok
   __print_status 'ok' "${file_basename}" "${file_length}" 'sub'

   # Store the position of where the line of the FLAC file is displayed in file
   # descriptor (3), to be used by the next job, terminated by a newline to
   # indicate job completed
   __store_position
}

#-------------------------------------------------------------------------------

__extract_images() {
   # Extact embedded artwork from a given FLAC
   #--
   # $1 is the filename
   # $2 is the operation that's currently being run, of which, can be:
   #   aucdtect          aucdtect_spectrogram     md5_check
   #   compress_verify   compress_no_test         test
   #   replaygain_test   replaygain_force_apply   replaygain_apply
   #   retag_analyze     retag_apply              extract_artwork
   #   prune
   # $3 is a string representing number items processed, eg: [43/439]
   #--
   trap '__kill_jobs "$(jobs -rp)"' EXIT

   # Set up local variables
   declare    file_basename
   declare -i file_length

   # Truncate file, if necessary, and grab file information, splitting on
   # Unit Separator (\037)
   IFS=$'\037' read -r file_basename file_length < <(__truncate_filename "$1")

   # Print current FLAC being processed
   __print_item "${file_basename}" "${file_length}" "$3" 'half'

   # Check if file is a FLAC file (hide output)
   metaflac --show-md5sum "${1}" >/dev/null 2>&1

   # Exit code 1 implies failure (130 is SIGINT)
   if (( ${?} == 1 )) ; then
      # Error with FLAC file, display failed/error
      __print_status 'fail' "${file_basename}" "${file_length}"

      # Log FLAC failure
      printf "%s__redoflacs::delimiter__Not a real FLAC file\n" "${1}" \
         >> "${log_file}"

      # Add one to fail fd
      printf '.' >> "${issue_ticks}"
   else
      # Find all the artwork blocks available in the current FLAC file
      __find_artwork "$1"

      # If the user chose a location to store extracted artwork, then prepend
      # a counter in front of the directory to prevent clobbering since all
      # the artwork will be housed in one directory.  Otherwise the artwork
      # will be placed in a subdirectory where the current FLAC file is
      # located
      if [[ -n "${artwork_location}" ]] ; then
         # Example: /artwork_location/[1] 01.flac_[redoflacs_art]_8792
         artwork_directory="${artwork_location}/[${iteration}] ${1##*/}_[redoflacs_art]_$$"
      else
         # Example: /path/to/current/flac/01.flac_[redoflacs_art]_8792
         artwork_directory="${1}_[redoflacs_art]_$$"
      fi

      #~~~~~~~
      # Other
      #~~~~~~~
      # Only extact the artwork if any was found
      if [[ -n "${artwork_other[@]}" ]] ; then
         # Create the directory where extracted artwork will be placed
         mkdir -p "${artwork_directory}"

         # If there was only one image for the given artwork type, then
         # extract it, otherwise make sure to add a number at the end of the
         # image in case there is more than one to prevent clobbering
         if (( ${#artwork_other[@]} == 1 )) ; then
            __do_extract "${artwork_other[0]}"
         else

            # Run through the images found in the file for the given artwork
            # type, stripping the extension, adding a number indicating
            # image number was found and appending the extension back before
            # extracting the images
            for art_file in "${!artwork_other[@]}" ; do
               artwork_extension="${artwork_other[${art_file}]##*.}"
               __do_extract "${artwork_other[${art_file}]%.*} ($(( art_file + 1 ))).${artwork_extension}"
            done
         fi
      fi

      #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      # 32x32 pixels 'file icon' (PNG only)
      #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      # Only extact the artwork if any was found
      if [[ -n "${artwork_file_icon[@]}" ]] ; then
         # Create the directory where extracted artwork will be placed
         mkdir -p "${artwork_directory}"

         # If there was only one image for the given artwork type, then
         # extract it, otherwise make sure to add a number at the end of the
         # image in case there is more than one to prevent clobbering
         if (( ${#artwork_file_icon[@]} == 1 )) ; then
            __do_extract "${artwork_file_icon[0]}"
         else

            # Run through the images found in the file for the given artwork
            # type, stripping the extension, adding a number indicating
            # image number was found and appending the extension back before
            # extracting the images
            for art_file in "${!artwork_file_icon[@]}" ; do
               artwork_extension="${artwork_file_icon[${art_file}]##*.}"
               __do_extract "${artwork_file_icon[${art_file}]%.*} ($(( art_file + 1 ))).${artwork_extension}"
            done
         fi
      fi

      #~~~~~~~~~~~~~~~~~
      # Other file icon
      #~~~~~~~~~~~~~~~~~
      # Only extact the artwork if any was found
      if [[ -n "${artwork_other_file_icon[@]}" ]] ; then
         # Create the directory where extracted artwork will be placed
         mkdir -p "${artwork_directory}"

         # If there was only one image for the given artwork type, then
         # extract it, otherwise make sure to add a number at the end of the
         # image in case there is more than one to prevent clobbering
         if (( ${#artwork_other_file_icon[@]} == 1 )) ; then
            __do_extract "${artwork_other_file_icon[0]}"
         else

            # Run through the images found in the file for the given artwork
            # type, stripping the extension, adding a number indicating
            # image number was found and appending the extension back before
            # extracting the images
            for art_file in "${!artwork_other_file_icon[@]}" ; do
               artwork_extension="${artwork_other_file_icon[${art_file}]##*.}"
               __do_extract "${artwork_other_file_icon[${art_file}]%.*} ($(( art_file + 1 ))).${artwork_extension}"
            done
         fi
      fi

      #~~~~~~~~~~~~~~~
      # Cover (front)
      #~~~~~~~~~~~~~~~
      # Only extact the artwork if any was found
      if [[ -n "${artwork_cover_front[@]}" ]] ; then
         # Create the directory where extracted artwork will be placed
         mkdir -p "${artwork_directory}"

         # If there was only one image for the given artwork type, then
         # extract it, otherwise make sure to add a number at the end of the
         # image in case there is more than one to prevent clobbering
         if (( ${#artwork_cover_front[@]} == 1 )) ; then
            __do_extract "${artwork_cover_front[0]}"
         else

            # Run through the images found in the file for the given artwork
            # type, stripping the extension, adding a number indicating
            # image number was found and appending the extension back before
            # extracting the images
            for art_file in "${!artwork_cover_front[@]}" ; do
               artwork_extension="${artwork_cover_front[${art_file}]##*.}"
               __do_extract "${artwork_cover_front[${art_file}]%.*} ($(( art_file + 1 ))).${artwork_extension}"
            done
         fi
      fi

      #~~~~~~~~~~~~~~
      # Cover (back)
      #~~~~~~~~~~~~~~
      # Only extact the artwork if any was found
      if [[ -n "${artwork_cover_back[@]}" ]] ; then
         # Create the directory where extracted artwork will be placed
         mkdir -p "${artwork_directory}"

         # If there was only one image for the given artwork type, then
         # extract it, otherwise make sure to add a number at the end of the
         # image in case there is more than one to prevent clobbering
         if (( ${#artwork_cover_back[@]} == 1 )) ; then
            __do_extract "${artwork_cover_back[0]}"
         else

            # Run through the images found in the file for the given artwork
            # type, stripping the extension, adding a number indicating
            # image number was found and appending the extension back before
            # extracting the images
            for art_file in "${!artwork_cover_back[@]}" ; do
               artwork_extension="${artwork_cover_back[${art_file}]##*.}"
               __do_extract "${artwork_cover_back[${art_file}]%.*} ($(( art_file + 1 ))).${artwork_extension}"
            done
         fi
      fi

      #~~~~~~~~~~~~~~
      # Leaflet page
      #~~~~~~~~~~~~~~
      # Only extact the artwork if any was found
      if [[ -n "${artwork_leaflet[@]}" ]] ; then
         # Create the directory where extracted artwork will be placed
         mkdir -p "${artwork_directory}"

         # If there was only one image for the given artwork type, then
         # extract it, otherwise make sure to add a number at the end of the
         # image in case there is more than one to prevent clobbering
         if (( ${#artwork_leaflet[@]} == 1 )) ; then
            __do_extract "${artwork_leaflet[0]}"
         else

            # Run through the images found in the file for the given artwork
            # type, stripping the extension, adding a number indicating
            # image number was found and appending the extension back before
            # extracting the images
            for art_file in "${!artwork_leaflet[@]}" ; do
               artwork_extension="${artwork_leaflet[${art_file}]##*.}"
               __do_extract "${artwork_leaflet[${art_file}]%.*} ($(( art_file + 1 ))).${artwork_extension}"
            done
         fi
      fi

      #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      # Media (e.g. label side of CD)
      #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      # Only extact the artwork if any was found
      if [[ -n "${artwork_media_label[@]}" ]] ; then
         # Create the directory where extracted artwork will be placed
         mkdir -p "${artwork_directory}"

         # If there was only one image for the given artwork type, then
         # extract it, otherwise make sure to add a number at the end of the
         # image in case there is more than one to prevent clobbering
         if (( ${#artwork_media_label[@]} == 1 )) ; then
            __do_extract "${artwork_media_label[0]}"
         else

            # Run through the images found in the file for the given artwork
            # type, stripping the extension, adding a number indicating
            # image number was found and appending the extension back before
            # extracting the images
            for art_file in "${!artwork_media_label[@]}" ; do
               artwork_extension="${artwork_media_label[${art_file}]##*.}"
               __do_extract "${artwork_media_label[${art_file}]%.*} ($(( art_file + 1 ))).${artwork_extension}"
            done
         fi
      fi

      #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      # Lead artist/lead performer/soloist
      #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      # Only extact the artwork if any was found
      if [[ -n "${artwork_lead_artist[@]}" ]] ; then
         # Create the directory where extracted artwork will be placed
         mkdir -p "${artwork_directory}"

         # If there was only one image for the given artwork type, then
         # extract it, otherwise make sure to add a number at the end of the
         # image in case there is more than one to prevent clobbering
         if (( ${#artwork_lead_artist[@]} == 1 )) ; then
            __do_extract "${artwork_lead_artist[0]}"
         else

            # Run through the images found in the file for the given artwork
            # type, stripping the extension, adding a number indicating
            # image number was found and appending the extension back before
            # extracting the images
            for art_file in "${!artwork_lead_artist[@]}" ; do
               artwork_extension="${artwork_lead_artist[${art_file}]##*.}"
               __do_extract "${artwork_lead_artist[${art_file}]%.*} ($(( art_file + 1 ))).${artwork_extension}"
            done
         fi
      fi

      #~~~~~~~~~~~~~~~~~~
      # Artist/performer
      #~~~~~~~~~~~~~~~~~~
      # Only extact the artwork if any was found
      if [[ -n "${artwork_artist[@]}" ]] ; then
         # Create the directory where extracted artwork will be placed
         mkdir -p "${artwork_directory}"

         # If there was only one image for the given artwork type, then
         # extract it, otherwise make sure to add a number at the end of the
         # image in case there is more than one to prevent clobbering
         if (( ${#artwork_artist[@]} == 1 )) ; then
            __do_extract "${artwork_artist[0]}"
         else

            # Run through the images found in the file for the given artwork
            # type, stripping the extension, adding a number indicating
            # image number was found and appending the extension back before
            # extracting the images
            for art_file in "${!artwork_artist[@]}" ; do
               artwork_extension="${artwork_artist[${art_file}]##*.}"
               __do_extract "${artwork_artist[${art_file}]%.*} ($(( art_file + 1 ))).${artwork_extension}"
            done
         fi
      fi

      #~~~~~~~~~~~
      # Conductor
      #~~~~~~~~~~~
      # Only extact the artwork if any was found
      if [[ -n "${artwork_conductor[@]}" ]] ; then
         # Create the directory where extracted artwork will be placed
         mkdir -p "${artwork_directory}"

         # If there was only one image for the given artwork type, then
         # extract it, otherwise make sure to add a number at the end of the
         # image in case there is more than one to prevent clobbering
         if (( ${#artwork_conductor[@]} == 1 )) ; then
            __do_extract "${artwork_conductor[0]}"
         else

            # Run through the images found in the file for the given artwork
            # type, stripping the extension, adding a number indicating
            # image number was found and appending the extension back before
            # extracting the images
            for art_file in "${!artwork_conductor[@]}" ; do
               artwork_extension="${artwork_conductor[${art_file}]##*.}"
               __do_extract "${artwork_conductor[${art_file}]%.*} ($(( art_file + 1 ))).${artwork_extension}"
            done
         fi
      fi

      #~~~~~~~~~~~~~~~~
      # Band/Orchestra
      #~~~~~~~~~~~~~~~~
      # Only extact the artwork if any was found
      if [[ -n "${artwork_band[@]}" ]] ; then
         # Create the directory where extracted artwork will be placed
         mkdir -p "${artwork_directory}"

         # If there was only one image for the given artwork type, then
         # extract it, otherwise make sure to add a number at the end of the
         # image in case there is more than one to prevent clobbering
         if (( ${#artwork_band[@]} == 1 )) ; then
            __do_extract "${artwork_band[0]}"
         else

            # Run through the images found in the file for the given artwork
            # type, stripping the extension, adding a number indicating
            # image number was found and appending the extension back before
            # extracting the images
            for art_file in "${!artwork_band[@]}" ; do
               artwork_extension="${artwork_band[${art_file}]##*.}"
               __do_extract "${artwork_band[${art_file}]%.*} ($(( art_file + 1 ))).${artwork_extension}"
            done
         fi
      fi

      #~~~~~~~~~~
      # Composer
      #~~~~~~~~~~
      # Only extact the artwork if any was found
      if [[ -n "${artwork_composer[@]}" ]] ; then
         # Create the directory where extracted artwork will be placed
         mkdir -p "${artwork_directory}"

         # If there was only one image for the given artwork type, then
         # extract it, otherwise make sure to add a number at the end of the
         # image in case there is more than one to prevent clobbering
         if (( ${#artwork_composer[@]} == 1 )) ; then
            __do_extract "${artwork_composer[0]}"
         else

            # Run through the images found in the file for the given artwork
            # type, stripping the extension, adding a number indicating
            # image number was found and appending the extension back before
            # extracting the images
            for art_file in "${!artwork_composer[@]}" ; do
               artwork_extension="${artwork_composer[${art_file}]##*.}"
               __do_extract "${artwork_composer[${art_file}]%.*} ($(( art_file + 1 ))).${artwork_extension}"
            done
         fi
      fi

      #~~~~~~~~~~~~~~~~~~~~~~
      # Lyricist/text writer
      #~~~~~~~~~~~~~~~~~~~~~~
      # Only extact the artwork if any was found
      if [[ -n "${artwork_lyricist[@]}" ]] ; then
         # Create the directory where extracted artwork will be placed
         mkdir -p "${artwork_directory}"

         # If there was only one image for the given artwork type, then
         # extract it, otherwise make sure to add a number at the end of the
         # image in case there is more than one to prevent clobbering
         if (( ${#artwork_lyricist[@]} == 1 )) ; then
            __do_extract "${artwork_lyricist[0]}"
         else

            # Run through the images found in the file for the given artwork
            # type, stripping the extension, adding a number indicating
            # image number was found and appending the extension back before
            # extracting the images
            for art_file in "${!artwork_lyricist[@]}" ; do
               artwork_extension="${artwork_lyricist[${art_file}]##*.}"
               __do_extract "${artwork_lyricist[${art_file}]%.*} ($(( art_file + 1 ))).${artwork_extension}"
            done
         fi
      fi

      #~~~~~~~~~~~~~~~~~~~~
      # Recording Location
      #~~~~~~~~~~~~~~~~~~~~
      # Only extact the artwork if any was found
      if [[ -n "${artwork_recording_location[@]}" ]] ; then
         # Create the directory where extracted artwork will be placed
         mkdir -p "${artwork_directory}"

         # If there was only one image for the given artwork type, then
         # extract it, otherwise make sure to add a number at the end of the
         # image in case there is more than one to prevent clobbering
         if (( ${#artwork_recording_location[@]} == 1 )) ; then
            __do_extract "${artwork_recording_location[0]}"
         else

            # Run through the images found in the file for the given artwork
            # type, stripping the extension, adding a number indicating
            # image number was found and appending the extension back before
            # extracting the images
            for art_file in "${!artwork_recording_location[@]}" ; do
               artwork_extension="${artwork_recording_location[${art_file}]##*.}"
               __do_extract "${artwork_recording_location[${art_file}]%.*} ($(( art_file + 1 ))).${artwork_extension}"
            done
         fi
      fi

      #~~~~~~~~~~~~~~~~~~
      # During recording
      #~~~~~~~~~~~~~~~~~~
      # Only extact the artwork if any was found
      if [[ -n "${artwork_during_recording[@]}" ]] ; then
         # Create the directory where extracted artwork will be placed
         mkdir -p "${artwork_directory}"

         # If there was only one image for the given artwork type, then
         # extract it, otherwise make sure to add a number at the end of the
         # image in case there is more than one to prevent clobbering
         if (( ${#artwork_during_recording[@]} == 1 )) ; then
            __do_extract "${artwork_during_recording[0]}"
         else

            # Run through the images found in the file for the given artwork
            # type, stripping the extension, adding a number indicating
            # image number was found and appending the extension back before
            # extracting the images
            for art_file in "${!artwork_during_recording[@]}" ; do
               artwork_extension="${artwork_during_recording[${art_file}]##*.}"
               __do_extract "${artwork_during_recording[${art_file}]%.*} ($(( art_file + 1 ))).${artwork_extension}"
            done
         fi
      fi

      #~~~~~~~~~~~~~~~~~~~~
      # During performance
      #~~~~~~~~~~~~~~~~~~~~
      # Only extact the artwork if any was found
      if [[ -n "${artwork_during_performance[@]}" ]] ; then
         # Create the directory where extracted artwork will be placed
         mkdir -p "${artwork_directory}"

         # If there was only one image for the given artwork type, then
         # extract it, otherwise make sure to add a number at the end of the
         # image in case there is more than one to prevent clobbering
         if (( ${#artwork_during_performance[@]} == 1 )) ; then
            __do_extract "${artwork_during_performance[0]}"
         else

            # Run through the images found in the file for the given artwork
            # type, stripping the extension, adding a number indicating
            # image number was found and appending the extension back before
            # extracting the images
            for art_file in "${!artwork_during_performance[@]}" ; do
               artwork_extension="${artwork_during_performance[${art_file}]##*.}"
               __do_extract "${artwork_during_performance[${art_file}]%.*} ($(( art_file + 1 ))).${artwork_extension}"
            done
         fi
      fi

      #~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      # Movie/video screen capture
      #~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      # Only extact the artwork if any was found
      if [[ -n "${artwork_movie[@]}" ]] ; then
         # Create the directory where extracted artwork will be placed
         mkdir -p "${artwork_directory}"

         # If there was only one image for the given artwork type, then
         # extract it, otherwise make sure to add a number at the end of the
         # image in case there is more than one to prevent clobbering
         if (( ${#artwork_movie[@]} == 1 )) ; then
            __do_extract "${artwork_movie[0]}"
         else

            # Run through the images found in the file for the given artwork
            # type, stripping the extension, adding a number indicating
            # image number was found and appending the extension back before
            # extracting the images
            for art_file in "${!artwork_movie[@]}" ; do
               artwork_extension="${artwork_movie[${art_file}]##*.}"
               __do_extract "${artwork_movie[${art_file}]%.*} ($(( art_file + 1 ))).${artwork_extension}"
            done
         fi
      fi

      #~~~~~~~~~~~~~~~~~~~~~~~~
      # A bright coloured fish
      #~~~~~~~~~~~~~~~~~~~~~~~~
      # Only extact the artwork if any was found
      if [[ -n "${artwork_fish[@]}" ]] ; then
         # Create the directory where extracted artwork will be placed
         mkdir -p "${artwork_directory}"

         # If there was only one image for the given artwork type, then
         # extract it, otherwise make sure to add a number at the end of the
         # image in case there is more than one to prevent clobbering
         if (( ${#artwork_fish[@]} == 1 )) ; then
            __do_extract "${artwork_fish[0]}"
         else

            # Run through the images found in the file for the given artwork
            # type, stripping the extension, adding a number indicating
            # image number was found and appending the extension back before
            # extracting the images
            for art_file in "${!artwork_fish[@]}" ; do
               artwork_extension="${artwork_fish[${art_file}]##*.}"
               __do_extract "${artwork_fish[${art_file}]%.*} ($(( art_file + 1 ))).${artwork_extension}"
            done
         fi
      fi

      #~~~~~~~~~~~~~~
      # Illustration
      #~~~~~~~~~~~~~~
      # Only extact the artwork if any was found
      if [[ -n "${artwork_illustration[@]}" ]] ; then
         # Create the directory where extracted artwork will be placed
         mkdir -p "${artwork_directory}"

         # If there was only one image for the given artwork type, then
         # extract it, otherwise make sure to add a number at the end of the
         # image in case there is more than one to prevent clobbering
         if (( ${#artwork_illustration[@]} == 1 )) ; then
            __do_extract "${artwork_illustration[0]}"
         else

            # Run through the images found in the file for the given artwork
            # type, stripping the extension, adding a number indicating
            # image number was found and appending the extension back before
            # extracting the images
            for art_file in "${!artwork_illustration[@]}" ; do
               artwork_extension="${artwork_illustration[${art_file}]##*.}"
               __do_extract "${artwork_illustration[${art_file}]%.*} ($(( art_file + 1 ))).${artwork_extension}"
            done
         fi
      fi

      #~~~~~~~~~~~~~~~~~~~~~~
      # Band/artist logotype
      #~~~~~~~~~~~~~~~~~~~~~~
      # Only extact the artwork if any was found
      if [[ -n "${artwork_band_logo[@]}" ]] ; then
         # Create the directory where extracted artwork will be placed
         mkdir -p "${artwork_directory}"

         # If there was only one image for the given artwork type, then
         # extract it, otherwise make sure to add a number at the end of the
         # image in case there is more than one to prevent clobbering
         if (( ${#artwork_band_logo[@]} == 1 )) ; then
            __do_extract "${artwork_band_logo[0]}"
         else

            # Run through the images found in the file for the given artwork
            # type, stripping the extension, adding a number indicating
            # image number was found and appending the extension back before
            # extracting the images
            for art_file in "${!artwork_band_logo[@]}" ; do
               artwork_extension="${artwork_band_logo[${art_file}]##*.}"
               __do_extract "${artwork_band_logo[${art_file}]%.*} ($(( art_file + 1 ))).${artwork_extension}"
            done
         fi
      fi

      #~~~~~~~~~~~~~~~~~~~~~~~~~~~
      # Publisher/Studio logotype
      #~~~~~~~~~~~~~~~~~~~~~~~~~~~
      # Only extact the artwork if any was found
      if [[ -n "${artwork_publisher_logo[@]}" ]] ; then
         # Create the directory where extracted artwork will be placed
         mkdir -p "${artwork_directory}"

         # If there was only one image for the given artwork type, then
         # extract it, otherwise make sure to add a number at the end of the
         # image in case there is more than one to prevent clobbering
         if (( ${#artwork_publisher_logo[@]} == 1 )) ; then
            __do_extract "${artwork_publisher_logo[0]}"
         else

            # Run through the images found in the file for the given artwork
            # type, stripping the extension, adding a number indicating
            # image number was found and appending the extension back before
            # extracting the images
            for art_file in "${!artwork_publisher_logo[@]}" ; do
               artwork_extension="${artwork_publisher_logo[${art_file}]##*.}"
               __do_extract "${artwork_publisher_logo[${art_file}]%.*} ($(( art_file + 1 ))).${artwork_extension}"
            done
         fi
      fi

      # Unset all the arrays used so we don't pollute other files
      unset -v \
         artwork_other \
         artwork_file_icon \
         artwork_other_file_icon \
         artwork_cover_front \
         artwork_cover_back \
         artwork_leaflet \
         artwork_media_label \
         artwork_lead_artist \
         artwork_artist \
         artwork_conductor \
         artwork_band \
         artwork_composer \
         artwork_lyricist \
         artwork_recording_location \
         artwork_during_recording \
         artwork_during_performance \
         artwork_movie \
         artwork_fish \
         artwork_illustration \
         artwork_band_logo \
         artwork_publisher_logo

      # FLAC is ok, display ok
      __print_status 'ok' "${file_basename}" "${file_length}"
   fi

   # Store the position of where the line of the FLAC file is displayed in file
   # descriptor (3), to be used by the next job, terminated by a newline to
   # indicate job completed
   __store_position
}

#-------------------------------------------------------------------------------

# Prune FLACS
__prune() {
   # Prune given FLAC by removing various BLOCKs (defined in user configuration)
   #--
   # $1 is the filename
   # $2 is the operation that's currently being run, of which, can be:
   #   aucdtect          aucdtect_spectrogram     md5_check
   #   compress_verify   compress_no_test         test
   #   replaygain_test   replaygain_force_apply   replaygain_apply
   #   retag_analyze     retag_apply              extract_artwork
   #   prune
   # $3 is a string representing number items processed, eg: [43/439]
   #--
   trap '__kill_jobs "$(jobs -rp)"' EXIT

   # Set up local variables
   declare    file_basename
   declare -i file_length

   # Truncate file, if necessary, and grab file information, splitting on
   # Unit Separator (\037)
   IFS=$'\037' read -r file_basename file_length < <(__truncate_filename "$1")

   # Print current FLAC being processed
   __print_item "${file_basename}" "${file_length}" "$3" 'half'

   # Check if file is a FLAC file (hide output)
   metaflac --show-md5sum "${1}" >/dev/null 2>&1

   # Exit code 1 implies failure (130 is SIGINT)
   if (( ${?} == 1 )) ; then
      # Error with FLAC file, display failed/error
      __print_status 'fail' "${file_basename}" "${file_length}"

      # Log FLAC failure
      printf "%s__redoflacs::delimiter__Not a real FLAC file\n" "${1}" \
         >> "${log_file}"

      # Add one to fail fd
      printf '.' >> "${issue_ticks}"
   else
      # Remove all information but STREAMINFO,VORBIS_COMMENTs, and
      # possibly METADATA_BLOCK_PICTURE
      metaflac --remove --dont-use-padding --except-block-type="${dont_prune_flac_metadata}" "${1}"

      # FLAC is ok, display ok
      __print_status 'ok' "${file_basename}" "${file_length}"
   fi

   # Store the position of where the line of the FLAC file is displayed in file
   # descriptor (3), to be used by the next job, terminated by a newline to
   # indicate job completed
   __store_position
}

# .: PRE-SCRIPT CHECKS :.
#-------------------------------------------------------------------------------
# Enable BASH 4 globstar
shopt -s globstar

# Version
version="0.23_pre"

# This sets the script configuration revision (used to compare against the user
# configuration revision)
script_config_revision="2"

# Set FLAC extension for easy use later
flac_extension=".[Ff][Ll][Aa][Cc]"

# Colors on by default
blue="\033[34m"
green="\033[32m"
red="\033[31m"
cyan="\033[36m"
magenta="\033[35m"
yellow="\033[33m"
invert="\033[7m"
normal="\033[0m"

declare -Ag operation_summary  # Stores all the operational states
declare -ig max_length         # Max filename to fit inside terminal width
declare unit_separator=$'\037' # ASCII unit separator

# Check if user is running under Cygwin
# and if so, warn user and exit
os_name="$(uname -o)"
if [[ "${os_name}" == "Cygwin" ]] ; then
   __error "This version of redoflacs is meant to be run under\n" >&2
   __error "${cyan}UNIX/Linux/BSD${normal}.  Please use the ${cyan}Windows (Cygwin)${normal}\n" >&2
   __error "version located here:\n" >&2
   __error "${cyan}https://github.com/sirjaren/redoflacsw/tags${normal}\n" >&2

   exit 1
fi

#-------------------------------------------------------------------------------

# Check if configuration file exists based of ${EUID}.  If it doesn't
# exist, create one
if (( EUID == 0 )) ; then
   # User is root
   #
   # Configuration file location
   config_file="/etc/redoflacs.conf"

   # Check if system-wide configuration doesn't exist
   if [[ ! -f "${config_file}" ]] ; then
      # Create system-wide configuration file
      __create_config

      # Inform user of created configuration file, reminding them to check
      # it over before running program
      __info "A configuration file has been created here:\n"
      __info "${cyan}${config_file}${normal}\n\n"

      __info "Please review it before running this program.\n"

      exit 0
   else
      # Configuration file exists, parse it
      __parse_config
   fi
else
   # User is _NOT_ root
   #
   # Configuration file location
   config_file="${HOME}/.config/redoflacs/config"

   # Check if user configuration doesn't exist
   if [[ ! -f "${config_file}" ]] ; then
      # Create '.config/redoflacs' directory (if it doesn't exist)
      mkdir -p "${config_file%/*}"

      # Create user configuration file
      __create_config

      # Inform user of created configuration file, reminding them to check
      # it over before running program
      __info "A configuration file has been created here:\n"
      __info "${cyan}${config_file}${normal}\n\n"

      __info "Please review it before running this program.\n"

      exit 0
   else
      # Configuration file exists, parse it
      __parse_config
   fi
fi

#-------------------------------------------------------------------------------

# Generate log file location
#--
# Ensure we don't overwrite an existing log file by incrementing the current
# PID by 1 until the log file that is to be set, doesn't exist
pid="$$"
log_file="${error_log}/redoflacs_${pid}.log"

until [[ ! -f "${log_file}" ]] ; do
   log_file="${error_log}/redoflacs_log_$((pid++)).log"
done

#-------------------------------------------------------------------------------

# Handle CLI arguments
__process_positional_parameters "${@}"

#-------------------------------------------------------------------------------

# Check if user set '-n, --no-color'.  This must come before everything (and
# after the positional parameters) to ensure color is set/unset.  The normal
# variable is always set, to reset the inverted colors (color or no-color)
# during progress bar output
if [[ "${no_color}" == "true" ]] ; then
   blue=""
   green=""
   red=""
   cyan=""
   magenta=""
   yellow=""
fi

#-------------------------------------------------------------------------------

# Make sure we are running BASH 4 or greater
if (( ${BASH_VERSINFO[0]} < 4 )) ; then
   __error "You must be running ${cyan}BASH 4${normal} or greater to use\n" >&2
   __error "this program!\n" >&2
   exit 1
fi

#-------------------------------------------------------------------------------

# Check for any conflicting operations/arguments called
# at script invocation and warn user
__check_conflicting_operations

#-------------------------------------------------------------------------------

# For each operation that was selected, set up operation_summary array
for operation in "${operations[@]}" ; do
   # Update status for the current operation
   __update_operation_status "${operation}" 'Operation Did Not Run'
done
#-------------------------------------------------------------------------------

# Check for any missing programs vital for this script
# to operate correctly, and exit if any programs are found
# to be missing
__check_missing_programs

#-------------------------------------------------------------------------------

# Check whether directory exists
if [[ ! -d "${directory}" ]] ; then
   printf "  Usage: redoflacs [OPTION] [PATH_TO_FLAC(s)]...\n\n" >&2
   __error "Please specify a directory!\n" >&2
   exit 1
fi

#-------------------------------------------------------------------------------

# Check for at least 1 FLAC file
read -r find_flacs < <( printf "%s\n" "${directory}"/**/*${flac_extension} )

if [[ ! -f "${find_flacs}" ]] ; then
   __error "There are not any FLAC files to process!\n" >&2
   exit 1
fi

#-------------------------------------------------------------------------------

# If "-e, --extract-artwork" was called, make sure artwork_location is a valid
# location, if user-defined
if [[ "${check_artwork_dir}" == "true" ]] ; then

   # Check if artwork_location is user-defined
   if [[ -n "${artwork_location}" ]] ; then

      # Put extracted artwork in user-defined location, testing to make sure
      # the directory exists
      if [[ ! -d "${artwork_location}" ]] ; then
         __error "${cyan}${artwork_location}${normal} doesn't exist!\n" >&2
         __error "Please set a valid directory in the configuration file!\n" >&2

         exit 1
      fi
   fi
fi

# If "-A, --aucdtect-spectrogram" was called, make sure spectrogram_location is
# a valid location, if user-defined
if [[ "${create_spectrogram}" == "true" ]] ; then

   # Check if spectrogram_location is user-defined
   if [[ -n "${spectrogram_location}" ]] ; then

      # Put spectrograms in user-defined location, testing to make sure the
      # directory exists
      if [[ ! -d "${spectrogram_location}" ]] ; then
         __error "${cyan}${spectrogram_location}${normal} doesn't exist!\n" >&2
         __error "Please set a valid directory in the configuration file!\n" >&2

         exit 1
      fi
   fi
fi

#-------------------------------------------------------------------------------

# If ${jobs} wasn't set upon invocation, check in /proc
# to see how many jobs should be run
if [[ -z "${jobs}" ]] ; then
   __find_cores
else
   jobs_display="(User Defined)"
fi

# .: START SCRIPT :.
#-------------------------------------------------------------------------------
# Store current stty settings
old_stty="$(stty -g)"

# Prevent Control-C from displaying '^C'.  May already be set
stty -ctlecho 2> /dev/null

# Hide the cursor
printf "\033[?25l"

# Check to see if config file in script is newer than user config, warning
# user if their config is older displaying a countdown before continuing
__check_config_version

# Temporary FIFO location
tmp_fifo="/tmp/redoflacs_fifo_$$"

# Set up a temporary FIFO location.  The variable
# is set up here, to prevent it from being called
# upon script invocation when auCDtect isn't going
# to be run
tmp_aucdtect_fd="/tmp/redoflacs_aucdtect_fifo_$$"

# Enforce FIFO is removed right away if user invokes SIGINT _immediately_ after
# script invocation
trap 'rm -f "${tmp_fifo}" "${tmp_aucdtect_fd}"' EXIT

mkfifo "${tmp_fifo}" "${tmp_aucdtect_fd}"

# Open auCDtect FIFO for reading and writing on file descriptor '4'
exec 4<>"${tmp_aucdtect_fd}"

# File where a tick is placed for each issue found
issue_ticks="/tmp/redoflacs_issue_file_$$"

# Display a countdown if retagging FLACs
[[ "${operations[8]}" == 'retag_analyze' ]] && __countdown_metadata

# Display top banner
__top_banner

# Grab the total flacs to process
total_items=( "${directory}"/**/*${flac_extension} )

# This displays '[ ok ]' after 'Finding FLAC files to process...'
__processed_flacs_ok

#-------------------------------------------------------------------------------

for operation in "${operations[@]}" ; do
   # Loop through the various operations to run.  All the operations are to be
   # run, in order, which is detailed below:
   #   operations[0]='aucdtect'
   #   operations[1]='aucdtect_spectrogram'
   #   operations[2]='md5_check'
   #   operations[3]='compress_verify'
   #   operations[4]='compress_no_test'
   #   operations[5]='test'
   #   operations[6]='replaygain_test'
   #   operations[7]='replaygain_force_apply'   # Conditionally set
   #   operations[7]='replaygain_apply'         # Conditionally set
   #   operations[8]='retag_analyze'
   #   operations[9]='retag_apply'
   #   operations[10]='extract_artwork'
   #   operations[11]='prune'
   #--
   if [[ "${operation}" == 'replaygain_'*'apply' ]] ; then
      # Change current directory to absolute pathname
      [[ "${directory}" == "." ]] && directory="${PWD}"

      # List of directories to process
      total_items_backup=( "${total_items[@]}" )  # Total FLACs backup array
      __get_directory_list "${total_items[@]}"    # Returns $total_dirs[@]
      total_items=( "${total_dirs[@]}" )          # Now process directories
   fi

   if [[ "${operation}" == 'prune' ]] ; then
      # Set which FLAC metadata BLOCKS to remove
      if [[ "${remove_artwork}" == "true" ]] ; then
         # Remove artwork
         dont_prune_flac_metadata="STREAMINFO,VORBIS_COMMENT"
      else
         # Don't remove artwork
         dont_prune_flac_metadata="STREAMINFO,PICTURE,VORBIS_COMMENT"
      fi
   fi

   # Prints title message of current operation
   __message "${operation}"

   # Scroll terminal, if needed
   __scroll_terminal

   # Make sure to clear file descriptor '3' before proceeding
   __clear_tmp_fd

   # Set the cursor to the correct row depending on whether there were more
   # or less files to process than the number of jobs to run
   if (( ${#total_items[@]} < jobs )) ; then
      # Less files than jobs to run, so only add the number of files
      # processed
      post_row=$(( $(__row) + ${#total_items[@]} ))
   else
      # More files than jobs to run, so add the number of jobs processed
      post_row=$(( $(__row) + jobs ))
   fi

   trap '__trap_sigint "$post_row" "${operation}"' SIGINT

   # Run parallel operations, that which is specified as ${1}
   __run_parallel "${operation}"

   printf "\033[${post_row}H"

   if [[ -f "${log_file}" ]] ; then
      # Print out log exists to STDERR
      __message_log_exists "${operation}"

      # Create and format log
      __create_log "${operation}"

      # Update status for the current operation
      __update_operation_status "${operation}" "$(__num_issues)"

      # Display Summary Of Operations
      __summary

      exit 1
   fi

   # Update status for the current operation
   __update_operation_status "${operation}" 'Operation Completed'

   # Restore the items to process from directories to FLACs
   [[ "${operation}" == 'replaygain_'*'apply' ]] && total_items=( "${total_items_backup[@]}" )
done

#-------------------------------------------------------------------------------

# Display Summary Of Operations
__summary
