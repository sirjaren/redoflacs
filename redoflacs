#!/usr/bin/env bash
# vim: ts=2:sts=2:sw=2:et:ft=sh:
#------------------------------------------------------------------------------
# NAME
#   redoflacs - BASH commandline FLAC compressor, verifier, organizer,
#               analyzer, and retagger
#
# FILE INFORMATION
#   Author:        Jaren Stangret <sirjaren@gmail.com>
#   Homepage:      https://github.com/sirjaren/redoflacs
#   Dependencies:  BASH >= 4.0
#
# DISTRIBUTION
#   The MIT License
#
#   Copyright 2018 Jaren Stangret
#
#   Permission is hereby granted, free of charge, to any person obtaining a
#   copy of this software and associated documentation files (the "Software"),
#   to deal in the Software without restriction, including without limitation
#   the rights to use, copy, modify, merge, publish, distribute, sublicense,
#   and/or sell copies of the Software, and to permit persons to whom the
#   Software is furnished to do so, subject to the following conditions:
#
#   The above copyright notice and this permission notice shall be included in
#   all copies or substantial portions of the Software.
#
#   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
#   FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
#   DEALINGS IN THE SOFTWARE.
#------------------------------------------------------------------------------

#################################  FUNCTIONS  #################################

_info() { printf     " ${green}*${reset} ${@}";  }  # Bold green message
_warn() { printf >&2 " ${yellow}*${reset} ${@}"; }  # Yellow message
_error(){ printf >&2 " ${red}*${reset} ${@}";    }  # Bold red message

_print_ok()   { printf "\033[${row}H${green}100%%${reset}"; }
_print_fail() { printf "\033[${row}H${red}fail${reset}";    }
_print_check(){ printf "\033[${row}H${yellow}chck${reset}"; }
_print_skip() { printf "\033[${row}H${cyan}chck${reset}";   }

#
# Display help
#
_help()
{
  IFS='' read -rd '' << HELP_EOF
Usage: redoflacs [operations] [options] [target] ...

Operations:
  -c, --compress
  -C, --compress-notest
  -t, --test
  -m, --md5check
  -a, --aucdtect
  -A, --aucdtect-spectrogram
  -e, --extract-artwork
  -p, --prune
  -g, --replaygain
  -G, --replaygain-noforce
  -r, --retag
  -l, --all
  -L, --reallyall

Options:
  -j[N], --jobs[=N]
  -n, --no-color
  -x, --no-extra-tags
  -o, --new-config
  -v, --version
  -h, --help

See redoflacs(1) for more information.
HELP_EOF

  printf '%s' "$REPLY"
}

#
# Display usage
#
_usage()
{
  printf >&2 ' Usage: redoflacs [operations] [options] [target] ...\n'
}

#
# Print out the correct operational message regarding a log file's existence
# and what infomration that log may contain.
#
# $1 determines the log file to use, as well as how many lines are printed out
# to correctly set the current row.  Possible values:
#   aucdtect                  md5_check           compress_verify
#   compress_no_test          test                replaygain_test
#   replaygain_force_apply    replaygain_apply    retag_analyze
#   retag_apply               extract_images      prune
#
_message_log_exists()
{
  case "$1" in
    'aucdtect'*)
      _error 'Some FLAC files may be lossy sourced, please check:\n'
    ;;
    'md5_check')
      _error 'The MD5 Signature is unset for some FLAC files or there were\n'
      _error 'issues with some of the FLAC files, please check:\n'
    ;;
    'compress_'*|'test'|'replaygain_test'|'extract_images'|'prune')
      _error 'There were issues with some of the FLAC files,\n'
      _error 'please check:\n'
    ;;
    'replaygain'*'apply')
      _error 'There were issues adding ReplayGain values,\n'
      _error 'please check:\n'
    ;;
    'retag_'*)
      _error 'Some FLAC files have missing tags or there were\n'
      _error 'issues with some of the FLAC files, please check:\n'
    ;;
  esac

  # Print the bottom half of the message (uniform across all operations)
  _error "${cyan}${log_file}${reset}\n"
  _error 'for details.\n'
}

#
# Print out current operation message
#
# $1 determines which title message to print (if any).  Possible values:
#   aucdtect                  md5_check           compress_verify
#   compress_no_test          test                replaygain_test
#   replaygain_force_apply    replaygain_apply    retag_analyze
#   retag_apply               extract_images      prune
#
# $2 is the number of processed items (iteration)
#
# $3 is conditionally called, and appears if the operation was interrupted:
#   Interrupted operation: $3 == 'interrupt'
#     Operation completed: $3 is NULL
#
_message()
{
  # Set up local variables
  declare message sub_message
  declare -i issues spacing

  # Print title message if $1 is not NULL
  if [[ -n "${1}" ]]; then
    case "${1}" in
      'aucdtect')          message='Validating with auCDtect'                ;;
      'md5_check')         message='Check MD5 Signature'                     ;;
      'compress_'*)        message="Level ${compression_level} Compression"  ;;
      'test')              message='Test FLACs'                              ;;
      'extract_images')    message='Extracting Artwork'                      ;;
      'replaygain_'*)
        if [[ "${1}" == 'replaygain_test' ]]; then
          message='Applying ReplayGain'
          sub_message='Testing'
        else  #  'replaygain'*'apply'
          sub_message='Applying'
        fi
      ;;
      'retag_'*)
        if [[ "${1}" == 'retag_analyze' ]]; then
          message='Retagging FLACs'
          sub_message='Analyzing'
        else  #  'retag_apply'
          sub_message='Re-Tagging'
        fi
      ;;
      'prune')
        message='Prune METADATA Blocks'
      ;;
    esac

    # Print title message, if applicable
    if [[ -n "${message}" && -z "$2" ]]; then
      printf "\033[$(_row)H ${green}*${reset} ${message}\n"
    fi

    # Print sub title message, if applicable
    if [[ -n "${sub_message}" && -z "$2" ]]; then
      printf "\033[$(_row);3H${green}>>${reset} ${sub_message}\n"
    fi
  fi

  # Update title/sub title message only if $2 is not NULL
  if [[ -n "${2}" ]]; then
    issues=$(_num_issues)  # Number of issues

    # Specify color according to operation status
    [[ "${3}" == 'interrupt' ]] && color="${cyan}" || color="${green}"

    # Verbage for singular/plural issues
    (( issues == 1 )) && issue_string='issue ' || issue_string='issues'

    if [[ -n "${sub_message}" ]]; then
      # Space between message and number of items proccessed
      spacing=$((44 - ${#sub_message} - ${#2} - ${#issues} - 14))

      # Sub title message
      printf "\033[2A   ${green}>>${reset} %s%${spacing}s${blue}[ ${color}%d ok${blue} | ${red}%d ${issue_string}${blue} ]${reset}\n" \
        "${sub_message}" '' "$2" "${issues}"
    else
      # Space between message and number of items proccessed
      spacing=$((46 - ${#message} - ${#2} - ${#issues} - 14))

      # Title message
      printf "\033[2A  ${green}*${reset} %s%${spacing}s${blue}[ ${color}%d ok${blue} | ${red}%d ${issue_string}${blue} ]${reset}\n" \
        "${message}" '' "$2" "${issues}"
    fi
  fi
}

#
# Update $operation_summary[@] with the current operation status
#
# $1 determines which operational index to update; possible values:
#   aucdtect                  md5_check           compress_verify
#   compress_no_test          test                replaygain_test
#   replaygain_force_apply    replaygain_apply    retag_analyze
#   retag_apply               extract_images      prune
#
# $2 is the operational status, the values of which, can be:
#   Operation Completed       Operation Interrupted
#   Operation Did Not Run
#
_update_operation_status()
{
  case "${1}" in
    'aucdtect'*)          operation_summary['Validate with auCDtect']="${2}" ;;
    'md5_check')          operation_summary['Check MD5 Signature']="${2}"    ;;
    'compress_'*)         operation_summary['Compress FLACs']="${2}"         ;;
    'test')               operation_summary['Test FLACs']="${2}"             ;;
    'replaygain_test')    operation_summary['>> Testing']="${2}"             ;;
    'replaygain'*'apply') operation_summary['>> Applying']="${2}"            ;;
    'retag_analyze')      operation_summary['>> Analyzing']="${2}"           ;;
    'retag_apply')        operation_summary['>> Re-Tagging']="${2}"          ;;
    'extract_images')     operation_summary['Extracting Artwork']="${2}"     ;;
    'prune')              operation_summary['Prune METADATA Blocks']="${2}"  ;;
  esac
}

#
# Displays the currently processed item on a dedicated row within the terminal.
# The filename is truncated if the length of the filename is greater than 79
# characters or greater than the width of the the terminal.  This is determined
# by MAX_LENGTH
#
_print_item()
{
  local fmt
  local basename="${item##*/}"

  # This printf format string displays the currently processed item
  fmt+=$"\033[${row};6H"              # Cursor row; 6 columns to right
  fmt+=$"\033[0K"                     # Erase line from cursor to right
  fmt+='%s'                           # Printf modifier; current item basename
  fmt+=$"\033[${row};${MAX_LENGTH}H"  # Cursor at row; at max filename length
  fmt+=$"\033[0K"                     # Erase line from cursor to right

  printf "$fmt" "$basename"

  return

  # Set up local variables
  declare -i  print_spacing='1'

  case "$4" in
    '')
      #       08 - track.flac                           [12/345]
      (( max_length >= $2 )) && print_spacing=$(( max_length - $2 ))
      printf "\033[${placement};9H%s%${print_spacing}s${magenta}%s${reset}" \
        "$1" '' "${3}"
    ;;
    'sub')
      #      50% 08 - track.flac                        [12/345]
      (( max_length >= $2 )) && print_spacing=$(( max_length - $2 ))
      printf "\033[${placement};6H${yellow}%s${reset} %s%${print_spacing}s${magenta}%s${reset}" \
        " 50%" "$1" '' "${3}"
    ;;
    'half')
      #   50% 08 - track.flac                           [12/345]
      (( max_length >= $2 )) && print_spacing=$(( max_length - $2 ))
      printf "\033[${placement};4H${yellow}%s${reset} %s%${print_spacing}s${magenta}%s${reset}" \
        " 50%" "$1" '' "${3}"
    ;;
    'decode')
      #       [decoding->WAV] 08 - track.flac           [12/345]
      (( max_length >= $2 )) && print_spacing=$(( max_length - $2 - 16 ))
      printf "\033[${placement};9H${cyan}[decoding->WAV]${reset} %s%${print_spacing}s${magenta}%s${reset}" \
        "$1" '' "${3}"
    ;;
    'aucdtect_fast')
      #       [auCDtect:fast] 08 - track.flac           [12/345]
      (( max_length >= $2 )) && print_spacing=$(( max_length - $2 - 16 ))
      printf "\033[${placement};9H${cyan}[auCDtect:fast]${reset} %s%${print_spacing}s${magenta}%s${reset}" \
        "$1" '' "${3}"
    ;;
    'aucdtect_slow')
      #       [auCDtect:slow] 08 - track.flac           [12/345]
      (( max_length >= $2 )) && print_spacing=$(( max_length - $2 - 16 ))
      printf "\033[${placement};9H${cyan}[auCDtect:slow]${reset} %s%${print_spacing}s${magenta}%s${reset}" \
        "$1" '' "${3}"
    ;;
    'spectrogram')
      #       [spectral->PNG] 08 - track.flac           [12/345]
      (( max_length >= $2 )) && print_spacing=$(( max_length - $2 - 16 ))
      printf "\033[${placement};9H${cyan}[spectral->PNG]${reset} %s%${print_spacing}s${magenta}%s${reset}" \
        "$1" '' "${3}"
    ;;
  esac
}

#
# Display the result of current item that was operated on
#
# $1 is the file/dir operation result, of which, can be:
#   ok   fail   issue   skip
# $2 is the basename of the file/dir
# $3 is the filename length
# $4 determines whether item is a sub operation or which action is being done
#
_print_status()
{
  # Set up local variables
  declare -i print_spacing='0' column_placement='0'

  case "$1" in
    'ok')     color="${green}"   result='100%'  ;;
    'fail')   color="${red}"     result='fail'  ;;
    'issue')  color="${yellow}"  result='chck'  ;;
    'skip')   color="${yellow}"  result='skip'  ;;
  esac

  #(( max_length >= $3 )) && print_spacing=$(( max_length - $3 ))

  case "$4" in
    'sub')
      column_placement='6'
    ;;
    'decode')
      action="${cyan}[decoding->WAV]${reset} "
      (( max_length >= $3 )) && print_spacing=$(( max_length - $3 - 16 ))
    ;;
    'aucdtect_fast')
      action="${cyan}[auCDtect:fast]${reset} "
      (( max_length >= $3 )) && print_spacing=$(( max_length - $3 - 16 ))
    ;;
    'aucdtect_slow')
      action="${cyan}[auCDtect:slow]${reset} "
      (( max_length >= $3 )) && print_spacing=$(( max_length - $3 - 16 ))
    ;;
    'spectrogram')
      action="${cyan}[spectral->PNG]${reset} "
      (( max_length >= $3 )) && print_spacing=$(( max_length - $3 - 16 ))
    ;;
  esac

#  printf "\033[${placement};${column_placement}H${color}%s${reset} ${action}%s%${print_spacing}s" \
#    "${result}" "$2" ''

  printf "\033[${placement};${column_placement}H${color}%s${reset} ${action}%s%${print_spacing}s\033[${placement};79H\033[0K" \
    "${result}" "$2" ''
}

#
# Display filename and progress bar of the current operation
#
# $1 is one of the following operations:
#   aucdtect                  md5_check           compress_verify
#   compress_no_test          test                replaygain_test
#   replaygain_force_apply    replaygain_apply    retag_analyze
#   retag_apply               extract_images      prune
#   decode                    aucdtect_fast       aucdtect_slow
#   spectrogram
#
# $2 is percent
# $3 is filename to print (may be truncated)
# $4 is filename length
#
_print_progress()
{
  # Set up local variables
  declare  action  progress_bar_length length=$4

  case "$1" in
    'decode')
      action="${cyan}[decoding->WAV]${reset} "
      # max_length - 16: '[decoding -> WAV] ' is 18 characters long
      progress_bar_length=$(( ( ( max_length - 16 ) * $2 ) / 100 ))
    ;;
    'aucdtect_fast')
      action="${cyan}[auCDtect:fast]${reset} "
      # max_length - 16: '[auCDtect - fast] ' is 18 characters long
      progress_bar_length=$(( ( ( max_length - 16 ) * $2 ) / 100 ))
    ;;
    'aucdtect_slow')
      action="${cyan}[auCDtect:slow]${reset} "
      # max_length - 16: '[auCDtect: slow] ' is 16 characters long
      progress_bar_length=$(( ( ( max_length - 16 ) * $2 ) / 100 ))
    ;;
    'spectrogram')
      action="${cyan}[spectral->PNG]${reset} "
      # max_length - 16: '[spectral->PNG] ' is 16 characters long
      progress_bar_length=$(( ( ( max_length - 16 ) * $2 ) / 100 ))
    ;;
    *)
      #progress_bar_length=$(( ( max_length * $2 ) / 100 ))
      progress_bar_length=$(( ( 60 * $2 ) / 100 ))
    ;;
  esac

  if (( progress_bar_length < length )); then
    # Print out the current item name as well as the progress bar
    #--
    # If $progress_bar_length is less than the current item's name length,
    # print out the item's name with the progress bar a part of the name.
    #
    # Otherwise, print out the item's name, and the progress bar after the
    # item's name
    printf "\033[${placement};4H${yellow}%4s${reset} ${action}${invert}%s${reset}" \
      "${2}%" "${3:0:${progress_bar_length}}"
  else
    printf "\033[${placement};4H${yellow}%4s${reset} ${action}${invert}%s%$(( progress_bar_length - length ))s${reset}" \
      "${2}%" "${3}" ''
  fi
}

#
# Kill any children process and display the correct interrupt message when a
# user sends SIGINT during script execution.  Perform any cleanup, and check
# for the existence of a log file before exiting script.
#
# $1 determines which additional cleanup may need to be performed based off of
# operation interrupted, as well as whether the trap is invoked during a
# countdown interruption.  Possible values:
#   aucdtect                  md5_check           compress_verify
#   compress_no_test          test                replaygain_test
#   replaygain_force_apply    replaygain_apply    retag_analyze
#   retag_apply               extract_images      prune
#   countdown
#
_trap_sigint()
{
  # Set up local variables
  declare    finished_items
  declare -a jobs_running=( $(jobs -rp) )  # Store running children processes

  _kill_jobs ${jobs_running[@]}            # Kill running children processes

  for (( i=1; i<=items_processed; i++)); do
    # Clear all the operation lines by moving up each line and clearing it,
    # until we are just below the operation's title message
    #--
    printf "\033[$(( post_row - i))H%${columns}s" ''
  done

  # Update title message, don't update if SIGINT was during a countdown
  if [[ "$1" != 'countdown' ]]; then
    # The number of completely finished (ok) items, minus any items
    # interrupted, minus items with issues
    finished_items="$(( iteration - ${#jobs_running[@]} - $(_num_issues) ))"
    _message "${operation}" "${finished_items}" 'interrupt'
  fi

  # Display extra newline if user invoked SIGINT during a countdown
  [[ "$1" == 'countdown' ]] && printf '\n'

  printf " ${green}*${reset} SIGINT received, generating summary...\n"

  case "${1}" in
    # Remove temporary script-created files
    #--
    'aucdtect'*)   rm -f "${directory}"/**/*_redoflacs_"$$".wav  ;;
    'compress_'*)  rm -f "${directory}"/**/*.tmp,fl-ac+en\'c     ;;
  esac

  # Update status for the current operation, but not if SIGINT was invoked
  # during a countdown
  if [[ "$1" != 'countdown' ]]; then
    _update_operation_status "${1}" 'Operation Interrupted'
  fi

  # Print out log exists to STDERR
  [[ -f "${log_file}" ]] && _message_log_exists "${1}"

  stty ${old_stty} < /dev/stderr  # Restore old stty settings
  printf '\033[?25h'              # Restore the cursor
  rm -f "${job_fifo}"             # Remove temporary FIFO
  rm -f "${tmp_picture_blocks}"   # Remove temporary 'metaflac' block streams
  _summary                        # Display Summary Of Operations

  exit 130
}

#
# Display redoflacs version
#
_print_version() { printf 'Version %s\n' "${version}"; }

#
# Return metaflac version
#
_metaflac_version()
{
  # Metaflacs version (ie: '2' in 1.2.1)
  IFS='.' read -r _ metaflac_version _ < <(metaflac --version)
  printf '%s' "${metaflac_version}"
}

#
# Kill any children process (obtained via $@), hiding errors and suppressing
# the shell's notification of terminated jobs
#
_kill_jobs()
{
  for pid in $@ ; do
    kill ${pid} 2>/dev/null
    wait ${pid} 2>/dev/null
  done
}

#
# Print out the current cursor row position
#
_row()
{
  declare old_stty  row_pos        # Intialize local variables
  exec < /dev/tty                  # Set a new TTY to read in STDIN
  old_stty="$(stty -g)"            # Store current TTY settings
  stty raw -echo min 0             # Current TTY set at an absolute minimum
  printf '\033[6n' > /dev/tty      # Send escape into new TTY

  # Read in escape sequence output from TTY.  The escape sequence looks like:
  #   ^[[<integer>;<integer>R
  #--
  # This is what is read in below:  ^[[<integer>
  IFS=';' read -r -d'R' row_pos _ < /dev/tty

  stty "${old_stty}"               # Restore the old TTY settings
  printf '%s' "${row_pos#??}"      # Return row position (removes: ^[)
}

#
# Scroll the terminal, dependant on the number of jobs to process.  If it's not
# necessary, scrolling may not occur
#
# $1 is the current cursor position in number of rows
#
_scroll_terminal()
{
  # Set up local variables
  declare    lines   remaining_lines   to_scroll
  declare -g columns

  # Redirecting '/dev/stderr' to 'stty' allows valid arguments
  read -r _ _ _ _ lines _ columns _ < <(stty -a < /dev/stderr)

  columns="${columns%;}"   # Terminal width - remove trailing semicolon
  lines="${lines%;}"       # Terminal height - remove trailing semicolon

  if (( ${#total_items[@]} < jobs )); then
    # Determine the remaining lines to the bottom of the terminal screen
    #--
    # If there are less items to process than jobs specified, add the
    # difference of lines to the remaining lines (obtained by the total number
    # of lines in the terminal minus the current row position)
    remaining_lines=$(( lines - $1 + (jobs - ${#total_items[@]}) ))
  else
    remaining_lines=$(( lines - $1 ))
  fi

  if (( jobs > remaining_lines )); then
    # Scroll the terminal if there are more jobs than lines available
    #--
    to_scroll=$(( jobs - remaining_lines ))  # Number of lines to scroll

    # Scroll terminal by printing as many newlines as determined above, plus 1
    for ((i=0 ; i<=to_scroll ; i++)); do
      printf '\n'
    done

    printf "\033[$((to_scroll + 1))A" # Place cursor up ($to_scroll + 1) lines
  fi
}

#
# Return an operation's completion percentage, expressed as an integer
#
# $1 is the operation to choose how to obtain the percentage, which can be:
#   aucdtect                  md5_check           compress_verify
#   compress_no_test          test                replaygain_test
#   replaygain_force_apply    replaygain_apply    retag_analyze
#   retag_apply               extract_images      prune
#   decode
#
# $2 is a (possibly multiline) string of text from a command binary's output
# with a percentage string contained within
#
_get_percent_complete()
{
  # Set up local variables
  declare percent

  case "$1" in
    'compress_'*)
      percent="${2//$'\b'/}"                        # Remove backspaces
      percent="${percent##*: }"                     # complete0, ratio=0.307
      percent="${percent##*complete, ratio=?.???}"  # Percent (integer)
    ;;
    'test')
      percent="${2##* }"                            # Percent (integer)
    ;;
    'decode')
      percent="${2//$'\b'}"                         # Remove backspaces
      percent="${percent##*: }"                     # complete0
      percent="${percent##*complete}"               # Percent (integer)
    ;;
    'aucdtect')
      percent="${2##*[}"                            # Percent (integer)
    ;;
    'spectrogram')
      percent="${2##*In:}"                          # Percent (floating)
      percent="${percent%%.*}"                      # Percent (integer)
    ;;
  esac

  # Default to '0' if percentage is not an integer
  if [[ "${percent}" =~ ^[[:digit:]]+$ ]]; then
    printf '%d' $percent
  else
    printf '%d' '0'
  fi
}

#
# Force the creation of a new configuration file
#
_new_config()
{
  # Check if configuration file exists based of ${EUID}.  If it doesn't
  # exist, create one
  if (( EUID == 0 )); then
    # User is root
    #--
    # Configuration file location
    config_file='/etc/redoflacs.conf'

    # If there already is a configuration file, do not overwrite it
    if [[ -f "${config_file}" ]]; then
      config_file="/etc/_$$.redoflacs.conf"
    fi
  else
    # User is _NOT_ root
    #--
    # Configuration file location
    config_file="${HOME}/.config/redoflacs/config"

    # If there already is a configuration file, do not overwrite it
    if [[ -f "${config_file}" ]]; then
      config_file="${HOME}/.config/redoflacs/_$$.config"
    fi
  fi

  # Creates the (new) configuration file
  _create_config

  # Explain to user where to find the new configuration file
  _info 'A new configuration file has been created here:\n'
  _info "${cyan}${config_file}${reset}\n\n"

  _info "It's recommended to review the new configuration file\n"
  _info 'and transfer over any changes you made in your old\n'
  _info 'configuration file.\n\n'

  _info 'After making the changes (if any), rename the new\n'
  _info 'configuration file to your old configuration file\n'
  _info 'name.  Here is the command you could use:\n'

  if (( EUID == 0 )); then
    _info "${cyan}mv${reset} ${cyan}${config_file}${reset} ${cyan}/etc/redoflacs.conf${reset}\n"
  else
    _info "${cyan}mv${reset} ${cyan}${config_file}${reset} ${cyan}${HOME}/.config/redoflacs/config${reset}\n"
  fi
}

#
# Create a configuration file
#
_create_config()
{
  # Set up local array
  declare -a config

  # Don't expand variables when using heredoc
  mapfile -n0 -t config << "END_OF_CONFIG"
#
# redoflacs configuration
#
# Any line that is _NOT_ prepended with a '#' will be interpreted as an option
# (except for blank lines -- these are not interpreted)
#
# See redoflacs(1) for a detailed description of each parameter
#
# NOTE: The options listed below are shell syntax.  Interpolation can occur
# should weak (double) quotes be used.
#
#------------------------------------------------------------------------------
# TAGGING SECTION
#------------------------------------------------------------------------------
#
# List the tags to be kept in each FLAC file.  The default is listed below.
#
# Another common tag not added by default is ALBUMARTIST.  Uncomment
# ALBUMARTIST below to allow script to keep this tag.
#
# NOTE: Whitespace _IS_ allowed for the these tag fields, ie:
#   ALBUM ARTIST
#   CATALOG NUMBER ISBN
#
TITLE
ARTIST
#ALBUMARTIST
ALBUM
DISCNUMBER
DATE
TRACKNUMBER
TRACKTOTAL
GENRE

# The COMPRESSION tag is a custom tag to allow the script to determine which
# level of compression the FLAC file(s) has/have been compressed at.
COMPRESSION

# The RELEASETYPE tag is a custom tag the author of this script uses to
# catalog what kind of release the album is (ie, Full Length, EP, Demo, etc.).
RELEASETYPE

# The SOURCE tag is a custom tag the author of this script uses to catalog
# which source the album has derived from (ie, CD, Vinyl, Digital, etc.).
SOURCE

# The MASTERING tag is a custom tag the author of this script uses to catalog
# how the album has been mastered (ie, Lossless, or Lossy).
MASTERING

# The REPLAYGAIN tags below, are added by the '-g, --replaygain' or
'-G, --replaygain-noforce' argument.  If you want to keep the ReplayGain tags,
# make sure you leave these here.
REPLAYGAIN_REFERENCE_LOUDNESS
REPLAYGAIN_TRACK_GAIN
REPLAYGAIN_TRACK_PEAK
REPLAYGAIN_ALBUM_GAIN
REPLAYGAIN_ALBUM_PEAK

#------------------------------------------------------------------------------
# OPTIONS
#------------------------------------------------------------------------------
#
# REMOVE ARTWORK:
#
# Set whether to remove embedded artwork within FLAC files.  By default, this
# script will remove any artwork it can find in the PICTURE block of a FLAC
# file.  Set 'remove_artwork' as 'true' to remove embedded artwork.  All other
# values are intepreted as 'false'.
remove_artwork='true'

#
# SET COMPRESSION:
#
# Set the type of COMPRESSION strength when compressing the FLAC files.
# Numbers range from '1-8', with '1' being the lowest compression and '8' being
# the highest compression.  The default is '8'.
compression_level='8'

#
# ERROR LOG DIRECTORY:
#
# Set where you want error logs to be placed.  By default, they are stored in
# the user's HOME directory.
error_log="${HOME}"

#
# AUCDTECT SKIP LOSSY:
#
# Set whether FLAC files should be skipped if the MASTERING tag is already set
# as 'Lossy' when analyzed with auCDtect.  Set 'skip_lossy' as 'true' to to
# skip FLAC files that have the tag: 'MASTERING=Lossy'.  All other values are
# intepreted as 'false'.
skip_lossy='true'

#
# SPECTROGRAM DIRECTORY:
#
# Set where created spectrogram images should be stored.  By default, they are
# stored in the same directory as the analyzed FLAC files.  Each image will
# have the same name as the tested FLAC file but with an integer suffix
# indicating the FLAC number (which was processed by the script) to allow for
# uniqueness.  The type of image created is PNG with the extension '.png'.
#
# All values for 'spectrogram_location' are interpreted as a directory.  If
# left blank, the default location will be used.
#
# An example of a user-defined location:
#    spectrogram_location="${HOME}/Spectrogram_Images"
#
# See redoflacs(1) for more information.
spectrogram_location=''

#
# EXTRACTED ARTWORK DIRECTORY:
#
# Set where the extracted artwork images should be stored.
#
# By  default, each extracted image will be placed in a subdirectory where the
# FLAC file is located.  The subdirectory housing the extracted artwork will
# have a similar name as the currently processed FLAC.  If a directory already
# exists, an integer is appended to the directory (to prevent overwriting and
# mixing files).  For example:
#
#    /path/to/01_file.flac          # FLAC file with embedded artwork
#    /path/to/01_file.flac_art/     # Directory housing artwork
#    /path/to/01_file.flac_art~1~/  # Directory '1' if above directory exists
#    /path/to/01_file.flac_art~2~/  # Directory '2' if above directory exists
#    /path/to/01_file.flac_art~N~/  # Directory 'N' if above directory exists
#
# All values for 'artwork_location' are interpreted as a directory.  If left
# blank, the default location will be used.
#
# If there is a user-defined location, the extracted images will be placed in a
# subdirectory in that location with a naming scheme similar to above:
#
#    artwork_location="${HOME}/artwork"    # User-defined configuration option
#
#    /path/to/01_file.flac                 # FLAC file with embedded artwork
#    ${HOME}/artwork/01_file.flac_art/     # Directory housing artwork
#    ${HOME}/artwork/01_file.flac_art~1~/  # If above directory exists
#
# See redoflacs(1) for more information.
artwork_location=''

#
# PREPEND TRACK NUMBER:
#
# Change whether the '-r, --retag' operation will re-tag singular track numbers
# and track totals from:
#    1, 2, 3, 4, 5, 6, 7, 8, 9
# to
#    01, 02, 03, 04, 05, 06, 07, 08, 09
#
# For example, if you had:
#    TRACKNUMBER=4
#     TRACKTOTAL=9
#
# You would end up with:
#    TRACKNUMBER=04
#     TRACKTOTAL=09
#
# This is enabled by setting 'prepend_zero' option as 'true'.  All other values
# are interpreted as 'false'.
prepend_zero='false'

#
# PRESERVE FILE MODIFICATION TIME:
#
# This is enabled by setting 'preserve_modtime' option as 'true'.  All other
# values are interpreted as 'false'
preserve_modtime='false'

# Version:4
END_OF_CONFIG

  # Write out configuration to either system-wide or local location
  printf '%s\n' "${config[@]}" > "${config_file}"
}

#
# Parse the user/system configuration file
#
# Load the config file into an array and process each line, grabbing the user-
# specified FLAC tags and setting up the configuration variables
#
_parse_config()
{
  # Set up local variables
  declare  config_option

  while read -r line; do
    # Run through the config file, evaluating the configuration option into the
    # current enviroment and storing the tag fields into an array
    #--
    # Test and use only the tag and config options
    if [[ -n "${line###*}" && -n "${line}" ]]; then
      config_option="${line//*=*/}"  # Null if line is a config option

      if [[ -n "${config_option}" ]]; then
        tags+=( "${line^^}" )       # Store uppercase tag in array
      else
        eval "${line}"              # Put config option in environment
      fi
    fi
  done < "${config_file}"

  if [[ "${preserve_modtime}" == 'true' ]]; then
    metaflac_extra_options="--preserve-modtime"
  fi
}

#
# Check current configuration, if the version in the script is newer warn user
# and display a countdown before starting script
#
_check_config_version()
{
  # Set up local variables/arrays
  declare    config_file  config_last_line  revision
  declare -a config_array

  # Check if configuration file exists based of ${EUID}.  If it doesn't
  # exist, create one
  if (( EUID == 0 )); then
    # User is root
    #--
    # Configuration file location
    config_file='/etc/redoflacs.conf'
  else
    # User is _NOT_ root
    #--
    # Configuration file location
    config_file="${HOME}/.config/redoflacs/config"
  fi

  # Load configuration file into an array
  mapfile -n0 -t config_array < "${config_file}"

  # Obtain only the last line of the config
  config_last_line="${config_array[@]: -1}"

  # Extract the revision number from the configuration file (new syntax format as
  # of redoflacs 0.30):
  IFS=':' read -r _ revision <<< "$config_last_line"

  # Check if ${revision} is an integer.  If not, display countdown and warn user
  # of new configuration file, else test if the user config revision is less than
  # the script config revision
  if [[ "${revision}" =~ ^[[:digit:]]+$ ]]; then
    if (( script_revision > revision )); then
      _countdown_config; printf '\n\n'
    fi
  else
    _countdown_config; printf '\n\n'
  fi
}

#
# Truncate the processed item's filename if it's bigger than terminal width,
# returning the filename (possibly truncated) as well as the length of the
# filename (in characters, possibly truncated)
#
# $1 is the filename to truncate/process
# $2 determines whether this is a multi-stage operation (eg, auCDtect)
#
_truncate_filename()
{
  unit_separator=$'\037'                 # ASCII unit separator

  # Set up local variables
  declare    filename="$1"  length_diff
  declare -i apparent_length  length
  declare filename_length

  # Make absolute pathname
  [[ "${filename}" == '.' || "${filename}" == './' ]] && filename="${PWD}"

  # Basename of file/directory
  if [[ "${filename: -1}" == '/' ]]; then         # Last character is a '/'
    filename="${filename%?}"                     # Remove last character
    filename="${filename##*/}/"                  # Basename of directory, append '/'
  else
    filename="${filename##*/}"                   # Basename of file
  fi

  filename="${filename//$'\n'/?}"                 # Replace '\n' with '?'

##   # Apparent (column-wdith) length of filename; 'wc' handles wide characters
##   filename_length="$(wc -L <<< "${filename}")"

  #printf >&2 "${smcup}\033[${iteration};0H%s" "$filename"
  #IFS=';' read -rs -dR -u2 -t1 -p "${curpos}${rmcup}" _ filename_length

  #{
  #  #IFS=';' read -rs -dR -u2 -t1 -p "${smcup}${filename}${curpos}${rmcup}" _ filename_length
  #} >/dev/null
  #printf >&2 -- '--\n'
  #printf >&2 "filename:        $filename\n"
  #printf >&2 "filename_length: $filename_length\n"
  #printf >&2 -- '--\n'
  printf >&2 "%s\n" "$filename_length"
  ((filename_length--))

  # Subtract 16 blocks from $max_length if we're doing a multi-stage operation
  [[ "${2}" == 'multi-stage' ]] && max_length=$((max_length - 16))

  # If filename is longer than the width allowed in the terminal, truncate it
  if (( filename_length > max_length )); then
    max_length=$((max_length - 4))        # Leave room for space and ellipsis
    apparent_length="${filename_length}"  # Apparent length of item
    length="${max_length}"                # Length in ${foo:offset:length}

    # Use fast ${foo:offset:length} truncate item if the apparent length
    # equals the number of characters using ${#foo}.  Otherwise, use 'wc' to
    # grab apparent length (slower).  The slow method is only used for wide
    # characters
    #--
    if (( ${#filename} == filename_length )); then
      # eg, 'longfilename' -> 'longfilen...'
      filename="${filename:0:${max_length}}..."
      filename_length="${#filename}"
    else
      until (( apparent_length <= max_length )); do
        # Keep slicing off a character from the current item, until it's length
        # is less than or equal to the maximum length allowed.  Wide characters
        # may never truncate equal to $max_length, but may be less than it
        #--
        ((--length))
        apparent_length="$(wc -L <<< "${filename:0:${length}}")"
      done

      # Difference between lengths, represented as spaces
      printf -v length_diff "%$(( max_length - apparent_length ))s" ''

      # eg, 'longfilename' -> 'longfilen ...'
      filename="${filename:0:${length}}${length_diff}..."

      # Apparent length of truncated filename
      filename_length="$(wc -L <<< "${filename}")"
    fi
  fi


  # Return (truncated) filename and (truncated) filename length
  printf "%s${unit_separator}%d" "${filename}" "${filename_length}"
}

#
# Determine number of jobs to run via the number CPUs/cores available
#
_find_cores()
{
  # Set up global variable
  declare -gi jobs='2'                  # By default, set $jobs to '2'
  declare -g  jobs_display='(Default)'  # Default $jobs determination

  # 'nproc' is part of GNU coreutils
  if type -P nproc >/dev/null; then
    jobs="$(nproc)"         # Store useable 'online' CPU's
    jobs_display='(nproc)'  # $jobs dynamically determined
    return 0
  fi

  # Fallback to /proc/cpuinfo.  Check /proc/cpuinfo if /proc is mounted by
  # comparing device numbers to /
  if (( $(stat -c %d '/proc') != $(stat -c %d '/') )); then
    if [[ -f '/proc/cpuinfo' ]]; then
      jobs='0'  # Initialize to zero

      # /proc/cpuinfo exists, find total number of cores to use by countine the
      # number of processor entries are in /proc/cpuinfo
      while read -r i; do
        [[ "${i}" == 'processor'*:' '* ]] && ((jobs++))
      done < /proc/cpuinfo

      jobs_display='(/proc/cpuinfo)'  # $jobs dynamically determined
    fi
  fi
}

#
# Find all the artwork blocks in a given FLAC file, storing each instance into
# an array, to be returned as $artwork[@]
#
_find_artwork()
{
  # Set up local variables/array
  declare -a artwork_blocks
  declare tmp_picture_blocks="/tmp/redoflacs_block_stream_${BASHPID}"

  # Grab all the PICTURE blocks from current FLAC file, storing into an array
  #--
  # It's much faster to read in from a temporary file than via process
  # substitution
  metaflac --list --block-type=PICTURE "${1}" > "${tmp_picture_blocks}"

  # Continue if there were any PICTURE blocks found in current FLAC
  if [[ -s "${tmp_picture_blocks}" ]]; then
    # Only read in the lines we care about and store into array
    while read -r; do
      # We only care about the block, picture and MIME type lines
      [[ "${REPLY}" == 'METADATA'* || "${REPLY}" == '  '[tM]* ]] && artwork_blocks+=( "${REPLY}" )
    done < "${tmp_picture_blocks}"

    # Run through each line obtained and parse out the information wanted
    #--
    # $artwork_blocks[@] looks something like this:
    #   'METADATA block #2'
    #   '  type: 6 (PICTURE)'
    #   '  type: 5 (Leaflet page)'
    #   '  MIME type: image/jpeg'
    #   'METADATA block #3'
    #   '  type: 6 (PICTURE)'
    #   '  type: 6 (Media (e.g. label side of CD))'
    #   '  MIME type: image/jpeg'
    #   'METADATA block #4'
    #   '  type: 6 (PICTURE)'
    #   '  type: 7 (Lead artist/lead performer/soloist)'
    #   '  MIME type: image/jpg'
    #--
    for i in "${!artwork_blocks[@]}"; do
      if [[ "${artwork_blocks[$i]}" == 'METADATA'* ]]; then
        block_id="${artwork_blocks[$i]##* #}"  # METADATA block #4 -> 4

        # type: 8 (Artist/Performer) -> art_id='8', art_desc='(Artist-Performer)'
        read -r _ art_id art_desc <<< "${artwork_blocks[$((i + 2))]//\//-}"

        # MIME type: image/jpeg -> 'jpg'
        IFS='/' read -r _ art_ext <<< "${artwork_blocks[$((i + 3))]/jpeg/jpg}"

        # Store artwork information into array as a single index
        artwork+=( "${block_id}:${art_id} ${art_desc}.${art_ext}" )
      fi
    done
  fi

  rm -f "${tmp_picture_blocks}"  # Remove temporary 'metaflac' block streams
}

#
# Top banner displaying invocation settings
#
_top_banner()
{
  read -r _ flac_version < <(flac --version)                # Flac Version

  printf " ${blue}%s${reset}\n" \
    '---------------------------------------------------'  # Top title line

  printf '%16sRuntime Information\n'                        # Title

  printf " ${blue}%s${reset}\n" \
    '-------------------------+-------------------------'  # Bottom title line

  printf "                redoflacs ${blue}|${reset} ${cyan}%s${reset}\n" \
    "${version}"                                           # Script version

  printf "                     FLAC ${blue}|${reset} ${cyan}%s${reset}\n" \
    "${flac_version}"                                      # Flac version

  printf "                     Jobs ${blue}|${reset} ${cyan}%s %s${reset}\n" \
    "${jobs}" "${jobs_display}"                            # Number of jobs

  printf "            Log Directory ${blue}|${reset} ${cyan}%s${reset}\n" \
    "${error_log}/"                                        # Log directory

  # Set configuration directory
  if (( EUID == 0 )) ; then
    config_directory='/etc/'                               # System config
  else
    config_directory='~/.config/redoflacs/'                # User config
  fi

  printf "         Config Directory ${blue}|${reset} ${cyan}%s${reset}\n" \
    "${config_directory}"                                  # Config directory

  printf " ${blue}%s${reset}\n" \
    '-------------------------+-------------------------'  # End banner line

  _info 'Finding FLAC files to process...'                  # Show FLAC search
}

#
# Display countdown before retagging to allow user to quit script safely
#
_countdown_metadata()
{
  trap '_trap_sigint countdown' SIGINT  # Trap SIGINT to abort cleanly

  # Warning message
  _error "${yellow}CAUTION!${reset} These are the tag fields that will be kept\n"
  _error 'when re-tagging the selected files:\n'

  # Creates the listing of tags to be kept
  printf '     %s\n' "${tags[@]}" >&2

  # Warning message about embedded coverart
  _error "By default, this script will ${cyan}REMOVE${reset} the legacy ${cyan}COVERART${reset} tag.\n"
  _error "Add the ${cyan}COVERART${reset} tag to the list of tags to be kept in the\n"
  _error "${cyan}TAGGING SECTION${reset} of the configuration file.\n\n"

  _error "Keep in mind, if the ${cyan}remove_artwork${reset} option is set to ${cyan}false${reset},\n"
  _error "embedded artwork in the ${cyan}PICTURE${reset} block will be kept when using\n"
  _error "the ${cyan}-p, --prune${reset} option as well.\n\n"

  _warn "Waiting ${red}10${reset} seconds before starting program...\n"
  _warn 'Ctrl+C (Control-C) to abort...\n'
  _info 'Starting in: '

  # 10 second countdown
  for count in {10..1}; do
    printf "${red}%d ${reset}" "$count"
    read -t1  # Sleep 1
  done

  printf '\n'  # Advance countdown to next line
}

#
# Displays countdown if a newer config is found to allow user to quit safely
#
_countdown_config()
{
  trap '_trap_sigint countdown' SIGINT  # Trap SIGINT to abort cleanly

  # Warning message
  _info 'There is a newer configuration file available!\n\n'

  _warn 'It is recommended you generate a new configuration\n'
  _warn 'file for use with this program.\n\n'

  _warn 'To generate a new configuration file, run:\n'
  _warn "${cyan}redoflacs --new-config${reset}\n\n"

  _warn 'The above command will _NOT_ overwrite your\n'
  _warn 'current configuration file.\n\n'

  _warn 'Waiting 10 seconds before starting program...\n'
  _warn 'Ctrl+C (Control-C) to abort...\n'
  _info 'Starting in: '

  # 10 second countdown
  for count in {10..1}; do
    printf "${red}%s ${reset}" "$count"
    read -t1  # Sleep 1
  done
}

#
# Return a listing of the total base directories housing all the found FLACs
#
_get_directory_list()
{
  declare     previous_dir  current_dir  # Set up local variable(s)
  declare -ga total_dirs                 # Set up global array

  for flac in "$@"; do
    # Run through total FLAC files array, printing out each unique directory
    #--
    current_dir="${flac%/*}"
    if [[ "${previous_dir}" != "${current_dir}" ]]; then
      total_dirs+=( "${current_dir}/" )
    fi
    previous_dir="${current_dir}"       # Set current directory to previous
  done
}

#
# Clear job manager file descriptor (tied to FIFO) by closing and reopening
#
# $1 is the FIFO to tie the file descriptor to
#
_clear_jobs_fd()
{
  exec 3<&- 3>&-  # Close file descriptor
  rm -f "$1"      # Remove FIFO if it exists
  mkfifo "$1"     # Create FIFO
  exec 3<>"$1"    # Open file descriptor read/write
}

#
# Return an integer detailing the number of issues an operation may have had,
# returning '0', if no issues were found
#
_num_issues()
{
  declare ticks  # Set up local variable

  # Read in number of issue ticks, hiding missing file output
  { read -r ticks < "${issue_ticks}"; } 2>/dev/null
  printf '%d' "${#ticks}"  # Return number of ticks (0, if empty)
}

#
# Obtain and process the positional parameters invoked with the script
#
_process_positional_parameters()
{
  # Set up global variables
  declare -g all  reallyall  create_spectrogram  no_extra_tags  no_color \
    directory

  # Set up local variables/arrays
  declare -a args  long_args  short_args  non_args  converted_args
  declare    regex

  # If no arguments are made to the script show usage and help
  if (( ${#} == 0 )); then
    _help
    exit 1
  fi

  # If only one argument was called
  if (( ${#} == 1 )); then
    case "$1" in
      '--help'|'-h')        _help          ; exit 0 ;;
      '--version'|'-v')     _print_version ; exit 0 ;;
      '--new-config'|'-o')  _new_config    ; exit 0 ;;
      *)                    _usage         ; exit 1 ;;
    esac
  fi

  # If only two arguments were called
  if (( ${#} == 2 )); then
    case "$1" in
      # The number of jobs cannot be specified without an operation
      '--jobs='[[:digit:]]*' '|'-j'[[:digit:]]*' ')
        _usage
        _error "${cyan}${1}${reset} cannot used without an operation specified.\n"
        exit 1
      ;;
    esac
  fi

  for i in "${@}"; do
    # Separate long, short, and non arguments into separate arrays to be
    # converted into short arguments for 'getopts' to process correctly
    #--
    case "$i" in
      '--'*) long_args+=( "${i}" )   ;;
      '-'*)  short_args+=( "${i}" )  ;;
      *)     non_args+=( "${i}" )    ;;
    esac
  done

  # If there isn't a single non-argument (directory), exit
  if (( ${#non_args[@]} != 1 )); then
    _usage
    exit 1
  fi

  # Long arguments
  #--
  # If any were called, convert long arguments to short, allowing 'getopts' to
  # process them
  #--
  if [[ -n "${long_args[@]}" ]]; then
    for i in "${long_args[@]}"; do
      case "$i" in
        # These arguments are to be called by themselves, so quit
        '--version')              _usage; exit 1          ;;
        '--help')                 _usage; exit 1          ;;
        '--new-config')           _usage; exit 1          ;;

        # Send long arguments to array to process later
        '--aucdtect')             converted_args+=( -a )  ;;
        '--aucdtect-spectrogram') converted_args+=( -A )  ;;
        '--md5check')             converted_args+=( -m )  ;;
        '--compress')             converted_args+=( -c )  ;;
        '--compress-notest')      converted_args+=( -C )  ;;
        '--test')                 converted_args+=( -t )  ;;
        '--replaygain')           converted_args+=( -g )  ;;
        '--replaygain-noforce')   converted_args+=( -G )  ;;
        '--retag')                converted_args+=( -r )  ;;
        '--extract-artwork')      converted_args+=( -e )  ;;
        '--prune')                converted_args+=( -p )  ;;
        '--all')                  converted_args+=( -l )  ;;
        '--reallyall')            converted_args+=( -L )  ;;
        '--no-color')             converted_args+=( -n )  ;;
        '--no-extra-tags')        converted_args+=( -x )  ;;

        '--jobs='*)
          # Enforce we have only digits after '--jobs=', and if so, set the
          # number of $jobs to its value, otherwise exit with a warning
          #--
          regex="[[:digit:]]+$"  # Regular expression
          if [[ "${i##*=}" =~ $regex ]] && (( ${i##*=} != 0 )); then
            jobs="${i##*=}"  # --jobs=11 -> 11
          else
            _usage
            _error "${cyan}--jobs${reset} requires a non-zero integer after it (eg. ${cyan}--jobs=11${reset}).\n"
            exit 1
          fi
        ;;

        # All other arguments are invalid
        *)  invalid_args+=( "${i}" )  ;;
      esac
    done
  fi

  # Short arguments
  #--
  # If any were called, add valid short arguments (using 'getopts') to the same
  # array as long arguments
  #--
  if [[ -n "${short_args[@]}" ]]; then
    while getopts ":j:LlcCtgGaAmeprnxhvo" args "${short_args[@]}"; do
      case "${args}" in
        # These arguments are to be called by themselves, so quit
        'v') _usage; exit 1          ;;
        'h') _usage; exit 1          ;;
        'o') _usage; exit 1          ;;

        # Send short arguments to array to process later
        'L') converted_args+=( -L )  ;;
        'a') converted_args+=( -a )  ;;
        'A') converted_args+=( -A )  ;;
        'm') converted_args+=( -m )  ;;
        'c') converted_args+=( -c )  ;;
        'C') converted_args+=( -C )  ;;
        't') converted_args+=( -t )  ;;
        'g') converted_args+=( -g )  ;;
        'G') converted_args+=( -G )  ;;
        'r') converted_args+=( -r )  ;;
        'e') converted_args+=( -e )  ;;
        'p') converted_args+=( -p )  ;;
        'l') converted_args+=( -l )  ;;
        'n') converted_args+=( -n )  ;;
        'x') converted_args+=( -x )  ;;

        'j')
          # Enforce we have only digits after '-j', and if so, set the
          # number of $jobs to its value, otherwise exit with a warning
          #--
          regex="[[:digit:]]+$"  # Regular expression
          if [[ "${OPTARG}" =~ $regex ]] && (( OPTARG != 0 )); then
            jobs="${OPTARG}"  # OPTARG is the argument after 'j' (j:)
          else
            _usage
            _error "${cyan}-j${reset} requires a non-zero integer after it (eg. ${cyan}-j11${reset}).\n"
            exit 1
          fi
        ;;
        ?)
          # Set invalid argument from getopts into array using
          # ${OPTARG}
          invalid_args+=( "-${OPTARG}" )
        ;;
      esac
    done
  fi

  # Display invalid arguments, if any
  if [[ -n "${invalid_args[@]}" ]]; then
    _usage
    _error 'Invalid option(s): '
    printf "${cyan}%s${reset}\n" "${invalid_args[*]}" >&2
    exit 1
  fi

  # Process converted arguments, setting each operation to run into an array
  #--
  # Run through the catchall arugments first
  for i in "${converted_args[@]}"; do
    case "${i}" in
      # These are the meta-arguments (do multiple operations)
      '-l')
        all='true'
        operations[1]='md5_check'
        operations[2]='compress_verify'
        operations[5]='replaygain_test'
        operations[6]='replaygain_force_apply'
        operations[7]='retag_analyze'
        operations[8]='retag_apply'
        operations[10]='prune'
      ;;
      '-L')
        reallyall='true'
        create_spectrogram='true'
        operations[0]='aucdtect'
        operations[1]='md5_check'
        operations[2]='compress_verify'
        operations[5]='replaygain_test'
        operations[6]='replaygain_force_apply'
        operations[7]='retag_analyze'
        operations[8]='retag_apply'
        operations[9]='extract_images'
        operations[10]='prune'
      ;;
    esac
  done

  # Run through the individual operations
  for i in "${converted_args[@]}"; do
    case "${i}" in
      # Process individual arguments
      '-a')
        if [[ "${create_spectrogram}" == 'true' || "${operations[0]}" == 'conflict' ]]; then
          operations[0]='conflict'  # If already set
        else
          operations[0]='aucdtect'
        fi
      ;;
      '-A')
        if [[ -n "${operations[0]}" && -z "${create_spectrogram}" ]] || [[ "${operations[0]}" == 'conflict' ]]; then
          operations[0]='conflict'  # If already set
        else
          create_spectrogram='true'
          operations[0]='aucdtect'
        fi
      ;;
      '-m') operations[1]='md5_check'         ;;
      '-c') operations[2]='compress_verify'   ;;
      '-C') operations[3]='compress_no_test'  ;;
      '-t') operations[4]='test'              ;;
      '-g')
        if [[ "${operations[6]}" == 'replaygain_apply' || "${operations[6]}" == 'conflict' ]]; then
          operations[6]='conflict'   # If already set
        else
          operations[5]='replaygain_test'
          operations[6]='replaygain_force_apply'
        fi
      ;;
      '-G')
        if [[ "${operations[6]}" == 'replaygain_force_apply' || "${operations[6]}" == 'conflict' ]]; then
          operations[6]='conflict'   # If already set
        else
          operations[5]='replaygain_test'
          operations[6]='replaygain_apply'
        fi
      ;;
      '-r')
        operations[7]='retag_analyze'
        operations[8]='retag_apply'
      ;;
      '-e')
        operations[9]='extract_images'
      ;;
      '-p') operations[10]='prune'            ;;
      '-n') no_color='true'                   ;;
      '-x') no_extra_tags='true'              ;;
    esac
  done

  args=( "${@}" )  # Store arguments into an array to process

  # Obtain the last element in $args[@], which is the directory to process
  #--
  # BASH 4.2 allows negative indices:
  #   directory="${args[-1]%/}"
  directory="${args[$(( ${#args[@]} - 1 ))]%/}"  # Remove ending slash (if any)
}

#
# Check for missing programs vital to this script
#
_check_missing_programs()
{
  # Set up local variables/arrays
  declare -a missing_commands

  # Add each command that's needed to an array to be displayed
  if ! type -P rm >/dev/null; then
    missing_commands+=( "   Missing ${cyan}rm${reset}        ->  Part of ${cyan}coreutils${reset}" )
  fi
  if ! type -P stty >/dev/null; then
    missing_commands+=( "   Missing ${cyan}stty${reset}      ->  Part of ${cyan}coreutils${reset}" )
  fi
  if ! type -P stat >/dev/null; then
    missing_commands+=( "   Missing ${cyan}stat${reset}      ->  Part of ${cyan}coreutils${reset}" )
  fi
  if ! type -P mkdir >/dev/null; then
    missing_commands+=( "   Missing ${cyan}mkdir${reset}     ->  Part of ${cyan}coreutils${reset}" )
  fi
  if ! type -P mkfifo >/dev/null; then
    missing_commands+=( "   Missing ${cyan}mkfifo${reset}    ->  Part of ${cyan}coreutils${reset}" )
  fi
  if ! type -P wc >/dev/null; then
    missing_commands+=( "   Missing ${cyan}wc${reset}        ->  Part of ${cyan}coreutils${reset}" )
  fi
  if ! type -P metaflac >/dev/null; then
    missing_commands+=( "   Missing ${cyan}metaflac${reset}  ->  Part of ${cyan}flac${reset}" )
  fi
  if ! type -P flac >/dev/null; then
    missing_commands+=( "   Missing ${cyan}flac${reset}      ->  Part of ${cyan}flac${reset}" )
  fi

  if [[ -n "${missing_commands[@]}" ]]; then
    # Display message that system is missing vital programs
    #--
    _error 'You seem to be missing one or more necessary programs\n'
    _error 'to run this script reliably.  Below shows the program(s)\n'
    _error 'missing, as well as where you can install them from:\n'
    for i in "${missing_commands[@]}"; do
      _warn "${i}\n"
    done
    exit 1
  fi

  # Optional binaries
  #--
  # Check for auCDtect if operation was called
  if [[ "${operations[0]}" == 'aucdtect' ]]; then
    if aucdtect="$(type -P auCDtect)"; then
      _aucdtect_cmd() { "${aucdtect}" "$@"; }  # Normal typeface
    elif aucdtect="$(type -P aucdtect)"; then
      _aucdtect_cmd() { "${aucdtect}" "$@"; }  # Alternate spelling
    else
      # auCDtect/aucdtect cannot be found
      _error "It appears ${cyan}auCDtect${reset} is not installed. Please verify you\n"
      _error "have this program installed and can be found in ${cyan}\$PATH${reset}\n"
      exit 1
    fi

    # Make sure auCDtect is executable
    if [[ ! -x "${aucdtect}" ]]; then
      _error "It appears ${cyan}auCDtect${reset} is not executable.  In order to make\n"
      _error "${cyan}auCDtect${reset} executable, run:\n"
      _error "${cyan}chmod u+x '${aucdtect}'${reset}\n"
      exit 1
    fi
  fi

  # Check for SoX if auCDtect spectrograms were called
  if [[ "${create_spectrogram}" == 'true' ]]; then
    if sox="$(type -P sox)"; then
      _sox_cmd() { "${sox}" "$@"; }
    else
      # SoX cannot be found
      _error "It appears ${cyan}SoX${reset} is not installed. Please verify you\n"
      _error "have this program installed and can be found in ${cyan}\$PATH${reset}\n"
      exit 1
    fi
  fi
}

#
# Check for any conflicting operations/arguments
#
_check_conflicting_operations()
{
  # '-l, --all' and '-L, --reallyall' cannot be called together
  if [[ "${all}" == 'true' && "${reallyall}" == 'true' ]]; then
    _error "Running both ${cyan}-l, --all${reset} and ${cyan}-L, --reallyall${reset} conflict!\n\n"

    _error 'Please choose one or the other.\n'
    exit 1
  fi

  # Store conflicting arguments if '-l, --all' or '-L, --reallyall' was called
  if [[ "${all}" == 'true' || "${reallyall}" == 'true' ]]; then
    # _compress_no_test()
    [[ -n "${operations[3]}" ]] && conflicting_args+=( '-C, --compress_notest' )

    case "${operations[6]}" in
      # _replaygain_apply()
      'replaygain_apply')
        conflicting_args+=( '-G, --replaygain-noforce' )
      ;;
    esac

    # Display conflicting arguments and exit, if there were any
    if [[ -n "${conflicting_args[@]}" ]]; then
      # '-l, --all'
      if [[ "${all}" == 'true' ]]; then
        _error "The below options conflict with ${cyan}-l, --all${reset}:\n"
      # '-L, --reallyall'
      elif [[ "${reallyall}" == 'true' ]]; then
        _error "The below options conflict with ${cyan}-L, --reallyall${reset}:\n"
      fi

      # Print each conflicting argument
      for i in "${conflicting_args[@]}"; do
        _error "  ${cyan}${i}${reset}\n"
      done

      _error '\nPlease remove incompatible options.\n'
      exit 1
    fi
  fi

  # _compress_verify() and _compress_no_test()
  if [[ -n "${operations[2]}" && -n "${operations[3]}" ]]; then
    _error "Running both ${cyan}-c, --compress${reset} and ${cyan}-C, --compress-notest${reset} conflict!\n\n"

    _error 'Please choose one or the other.\n'
    exit 1
  fi

  # _compress_no_test() and '-x, --no-extra-tags'
  if [[ -n "${operations[3]}" && "${no_extra_tags}" == 'true' ]]; then
    _error "Running both ${cyan}-C, --compress-notest${reset} and ${cyan}-x, --no_extra_tags${reset} conflict!\n\n"

    _error "${cyan}-x, --no_extra_tags${reset} invalidates the compression check, since each file\n"
    _error "seen to be missing the ${cyan}COMPRESSION${reset} tag is compressed, after which, the\n"
    _error "${cyan}COMPRESSION${reset} tag is NOT applied, leaving future executions to repeat this process.\n\n"

    _error 'Please choose one or the other.\n'
    exit 1
  fi

  # _compress_verify() and _test()
  if [[ -n "${operations[2]}" && -n "${operations[4]}" ]]; then
    _error "Running both ${cyan}-c, --compress${reset} and ${cyan}-t, --test${reset} conflict!\n\n"

    _error 'Please choose one or the other.\n'
    exit 1
  fi

  # _replaygain_force_apply and _replaygain_apply
  # 'conflict' is set during parameter handling if conflicts will ocurr
  if [[ "${operations[6]}" == 'conflict' ]]; then
    _error "Running both ${cyan}-g, --replaygain${reset} and ${cyan}-G, --replaygain-noforce${reset} conflict!\n\n"

    _error 'Please choose one or the other.\n'
    exit 1
  fi

  # _aucdtect and _aucdtect w/ spectrogram creation
  # 'conflict' is set during parameter handling if conflicts will ocurr
  if [[ "${operations[0]}" == 'conflict' ]]; then
    _error "Running both ${cyan}-a, --aucdtect${reset} and ${cyan}-A, --aucdtect-spectrogram${reset} conflict!\n\n"

    _error 'Please choose one or the other.\n'
    exit 1
  fi
}

#
# Display the summary of operations chart
#
_summary()
{
  # Set up local variables/arrays
  declare     operation  sub_message
  declare -a  operation_keys

  # Title
  printf "\033[$(_row);2H${blue}%s${reset}\n" \
  '---------------------------------------------------'
  printf '                Summary Of Operations\n'
  printf "${reset} ${blue}%s${reset}\n" \
  '-------------------------+-------------------------'

  # Correct order to display operational status to process
  operation_keys=(
    'Validate with auCDtect'
    'Check MD5 Signature'
    'Compress FLACs'
    'Test FLACs'
    '>> Testing'
    '>> Applying'
    '>> Analyzing'
    '>> Re-Tagging'
    'Extracting Artwork'
    'Prune METADATA Blocks'
  )

  for operation in "${operation_keys[@]}"; do
    # Display each operational line with the status of that operation, if it
    # was called
    #--
    if [[ -n "${operation_summary[$operation]}" ]]; then
      # Check for sub messages, and apply additional formatting
      if [[ "${operation}" == '>> '* ]]; then
        if [[ "${operation}" == '>> Testing' ]]; then
          printf "${yellow}%25s ${blue}|${reset}\n" 'Applying ReplayGain'
        elif [[ "${operation}" == '>> Analyzing' ]]; then
          printf "${yellow}%25s ${blue}|${reset}\n" 'Retagging FLACs'
        fi

        printf -v sub_message '%25s' "${operation}"  # Store right aligned message

        # Color '>>' as yellow and message as magenta
        printf "${yellow}%s${magenta}%s ${blue}|${reset}" \
          "${sub_message%%>> *}>>" "${sub_message##*>>}"
      else
          printf "${yellow}%25s ${blue}|${reset}" "${operation}"
      fi

      # Colorize the operational status
      case "${operation_summary[$operation]}" in
        'Operation Completed')
          printf " ${green}%s${reset}\n" "${operation_summary[$operation]}"
        ;;
        'Operation Interrupted')
          printf " ${cyan}%s${reset}\n" "${operation_summary[$operation]}"
        ;;
        'Operation Did Not Run')
          printf " ${magenta}%s${reset}\n" "${operation_summary[$operation]}"
        ;;
        *'Issue'*)
          printf " ${red}%s${reset}\n" "${operation_summary[$operation]}"
        ;;
      esac
    fi
  done

  # Last line of chart
  printf " ${blue}%s${reset}\n" \
    '-------------------------+-------------------------'

  # Remove temporary FIFOs and files
  rm -f "${job_fifo}" "${tmp_aucdtect_fd}" "${issue_ticks}"

  printf '\033[?25h'   # Restore cursor
}

#
# Run a given operation with a specified number of jobs
#
# $1 is the operational function to run multiple jobs, which can be:
#   aucdtect                  md5_check           compress_verify
#   compress_no_test          test                replaygain_test
#   replaygain_force_apply    replaygain_apply    retag_analyze
#   retag_apply               extract_images      prune
#
_run_parallel()
{
  local item
  local -i row starting_row previous_row iteration=0

  starting_row=$(_row)  # Current cursor row position state

  # Start as many operations as specified by the number of jobs
  for item in "${total_items[@]:0:${jobs}}"; do
    row=$((starting_row + iteration++))  # Placement of file/dir processed
    _$1 "$iteration" &                   # Fork process
  done

  # Wait on operations
  (( ${#total_items[@]} <= jobs )) && wait

  # An operation is completed with an integer and newline sent to a FIFO.  The
  # integer is that row position an operation was on.  For each newline read
  # in, process another file/dir from $total_items[@]
  while read -r previous_row; do
    (( iteration >= ${#total_items[@]} )) && break  # Stop, if no more FLACs
    item="${total_items[iteration++]}"    # Current file/dir to process
    row=$((starting_row + previous_row))  # Placement of file/dir processed
    _$1 "$previous_row" &                 # For process
  done <&3  # Read from FIFO

  # Wait on operations
  wait
}

#
# Test FLAC file's for ReplayGain application
#
# $1 is the filename
# $2 is the operation that's currently being run, of which, can be:
#   aucdtect                  md5_check           compress_verify
#   compress_no_test          test                replaygain_test
#   replaygain_force_apply    replaygain_apply    retag_analyze
#   retag_apply               extract_images      prune
# $3 is a string representing number items processed, eg: [43/439]
# $4 is the current operation's row placement
#
_replaygain_test()
{
  trap '_kill_jobs "$(jobs -rp)"' EXIT

  # Set up local variables
  declare    file_basename
  declare -i file_length

  # Truncate file, if necessary, and grab file information, splitting on
  # Unit Separator (\037)
  IFS=$'\037' read -r file_basename file_length < <(_truncate_filename "$1")

  # Print current FLAC being processed
  _print_item "${file_basename}" "${file_length}" "$3" 'sub'

  # Check if file is a FLAC file (capture output) via obtaining the sample
  # rate of the current file.  The sample rate captured will be tested against
  # later on.  Hide STDERR as we'll test the exit code instead
  current_sample_rate="$(metaflac --show-sample-rate "${1}" 2>/dev/null)"

  # Non-zero is failure
  if (( $? != 0 )); then
    # Display error
    _print_status 'fail' "$file_basename" "$file_length" 'sub'

    # Log header
    if [[ ! -f "$log_file" ]]; then
      printf >  "$log_file" '%s\n' 'redoflacs - FLAC ReplayGain test error log'
      printf >> "$log_file" '%.s-' {1..79}
      printf >> "$log_file" '\n'
    fi

    # Log FLAC failure
    printf >> "$log_file" '%s: Not a real FLAC file\n' "${PWD}/${1##*/}"
    printf >> "$issue_ticks" '.'  # Add one tick to total issues
  else
    # File is OK, test if sample rate is above 48kHz and the version of
    # `metaflac' installed is greater than 1.2.1
    if (( current_sample_rate > 48000 )); then

      # Sample rate is greater than 48kHz, so check to make sure the
      # version of `metaflac' is greater than 1.2.1
      if (( $(_metaflac_version) < 3 )); then
        # Old version of `metaflac' installed, display skipped
        _print_status 'skip' "${file_basename}" "${file_length}" 'sub'

        # Log header
        if [[ ! -f "$log_file" ]]; then
          printf >  "$log_file" '%s\n' \
            'redoflacs - FLAC ReplayGain test error log'
          printf >> "$log_file" '%.s-' {1..79}
          printf >> "$log_file" '\n'
        fi

        # The `metaflac' version installed is NOT greater than 1.2.1 so
        # skip processing current FLAC file, logging why it was skipped
        printf >> "$log_file"                                         \
          '%s: FLAC 1.3.0 or higher needed for sample rates >48kHz\n' \
          "${PWD}/${1##*/}"
        printf >> "$issue_ticks" '.'  # Add one tick to total issues
      else
        # FLAC is ok, display ok
        _print_status 'ok' "${file_basename}" "${file_length}" 'sub'
      fi
    else
      # FLAC is ok, display ok
      _print_status 'ok' "${file_basename}" "${file_length}" 'sub'
    fi
  fi
  printf "$4\n" >&3  # Store row position and end operation
}

#
# Apply ReplayGain to each directory of FLAC files (if values are missing)
#
# $1 is the directory (includes a slash, ie 'dir/'
# $2 is the operation that's currently being run, of which, can be:
#   aucdtect                  md5_check           compress_verify
#   compress_no_test          test                replaygain_test
#   replaygain_force_apply    replaygain_apply    retag_analyze
#   retag_apply               extract_images      prune
# $3 is a string representing number items processed, eg: [43/439]
# $4 is the current operation's row placement
#
_replaygain_apply()
{
  trap '_kill_jobs "$(jobs -rp)"' EXIT

  # Set up local variables
  declare file_basename percent_complete
  declare -i file_length
  declare -a replaygain_tags

  # Truncate file, if necessary, and grab file information, splitting on
  # Unit Separator (\037)
  IFS=$'\037' read -r file_basename file_length < <(_truncate_filename "$1")

  # Print current FLAC being processed
  _print_item "${file_basename}" "${file_length}" "$3" 'sub'

  # ${j} is a FLAC file -> under a directory, ${1}
  for j in "${1}"*${flac_extension}; do
    # Grab all of the ReplayGain tags
    mapfile -n0 -t replaygain_tags < \
      <(metaflac \
        --show-tag='REPLAYGAIN_REFERENCE_LOUDNESS' \
        --show-tag='REPLAYGAIN_TRACK_GAIN' \
        --show-tag='REPLAYGAIN_TRACK_PEAK' \
        --show-tag='REPLAYGAIN_ALBUM_GAIN' \
        --show-tag='REPLAYGAIN_ALBUM_PEAK' \
        "${j}"
      )

    # Test if any ReplayGain values are empty (if there are less
    # than 5 values in the replaygain array)
    if (( ${#replaygain_tags[@]} < 5 )); then
      # At _least_ one tag is missing from current file, so
      # apply new ReplayGain values
      #
      # Add ReplayGain to FLAC files under directory.  Metaflac
      # automatically removes old ReplayGain values (if any) before
      # proceeding
      metaflac ${metaflac_extra_options} --add-replay-gain "${1}"/*${flac_extension} >/dev/null 2>&1

      # Non-zero is failure
      if (( $? != 0 )); then
        # Display error
        _print_status 'fail' "$file_basename" "$file_length" 'sub'

        # Log header
        if [[ ! -f "$log_file" ]]; then
          printf >  "$log_file" '%s\n' \
            'redoflacs - FLAC ReplayGain apply error log'
          printf >> "$log_file" '%.s-' {1..79}
          printf >> "$log_file" '\n'
        fi

        # Log FLAC failure
        printf >> "$log_file" '%s: ' "${PWD}/${1##*/}"
        printf >> "$log_file" 'Corrupt FLAC(s) or differing sample rates '
        printf >> "$log_file" '(album ReplayGain)\n'
        printf >> "$issue_ticks" '.'  # Add one tick to total issues
        break                         # Move on to next directory
      else
        # Applied ReplayGain successfully
        _print_status 'ok' "${file_basename}" "${file_length}" 'sub'
      fi
    else
      # All FLACs have ReplayGain applied
      _print_status 'ok' "${file_basename}" "${file_length}" 'sub'
    fi
  done
  printf "$4\n" >&3  # Store row position and end operation
}

#
# Apply ReplayGain to each directory of FLAC files (force new values)
#
# $1 is the directory (includes a slash, ie 'dir/'
# $2 is the operation that's currently being run, of which, can be:
#   aucdtect                  md5_check           compress_verify
#   compress_no_test          test                replaygain_test
#   replaygain_force_apply    replaygain_apply    retag_analyze
#   retag_apply               extract_images      prune
# $3 is a string representing number items processed, eg: [43/439]
# $4 is the current operation's row placement
#
_replaygain_force_apply()
{
  trap '_kill_jobs "$(jobs -rp)"' EXIT

  # Set up local variables
  declare    file_basename  percent_complete
  declare -i file_length

  # Truncate file, if necessary, and grab file information, splitting on
  # Unit Separator (\037)
  IFS=$'\037' read -r file_basename file_length < <(_truncate_filename "$1")

  # Print current FLAC being processed
  _print_item "${file_basename}" "${file_length}" "$3" 'sub'

  # Add ReplayGain to FLAC files under directory
  metaflac ${metaflac_extra_options} --add-replay-gain "${1}"*${flac_extension} >/dev/null 2>&1

  # Non-zero is failure
  if (( $? != 0 )); then
    # Display error
    _print_status 'fail' "$file_basename" "$file_length" 'sub'

    # Log header
    if [[ ! -f "$log_file" ]]; then
      printf >  "$log_file" '%s\n' \
        'redoflacs - FLAC ReplayGain apply error log'
      printf >> "$log_file" '%.s-' {1..79}
      printf >> "$log_file" '\n'
    fi

    # Log FLAC failure
    printf >> "$log_file" '%s: ' "${PWD}/${1##*/}"
    printf >> "$log_file" 'Corrupt FLAC(s) or differing sample rates '
    printf >> "$log_file" '(album ReplayGain)\n'
    printf >> "$issue_ticks" '.'  # Add one tick to total issues
  else
    # Applied ReplayGain successfully
    _print_status 'ok' "${file_basename}" "${file_length}" 'sub'
  fi
  printf "$4\n" >&3  # Store row position and end operation
}

#
# Compress FLACs with user-defined compression level, verifying its integrity
#
# $1 is the FLAC file operated on
# $2 is the operation that's currently being run, of which, can be:
#   aucdtect                  md5_check           compress_verify
#   compress_no_test          test                replaygain_test
#   replaygain_force_apply    replaygain_apply    retag_analyze
#   retag_apply               extract_images      prune
# $3 is a string representing number items processed, eg: [43/439]
# $4 is the current operation's row placement
#
_compress_verify()
{
  trap '_kill_jobs "$(jobs -rp)"' EXIT

  # Set up local variables
  declare    file_basename percent_complete
  declare -i file_length

  # Truncate file, if necessary, and grab file information, splitting on
  # Unit Separator (\037)
  IFS=$'\037' read -r file_basename file_length < <(_truncate_filename "$1")

  # Print current FLAC being processed
  _print_item "${file_basename}" "${file_length}" "$3"

  # Only obtain current COMPRESSION value if the user did not specify '-x,
  # --no-extra-tags'
  if [[ "${no_extra_tags}" != 'true' ]]; then
    # Test for COMPRESSION level in FLAC file. Hide error output since
    # we'll be verifying the FLAC file later
    COMPRESSION="$(metaflac --show-tag='COMPRESSION' "${1}" 2> /dev/null)"
    COMPRESSION="${COMPRESSION#*=}"
  fi

  if (( COMPRESSION != compression_level )) || [[ "${no_extra_tags}" == 'true' ]]; then
    flac -f -${compression_level} -V "${1}" 2> \
      >(while read -r -d'%' percent_complete; do
        # Compress given FLAC file, verifying with a progress bar
        #--
        # Current percent complete
        percent_complete="$( _get_percent_complete "$2" "${percent_complete}" )"

        # Print operation progress bar and percent complete
        _print_progress "$2" "${percent_complete}" "${file_basename}" "${file_length}"
      done) >/dev/null

    # Non-zero is failure
    if (( $? != 0 )); then
      # Display error
      _print_status 'fail' "$file_basename" "$file_length"

      # Log header
      if [[ ! -f "$log_file" ]]; then
        printf >  "$log_file" '%s\n' \
          'redoflacs - FLAC compress/verify error log'
        printf >> "$log_file" '%.s-' {1..79}
        printf >> "$log_file" '\n'
      fi

      # Log FLAC failure
      printf >> "$log_file" '%s: Failed verification\n' "${PWD}/${1##*/}"
      printf >> "$issue_ticks" '.'  # Add one tick to total issues
    else
      # Only remove/add the new compression level if the user did not specify
      # no additional tags ('-x, --no-extra-tags' option)
      if [[ "${no_extra_tags}" != 'true' ]]; then
        metaflac ${metaflac_extra_options} \
          --remove-tag='COMPRESSION' \
          --set-tag='COMPRESSION'="${compression_level}" "${1}"
      fi

      # FLAC is ok, display ok
      _print_status 'ok' "${file_basename}" "${file_length}"
    fi
  else
    # If already at compression_level, test the FLAC file instead
    flac -t "${1}" 2> \
      >(while read -r -d'%' percent_complete; do
        # Test given FLAC file, with a progress bar
        #--
        # Current percent complete
        percent_complete="$( _get_percent_complete 'test' "${percent_complete}" )"

        # Print operation progress bar and percent complete
        _print_progress 'test' "${percent_complete}" "${file_basename}" "${file_length}"
      done) >/dev/null

    # Non-zero is failure
    if (( $? != 0 )); then
      # Display error
      _print_status 'fail' "$file_basename" "$file_length"

      # Log header
      if [[ ! -f "$log_file" ]]; then
        printf >  "$log_file" '%s\n' \
          'redoflacs - FLAC compress/verify error log'
        printf >> "$log_file" '%.s-' {1..79}
        printf >> "$log_file" '\n'
      fi

      # Log FLAC failure
      printf >> "$log_file" '%s: Failed verification\n' "${PWD}/${1##*/}"
      printf >> "$issue_ticks" '.'  # Add one tick to total issues
    else
      # FLAC is ok, display ok
      _print_status 'ok' "${file_basename}" "${file_length}"
    fi
  fi
  printf "$4\n" >&3  # Store row position and end operation
}

#
# Compress FLACs with user-defined compression level, verifying its integrity
# and _not_ falling back to _test() if the compression level is already set
#
# $1 is the FLAC file operated on
# $2 is the operation that's currently being run, of which, can be:
#   aucdtect                  md5_check           compress_verify
#   compress_no_test          test                replaygain_test
#   replaygain_force_apply    replaygain_apply    retag_analyze
#   retag_apply               extract_images      prune
# $3 is a string representing number items processed, eg: [43/439]
# $4 is the current operation's row placement
#
_compress_no_test()
{
  trap '_kill_jobs "$(jobs -rp)"' EXIT

  # Set up local variables
  declare    file_basename percent_complete
  declare -i file_length

  # Truncate file, if necessary, and grab file information, splitting on
  # Unit Separator (\037)
  IFS=$'\037' read -r file_basename file_length < <(_truncate_filename "$1")

  # Print current FLAC being processed
  _print_item "${file_basename}" "${file_length}" "$3"

  # Test for COMPRESSION level in FLAC file. Hide error output since
  # we'll be verifying the FLAC file later
  COMPRESSION="$(metaflac --show-tag='COMPRESSION' "${1}" 2> /dev/null)"
  COMPRESSION="${COMPRESSION#*=}"

  if (( COMPRESSION != compression_level )); then
    flac -f -${compression_level} -V "${1}" 2> \
      >(while read -r -d'%' percent_complete; do
        # Compress given FLAC file, verifying with a progress bar
        #--
        # Current percent complete
        percent_complete="$( _get_percent_complete "$2" "${percent_complete}" )"

        # Print operation progress bar and percent complete
        _print_progress "$2" "${percent_complete}" "${file_basename}" "${file_length}"
      done) >/dev/null

    # Non-zero is failure
    if (( $? != 0 )); then
      # Display error
      _print_status 'fail' "$file_basename" "$file_length"

      # Log header
      if [[ ! -f "$log_file" ]]; then
        printf >  "$log_file" '%s\n' 'redoflacs - FLAC compress/verify error log'
        printf >> "$log_file" '%.s-' {1..79}
        printf >> "$log_file" '\n'
      fi

      # Log FLAC failure
      printf >> "$log_file" '%s: Failed verification\n' "${PWD}/${1##*/}"
      printf >> "$issue_ticks" '.'  # Add one tick to total issues
    else
      metaflac ${metaflac_extra_options} \
        --remove-tag='COMPRESSION' \
        --set-tag='COMPRESSION'="${compression_level}" "${1}"

      # FLAC is ok, display ok
      _print_status 'ok' "${file_basename}" "${file_length}"
    fi
  else
    # Already at compression_level, print skipped FLAC file
    _print_status 'skip' "${file_basename}" "${file_length}"
  fi
  printf "$4\n" >&3  # Store row position and end operation
}

#
# Test FLAC file integrity
#
# $1 is the current operation's row placement
#
_test()
{
  trap '_kill_jobs "$(jobs -rp)"' EXIT

  local pct

  _print_item

  # Test given FLAC file, obtaining percent complete
  flac -t "$item" 2> >(
    while read -r -d'%' pct; do
      pct="${pct##* }"
      [[ "$pct" == *[^[:digit:]]* ]] && pct='0'
      # Print percentage complete
      printf "\033[${row}H${yellow}%3d%%${reset}" "$pct"
    done
  )

  if (( $? == 0 )); then
    _print_ok
    printf >&3 "$1\n" # Store row position and end operation
    return
  fi

  _print_fail

  # Log header
  if [[ ! -f "$log_file" ]]; then
    printf >  "$log_file" 'redoflacs - FLAC test error log\n'
    printf >> "$log_file" '%.s-' {1..79}
    printf >> "$log_file" '\n'
  fi

  # Log FLAC failure
  printf >> "$log_file" '%s: Failed testing\n' "$item"
  printf >> "$issue_ticks" '.'  # Add one tick to total issues
  printf >&3 "$1\n"  # Store row position and end operation
}

#
# Test FLAC validity with auCDtect
#
# $1 is the filename
# $2 is the operation that's currently being run, of which, can be:
#   aucdtect                  md5_check           compress_verify
#   compress_no_test          test                replaygain_test
#   replaygain_force_apply    replaygain_apply    retag_analyze
#   retag_apply               extract_images      prune
# $3 is a string representing number items processed, eg: [43/439]
# $4 is the current operation's row placement
#
_aucdtect()
{
  trap '_kill_jobs "$(jobs -rp)"' EXIT

  # Set up local arrays/variables
  declare    file_basename percent_complete
  declare -i file_length
  declare -a bits_mastering

  # Truncate file, if necessary, and grab file information, splitting on
  # Unit Separator (\037)
  IFS=$'\037' read -r file_basename file_length < <(_truncate_filename "$1")

  # Print current FLAC being processed
  _print_item "${file_basename}" "${file_length}" "$3"

  # Get the bit depth and MASTERING tag of a FLAC file.  Also used to check if
  # FLAC file is real.  Hide STDERR output.  The array indices are:
  #   bits_mastering[0] = bit depth (eg, 16)
  #   bits_mastering[1] = MASTERING tag & value (eg, MASTERING=Lossy)
  bits_mastering=( $(metaflac --show-bps --show-tag='MASTERING' "$1" 2>/dev/null) )

  # Non-zero is failure
  if (( $? != 0 )); then
    # Display error
    _print_status 'fail' "$file_basename" "$file_length"

    # Log header
    if [[ ! -f "$log_file" ]]; then
      printf >  "$log_file" '%s\n' 'redoflacs - auCDtect error log'
      printf >> "$log_file" '%.s-' {1..79}
      printf >> "$log_file" '\n'
    fi

    # Log FLAC failure
    printf >> "$log_file" '%s: Not a real FLAC file\n' "${PWD}/${1##*/}"
    printf >> "$issue_ticks" '.'  # Add one tick to total issues

  # Skip the FLAC file if it has a bit depth greater
  # than 16 since auCDtect doesn't support audio
  # files with a higher resolution than a CD.
  elif (( ${bits_mastering[0]} > 16 )); then
    # Display skipped
    _print_status 'skip' "$file_basename" "$file_length"

    # Log header
    if [[ ! -f "$log_file" ]]; then
      printf >  "$log_file" '%s\n' 'redoflacs - auCDtect error log'
      printf >> "$log_file" '%.s-' {1..79}
      printf >> "$log_file" '\n'
    fi

    # Log skipped FLAC file
    printf >> "$log_file" \
      '%s: auCDtect does not support a bit depth >16\n' "${PWD}/${1##*/}"
    printf >> "$issue_ticks" '.'  # Add one tick to total issues

  # Skip the FLAC file if it already has the 'Lossy' value set for the
  # MASTERING tag.  This is only done if the value of 'skip_lossy' is 'true',
  # set in the configuration file.  We make sure to remove 'MASTERING=' before
  # testing the tag field
  elif [[ "${bits_mastering[1]#*=}" == 'Lossy' ]]; then
    # Display skipped
    _print_status 'skip' "$file_basename" "$file_length"

    # Log header
    if [[ ! -f "$log_file" ]]; then
      printf >  "$log_file" '%s\n' 'redoflacs - auCDtect error log'
      printf >> "$log_file" '%.s-' {1..79}
      printf >> "$log_file" '\n'
    fi

    # Log skipped FLAC file
    printf >> "$log_file" '%s: MASTERING=Lossy value found; ' "${PWD}/${1##*/}"
    printf >> "$log_file" "skipping ('skip_lossy' configuration)\n"
    printf >> "$issue_ticks" '.'  # Add one tick to total issues

  # FLAC checks out, continue processing
  else
    # Re-truncate file, since we're doing a multi-stage operation, the
    # filename will be shorter than normal
    IFS=$'\037' read -r file_basename file_length < <(_truncate_filename "$1" 'multi-stage')

    # Print current FLAC being processed
    _print_item "${file_basename}" "${file_length}" "$3" 'decode'

    # The WAV file to be created from current FLAC file
    decoded_wav="${1%${flac_extension}}_redoflacs_$$.wav"

    flac -d "${1}" -o "${decoded_wav}" 2> \
      >(while read -r -d'%' percent_complete; do
        # Decode FLAC to WAV so auCDtect can read the audio file
        #--
        # Current percent complete
        percent_complete="$( _get_percent_complete 'decode' "${percent_complete}" )"

        # Print operation progress bar and percent complete
        _print_progress 'decode' "${percent_complete}" "${file_basename}" "${file_length}"
      done) >/dev/null

    # Non-zero is failure
    if (( $? != 0 )); then
      # Display error
      _print_status 'fail' "$file_basename" "$file_length" 'decode'

      # Log header
      if [[ ! -f "$log_file" ]]; then
        printf >  "$log_file" '%s\n' 'redoflacs - auCDtect error log'
        printf >> "$log_file" '%.s-' {1..79}
        printf >> "$log_file" '\n'
      fi

      # Log FLAC failure
      printf >> "$log_file" '%s: Failed decoding to WAV\n' "${PWD}/${1##*/}"
      printf >> "$issue_ticks" '.'  # Add one tick to total issues

    else
      # Decoded FLAC is ok, display ok
      _print_status 'ok' "$file_basename" "$file_length" 'decode'

      # Re-truncate file, since we're doing a multi-stage operation, the
      # filename will be shorter than normal
      IFS=$'\037' read -r file_basename file_length < <(_truncate_filename "$1" 'multi-stage')

      # Print current FLAC being processed, auCDtect: fast
      _print_item "$file_basename" "$file_length" "$3" 'aucdtect_fast'

      # 'export MALLOC_CHECK_' allows the dynamic linked version of
      # `auCDTECT' to run without throwing errors
      export MALLOC_CHECK_='0'

      # The actual auCDtect command with medium accuracy setting (for
      # speed).  STDOUT is sent to file descriptor '4'
      _aucdtect_cmd -m20 "${decoded_wav}" 2> \
        >(while read -r -d'%' percent_complete; do
          # Check FLAC validity by checking decoded WAV via auCDtect (fast)
          #--
          # Current percent complete
          percent_complete="$( _get_percent_complete "$2" "${percent_complete}" )"

          # Print operation progress bar and percent complete
          _print_progress 'aucdtect_fast' "${percent_complete}" "${file_basename}" "${file_length}"
        done) >&4

      # Non-zero is failure
      if (( $? != 0 )); then
        # Display error
        _print_status 'fail' "$file_basename" "$file_length" 'aucdtect_fast'

        # Log header
        if [[ ! -f "$log_file" ]]; then
          printf >  "$log_file" '%s\n' 'redoflacs - auCDtect error log'
          printf >> "$log_file" '%.s-' {1..79}
          printf >> "$log_file" '\n'
        fi

        # Log FLAC failure
        printf >> "$log_file" \
          '%s: Failed analyzing decoded FLAC\n' "${PWD}/${1##*/}"
        printf >> "$issue_ticks" '.'  # Add one tick to total issues

      else
        # Grab the conclusion of auCDtect's command
        # Below options prevents hanging FIFO by only reading
        # what is necessary:
        #    -s7:  Discard first seven lines from auCDtect's output
        #    -n2:  Only grab 2 lines from auCDtect's output
        #     -t:  Remove trailing newlines from auCDtect's output
        #    -u4:  Obtain auCDtect's output from file descriptor '4'
        #  array:  Store captured output into 'aucdtect_check_array'
        mapfile -s7 -n2 -t -u4 aucdtect_check_array

        # If there is an issue with the processed FLAC file, run
        # auCDtect once again with highest setting
        if [[ "${aucdtect_check_array[0]}" != 'This track looks like CDDA with probability 100%' ]]; then
          # Re-truncate file, since we're doing a multi-stage operation, the
          # filename will be shorter than normal
          IFS=$'\037' read -r file_basename file_length < <(_truncate_filename "$1" 'multi-stage')

          # Print current FLAC being processed, auCDtect: slow
          _print_item "${file_basename}" "${file_length}" "$3" 'aucdtect_slow'

          # The actual auCDtect command with highest accuracy setting.
          # STDOUT is sent to file descriptor '4'
          _aucdtect_cmd -m0 "${decoded_wav}" 2> \
            >(while read -r -d'%' percent_complete; do
              # Check FLAC validity by checking decoded WAV via auCDtect (slow)
              #--
              # Current percent complete
              percent_complete="$( _get_percent_complete "$2" "${percent_complete}" )"

              # Print operation progress bar and percent complete
              _print_progress 'aucdtect_slow' "${percent_complete}" "${file_basename}" "${file_length}"
            done) >&4

          # Non-zero is failure
          if (( $? != 0 )); then
            # Error with FLAC file, display failed/error
            _print_status 'fail' "$file_basename" "$file_length" 'aucdtect_slow'

            # Log header
            if [[ ! -f "$log_file" ]]; then
              printf >  "$log_file" '%s\n' 'redoflacs - auCDtect error log'
              printf >> "$log_file" '%.s-' {1..79}
              printf >> "$log_file" '\n'
            fi

            # Log FLAC failure
            printf >> "$log_file" \
              '%s: Failed analyzing decoded FLAC\n' "${PWD}/${1##*/}"
            printf >> "$issue_ticks" '.'  # Add one tick to total issues
          else
            # Grab the conclusion of auCDtect's command
            # Below options prevents hanging FIFO by only reading
            # what is necessary:
            #    -s7:  Discard first seven lines from auCDtect's output
            #    -n2:  Only grab 2 lines from auCDtect's output
            #     -t:  Remove trailing newlines from auCDtect's output
            #    -u4:  Obtain auCDtect's output from file descriptor '4'
            #  array:  Store captured output into 'aucdtect_check_array'
            mapfile -s7 -n2 -t -u4 aucdtect_check_array

            # There is an issue with the processed FLAC file
            if [[ "${aucdtect_check_array[0]}" != 'This track looks like CDDA with probability 100%' ]]; then
              # If user specified '-A, --aucdtect-spectrogram', then
              # create a spectrogram with SoX and change logging accordingly
              if [[ "${create_spectrogram}" == 'true' ]]; then
                # Check whether to place spectrogram images in user-defined location
                if [[ -z "${spectrogram_location}" ]]; then
                  # Obtain basename of current FLAC file
                  flac_file="${1##*/}"

                  # Obtain dirname of current FLAC file
                  spectrogram_dirname="${1%/*}"

                  # Create the spectrogram with '.png' as the
                  # file extension, placed in the same
                  # directory as the current FLAC file
                  spectrogram_picture="${spectrogram_dirname}/${flac_file%${flac_extension}}__${iteration}__.png"
                else
                  # Obtain basename of current FLAC file
                  flac_file="${1##*/}"

                  # Create the spectrogram with '.png' as the
                  # file extension, placed in the user-defined
                  # location
                  spectrogram_picture="${spectrogram_location}/${flac_file%${flac_extension}}__${iteration}__.png"
                fi

                # Re-truncate file, since we're doing a multi-stage operation, the
                # filename will be shorter than normal
                IFS=$'\037' read -r file_basename file_length < <(_truncate_filename "$1" 'multi-stage')

                # Print current FLAC being processed
                _print_item "${file_basename}" "${file_length}" "$3" 'spectrogram'

                # SoX command to create the spectrogram and
                # place it in spectrogram_picture.  Use the
                # following arguments to create the highest
                # resolution spectrograms:
                #   -x 5000
                #   -y 1025
                _sox_cmd \
                  "${decoded_wav}" -S -n spectrogram -c '' -t "${1}" \
                  -p 1 -z 90 -Z 0 -q 249 -w Hann -x 1800 -y 513 \
                  -o "${spectrogram_picture}" 2> \
                    >(while read -r -d'%' percent_complete; do
                      # Create spectrogram PNG image of given FLAC
                      #--
                      # Current percent complete
                      percent_complete="$( _get_percent_complete 'spectrogram' "${percent_complete}" )"

                      # Print operation progress bar and percent complete
                      _print_progress 'spectrogram' "${percent_complete}" "${file_basename}" "${file_length}"
                    done) >/dev/null

                # Error creating spectrogram, display issue
                _print_status 'issue' "$file_basename" "$file_length" 'spectrogram'

                # Log header
                if [[ ! -f "$log_file" ]]; then
                  printf >  "$log_file" '%s\n' 'redoflacs - auCDtect error log'
                  printf >> "$log_file" '%.s-' {1..79}
                  printf >> "$log_file" '\n'
                fi

                # Log auCDtect report
                printf >> "$log_file" '%s: %s (%s)\n' "${PWD}/${1##*/}" \
                  "${aucdtect_check_array[0]}" "$spectrogram_picture"
                printf >> "$issue_ticks" '.'  # Add one tick to total issues
              else
                # Issue with FLAC authenticity, display issue
                _print_status 'issue' "$file_basename" "$file_length" 'aucdtect_slow'

                # Log header
                if [[ ! -f "$log_file" ]]; then
                  printf >  "$log_file" '%s\n' 'redoflacs - auCDtect error log'
                  printf >> "$log_file" '%.s-' {1..79}
                  printf >> "$log_file" '\n'
                fi

                # Log auCDtect report
                printf >> "$log_file" '%s: %s\n' "${PWD}/${1##*/}" \
                  "${aucdtect_check_array[0]}"
                printf '.' >> "${issue_ticks}"  # Add one tick to total issues
              fi
            else
              # FLAC is ok, display ok
              _print_status 'ok' "${file_basename}" "${file_length}" 'aucdtect_slow'
            fi
          fi
        else
          # FLAC is ok, display ok
          _print_status 'ok' "${file_basename}" "${file_length}" 'aucdtect_fast'
        fi

        # Remove temporary WAV file
        rm "${decoded_wav}"
      fi
    fi
  fi
  printf "$4\n" >&3  # Store row position and end operation
}

#
# Check for valid MD5 checksum in FLAC file
#
# $1 is the filename
# $2 is the operation that's currently being run, of which, can be:
#   aucdtect                  md5_check           compress_verify
#   compress_no_test          test                replaygain_test
#   replaygain_force_apply    replaygain_apply    retag_analyze
#   retag_apply               extract_images      prune
# $3 is a string representing number items processed, eg: [43/439]
# $4 is the current operation's row placement
#
_md5_check()
{
  trap '_kill_jobs "$(jobs -rp)"' EXIT

  # Set up local variables
  declare    file_basename percent_complete md5_sum
  declare -i file_length

  # Truncate file, if necessary, and grab file information, splitting on
  # Unit Separator (\037)
  IFS=$'\037' read -r file_basename file_length < <(_truncate_filename "$1")

  # Print current FLAC being processed
  _print_item "${file_basename}" "${file_length}" "$3"

  # Get the MD5 checksum (hide stderr output).  Also
  # used to check if FLAC file is real
  md5_sum="$(metaflac --show-md5sum "$1" 2>/dev/null)"

  # Non-zero is failure
  if (( $? != 0 )); then
    # Display error
    _print_status 'fail' "$file_basename" "$file_length"

    # Log FLAC failure
    printf >> "$log_file" '%s: Not a real FLAC file\n' "${PWD}/${1##*/}"
    printf >> "$issue_ticks" '.'  # Add one tick to total issues

  # FLAC file is real, check for unset MD5 checksum.  We cannot use an
  # arithmetic expression as any amount of 0's will equal the expression
  # below
  elif [[ "${md5_sum}" == '00000000000000000000000000000000' ]]; then
    # Display error
    _print_status 'fail' "$file_basename" "$file_length"

    # Log FLAC failure
    printf >> "$log_file"                                            \
      '%s: Unset MD5 signature (00000000000000000000000000000000)\n' \
      "${PWD}/${1##*/}"
    printf >> "$issue_ticks" '.'  # Add one tick to total issues
  else
    # FLAC is ok, display ok
    _print_status 'ok' "$file_basename" "$file_length"
  fi
  printf "$4\n" >&3  # Store row position and end operation
}

#
# Check for missing VORBIS tags from a given FLAC
#
# $1 is the filename
# $2 is the operation that's currently being run, of which, can be:
#   aucdtect                  md5_check           compress_verify
#   compress_no_test          test                replaygain_test
#   replaygain_force_apply    replaygain_apply    retag_analyze
#   retag_apply               extract_images      prune
# $3 is a string representing number items processed, eg: [43/439]
#
_retag_analyze()
{
  trap '_kill_jobs "$(jobs -rp)"' EXIT

  # Set up local variables
  declare    file_basename
  declare -i file_length

  # Truncate file, if necessary, and grab file information, splitting on
  # Unit Separator (\037)
  IFS=$'\037' read -r file_basename file_length < <(_truncate_filename "$1")

  # Print current FLAC being processed
  _print_item "${file_basename}" "${file_length}" "$3" 'sub'

  # Check if file is a FLAC file (variable hides output)
  check_flac="$(metaflac --show-md5sum "${1}" 2>&1)"

  # Non-zero is failure
  if (( $? != 0 )); then
    # Display error
    _print_status 'fail' "$file_basename" "$file_length" 'sub'

    # Log header
    if [[ ! -f "$log_file" ]]; then
      printf >  "$log_file" '%s\n' 'redoflacs - FLAC retagging error log'
      printf >> "$log_file" '%.s-' {1..79}
      printf >> "$log_file" '\n'
    fi

    # Log FLAC failure
    printf >> "$log_file" '%s: Not a real FLAC file\n' "${PWD}/${1##*/}"
    printf >> "$issue_ticks" '.'  # Add one tick to total issues

  else
    # Iterate through each tag field and check if tag is missing
    for j in "${tags[@]}"; do
      # Check if ALBUMARTIST is in tag array and apply operations on
      # the tag field if it exists
      if [[ "${j}" == 'ALBUMARTIST' ]]; then
        # ALBUMARTIST exists in tag array so allow script to check the
        # various naming conventions within the FLAC files (ie,
        # 'ALBUM ARTIST' or 'ALBUM_ARTIST')

        # "ALBUMARTIST" or "ALBUM ARTIST" or "ALBUM_ARTIST", case-insensitive
        if [[ -n "$(metaflac --show-tag='ALBUMARTIST' "${1}")" ]]; then
          show_tag_list+=( '--show-tag=ALBUMARTIST' )

        elif [[ -n "$(metaflac --show-tag='ALBUM ARTIST' "${1}")" ]]; then
          show_tag_list+=( '--show-tag=ALBUM ARTIST' )

        elif [[ -n "$(metaflac --show-tag='ALBUM_ARTIST' "${1}")" ]]; then
          show_tag_list+=( '--show-tag=ALBUM_ARTIST' )
        fi
      else
        # Build up metaflac '--show-tag=' list
        show_tag_list+=( "--show-tag=${j}" )
      fi
    done

    # Load up all the tag values for current file
    mapfile -n0 -t metaflac_tag_array < <(metaflac "${show_tag_list[@]}" "${1}")

    # Take above tag values and create an associative
    # array using TAG_FIELD=TAG_VALUE as the key/value pair
    #
    # Specifically declare an empty associative array
    declare -A temp_tag_array

    # Run through the tag array from above and store
    # the values into a temporary tag array
    for tag_field_value in "${metaflac_tag_array[@]}"; do
      # This is the tag field (eg. TITLE)
      tag_field="${tag_field_value%%=*}"

      # Enforce the tag field to be uppercase
      # ${tag_field_value} below is the tag value
      temp_tag_array+=( ["${tag_field^^}"]="${tag_field_value#*=}" )
    done

    # Run through the tags array and test each tag value from
    # ${temp_tag_array} with the currently processed tag in ${tag[@]}.  For
    # each match found, test if the tag value is null, reporting any missing
    # tags. Then remove the tag field (index) from the ${temp_tag_array}, so
    # the next iteration is faster and we can check for missing tags (tag
    # fields)
    for j in "${tags[@]}"; do

      # If the total # of indices in the temporary tag array is above
      # 0, continue testing, else store missing tag (${j}) into the
      # missing tags array
      if (( ${#temp_tag_array[@]} > 0 )); then

        # Compare each tag field from the temporary array to ${j},
        # checking if they are equal and if so, check for missing
        # tag values
        for temp_tag_field in "${!temp_tag_array[@]}"; do
          # Both tag fields are equal
          if [[ "${j}" == "${temp_tag_field}" ]]; then
            # Check if tag value is null, logging missing tags if so
            if [[ -z "${temp_tag_array[${temp_tag_field}]}" ]]; then
              missing_tags+="${j}, "
            fi

            # Remove the current tag field from the temporary tag
            # array since it's been matched already
            unset -v temp_tag_array["${temp_tag_field}"]

            # This variable let's the script know that the current
            # tag, ${j} has been matched up with a tag field in
            # ${temp_tag_array[@]}
            tag_match='true'

            # Break out of loop since the tag fields have been
            # matched, continuing on to the next iteration of ${j}
            break
          fi
        done

        # If there wasn't a tag field in the temporary tag array
        # ( eg. ${temp_tag_array[@]} ) that matched ${j}, the FLAC file
        # must have a missing tag, so log it by throwing the missing tag
        # into the missing tags array
        if [[ "${tag_match}" != 'true' ]]; then
          missing_tags+="${j}, "
        fi

        # Reset the value of tag match (if any) for the next iteration
        # of ${j}
        unset -v tag_match

      # The total # of indices in the temporary tag array is 0, so
      # whatever is left in ${tags[@]} represented by ${j} is logged
      # as missing
      else
        missing_tags+="${j}, "
      fi
    done

    # If missing_tags_array is not empty, there are missing
    # tags in the current file so log output
    if [[ -n "${missing_tags}" ]]; then
      # Error with FLAC file, display failed/error
      _print_status 'fail' "$file_basename" "$file_length" 'sub'

      # Log header
      if [[ ! -f "$log_file" ]]; then
        printf >  "$log_file" '%s\n' 'redoflacs - FLAC retagging error log'
        printf >> "$log_file" '%.s-' {1..79}
        printf >> "$log_file" '\n'
      fi

      # Log the missing tags
      printf >> "$log_file" '%s: Missing tags: %s\n' \
        "${PWD}/${1##*/}" "${missing_tags%, }"
      printf >> "$issue_ticks" '.'  # Add one tick to total issues
    else
      # There are no missing tags, display ok
      _print_status 'ok' "$file_basename" "$file_length" 'sub'
    fi
  fi
  printf "$4\n" >&3  # Store row position and end operation
}

#
# Re-apply the VORBIS tags specified in the config file, removing all others
#
# $1 is the filename
# $2 is the operation that's currently being run, of which, can be:
#   aucdtect                  md5_check           compress_verify
#   compress_no_test          test                replaygain_test
#   replaygain_force_apply    replaygain_apply    retag_analyze
#   retag_apply               extract_images      prune
# $3 is a string representing number items processed, eg: [43/439]
# $4 is the current operation's row placement
#
_retag_apply()
{
  trap '_kill_jobs "$(jobs -rp)"' EXIT

  # Set up local variables
  declare    file_basename
  declare -i file_length

  # Truncate file, if necessary, and grab file information, splitting on
  # Unit Separator (\037)
  IFS=$'\037' read -r file_basename file_length < <(_truncate_filename "$1")

  # Print current FLAC being processed
  _print_item "${file_basename}" "${file_length}" "$3" 'sub'

  # Remove and set new tags
  #
  # Iterate through the tag array and set a variable for each tag
  for j in "${tags[@]}"; do
    # Check if ALBUMARTIST is in tag array and apply operations on
    # the tag field if it exists
    if [[ "${j}" == 'ALBUMARTIST' ]]; then
      # ALBUMARTIST exists in tag array so allow script to check the
      # various naming conventions within the FLAC files (ie,
      # 'ALBUM ARTIST' or 'ALBUM_ARTIST')
      #--
      # "ALBUMARTIST"
      if [[ -n "$(metaflac --show-tag='ALBUMARTIST' "${1}")" ]]; then
        show_tag_list+=( '--show-tag=ALBUMARTIST' )

      elif [[ -n "$(metaflac --show-tag='ALBUM ARTIST' "${1}")" ]]; then
        show_tag_list+=( '--show-tag=ALBUM ARTIST' )

      elif [[ -n "$(metaflac --show-tag='ALBUM_ARTIST' "${1}")" ]]; then
        show_tag_list+=( '--show-tag=ALBUM_ARTIST' )
      fi
    else
      # Build up metaflac '--show-tag=' list
      show_tag_list+=( "--show-tag=${j}" )
    fi
  done

  # Load up all the tag values for current file
  mapfile -n0 -t metaflac_tag_array < <(metaflac "${show_tag_list[@]}" "${1}")

  # Create a copy of ${metaflac_tag_array[@]} with just the tag fields
  # and force the tag fields to be uppercase
  tag_field_array=( "${metaflac_tag_array[@]%%=*}" )
  tag_field_array=( "${tag_field_array[@]^^}" )

  # Create a copy of ${metaflac_tag_array[@]} with just the tag values
  tag_values_array=( "${metaflac_tag_array[@]#*=}" )

  # Clear the original 'tag_field=tag_value array' for use below
  metaflac_tag_array=()

  # If the user specified 'true' to the 'prepend_zero' option in the
  # configuration file, enforce the TRACKNUMBER and TRACKTOTAL tags to have a
  # '0' prepended before singular numbers
  if [[ "${prepend_zero}" == 'true' ]]; then
    # Prepend a '0' for TRACKNUMBER and TRACKTOTAL
    for j in "${!tag_field_array[@]}"; do
      if [[ "${tag_field_array[${j}]}" == 'TRACKNUMBER' || "${tag_field_array[${j}]}" == 'TRACKTOTAL' ]]; then
        # Remove leading and trailing whitespace in tag value, eg:
        #   '   7     '  ->  '7'
        read -r prepend_tag_value <<< "${tag_values_array[$j]}"

        # Prepend a 0 to the tag value, forcing base10 to prevent octal errors
        printf -v prepend_tag_value '%02d' $((10#${prepend_tag_value}))

        # Store the tag field and tag value into an array, TAG_FIELD=TAG_VALUE
        metaflac_tag_array+=( "${tag_field_array[$j]}=${prepend_tag_value}" )
      else
        # Remove leading and trailing whitespace in tag value, eg:
        #   '   The Black     Halo     '  ->  'The Black     Halo'
        read -r tag_value <<< "${tag_values_array[$j]}"

        # Store the tag field and tag value into an array, TAG_FIELD=TAG_VALUE
        metaflac_tag_array+=( "${tag_field_array[$j]}=${tag_value}" )
      fi
    done
  else
    # ${prepend_zero} is not set as 'true', add each tag field and tag value
    # into ${metaflac_tag_array[@]}
    for j in "${!tag_field_array[@]}"; do
      # Remove leading and trailing whitespace in tag value, eg:
      #   '   The Black     Halo     '  ->  'The Black     Halo'
      read -r tag_value <<< "${tag_values_array[$j]}"

      # Store the tag field and tag value into an array, TAG_FIELD=TAG_VALUE
      metaflac_tag_array+=( "${tag_field_array[$j]}=${tag_value}" )
    done
  fi

  # Add the saved tags back, by printing each tag field and value
  # on a separate line to STDOUT.  This will be read in by metaflac.
  # Use process substitution to allow this to finish if user
  # invokes SIGINT
  metaflac ${metaflac_extra_options} --remove-all-tags --import-tags-from=- "${1}" < \
    <(
      # This prints each tag key and value pair
      # (eg. ARTIST=Kamelot)
      printf '%s\n' "${metaflac_tag_array[@]}"
    )

  # Display ok
  _print_status 'ok' "${file_basename}" "${file_length}" 'sub'

  printf "$4\n" >&3  # Store row position and end operation
}

#
# Extact embedded artwork from a given FLAC
#
# $1 is the filename
# $2 is the operation that's currently being run, of which, can be:
#   aucdtect                  md5_check           compress_verify
#   compress_no_test          test                replaygain_test
#   replaygain_force_apply    replaygain_apply    retag_analyze
#   retag_apply               extract_images      prune
# $3 is a string representing number items processed, eg: [43/439]
# $4 is the current operation's row placement
#
_extract_images()
{
  trap '_kill_jobs "$(jobs -rp)"' EXIT

  # Set up local variables
  declare -i file_length increment

  # Truncate file, if necessary, and grab file information, splitting on
  # Unit Separator (\037)
  IFS=$'\037' read -r file_basename file_length < <(_truncate_filename "$1")

  # Print current FLAC being processed
  _print_item "${file_basename}" "${file_length}" "$3" 'half'

  # Check if file is a FLAC file (hide output)
  metaflac --show-md5sum "${1}" >/dev/null 2>&1

  # Non-zero is failure
  if (( $? != 0 )); then
    # Display error
    _print_status 'fail' "$file_basename" "$file_length"

    # Log header
    if [[ ! -f "$log_file" ]]; then
      printf >  "$log_file" '%s\n' \
        'redoflacs - FLAC image extraction error log'
      printf >> "$log_file" '%.s-' {1..79}
      printf >> "$log_file" '\n'
    fi

    # Log FLAC failure
    printf >> "$log_file" '%s: Not a real FLAC file\n' "${PWD}/${1##*/}"
    printf >> "$issue_ticks" '.'  # Add one tick to total issues
  else
    # Find all the artwork blocks available in the current FLAC file, returned
    # as an array: $artwork[@]
    _find_artwork "$1"

    # Continue only if there were artwork to be extracted
    if [[ -n "${artwork[@]}" ]]; then
      # Determine where to put extracted artwork by checking user config
      if [[ -n "${artwork_location}" ]]; then
        # $artwork_location/file.flac_art
        artwork_directory="${artwork_location}/${1##*/}_art"
      else
        # /path/to/current/flac/file.flac_art
        artwork_directory="${1}_art"
      fi

      # Prevent directory clobbering by creating an incremental version
      until [[ ! -d "${artwork_directory}" ]]; do
        artwork_directory="${artwork_directory%~*~}~$((increment++))~"
      done

      mkdir -p "${artwork_directory}"  # Create artwork directory

      for image in "${artwork[@]}"; do
        # Run through all the artwork found in the current FLAC by looking
        # at $artwork[@], of which, each index looks like:
        #   artwork[0]="${block_id}:${art_id}_${art_desc}.${art_ext}"
        # and extract each image by it's METADATA block number
        #--
        # Prevent file clobbering by creating an incremental version
        increment='1'
        extracted_image="${artwork_directory}/${image#*:}"
        until [[ ! -f "${extracted_image}" ]]; do
          extracted_image="${artwork_directory}/${image#*:}~$((increment++))~"
        done

        # Extract image by the METADATA block number to the art directory
        metaflac \
          --block-number="${image%%:*}" \
          --export-picture-to="${extracted_image}" \
          "$1"
      done
    fi

    # FLAC is ok, display ok
    _print_status 'ok' "${file_basename}" "${file_length}"
  fi
  printf "$4\n" >&3  # Store row position and end operation
}

#
# Prune given FLAC by removing various BLOCKs (defined in user configuration)
#
# $1 is the filename
# $2 is the operation that's currently being run, of which, can be:
#   aucdtect                  md5_check           compress_verify
#   compress_no_test          test                replaygain_test
#   replaygain_force_apply    replaygain_apply    retag_analyze
#   retag_apply               extract_images      prune
# $3 is a string representing number items processed, eg: [43/439]
# $4 is the current operation's row placement
#
_prune()
{
  trap '_kill_jobs "$(jobs -rp)"' EXIT

  # Set up local variables
  declare    file_basename
  declare -i file_length

  # Truncate file, if necessary, and grab file information, splitting on
  # Unit Separator (\037)
  IFS=$'\037' read -r file_basename file_length < <(_truncate_filename "$1")

  # Print current FLAC being processed
  _print_item "${file_basename}" "${file_length}" "$3" 'half'

  # Check if file is a FLAC file (hide output)
  metaflac --show-md5sum "${1}" >/dev/null 2>&1

  # Non-zero is failure
  if (( $? != 0 )); then
    # Display error
    _print_status 'fail' "$file_basename" "$file_length"

    # Log header
    if [[ ! -f "$log_file" ]]; then
      printf >  "$log_file" '%s\n' 'redoflacs - block prune error log'
      printf >> "$log_file" '%.s-' {1..79}
      printf >> "$log_file" '\n'
    fi

    # Log FLAC failure
    printf >> "$log_file" '%s: Not a real FLAC file\n' "${PWD}/${1##*/}"
    printf >> "$issue_ticks" '.'  # Add one tick to total issues
  else
    # Remove all information but STREAMINFO,VORBIS_COMMENTs, and
    # possibly METADATA_BLOCK_PICTURE
    metaflac ${metaflac_extra_options} --remove --dont-use-padding --except-block-type="${dont_prune_flac_metadata}" "${1}"

    # FLAC is ok, display ok
    _print_status 'ok' "${file_basename}" "${file_length}"
  fi
  printf "$4\n" >&3  # Store row position and end operation
}

###################################  SETUP  ###################################

readonly MAX_LENGTH='79'               # Maximum length of output width

shopt -s globstar                      # BASH 4 globstar (eg, /**/*.flac)

version='0.31_pre'                     # Redoflacs version
flac_extension='.[Ff][Ll][Aa][Cc]'     # FLAC extension (case-insensitive)
unit_separator=$'\037'                 # ASCII unit separator

declare -i script_revision='4'         # Script user configuration revision
declare -i max_length                  # Max filename length within terminal
declare -A operation_summary           # Stores all the operational states

# Colors on by default
reset=$'\033[0m'
invert=$'\033[7m'
red=$'\033[31m'
green=$'\033[32m'
yellow=$'\033[33m'
blue=$'\033[34m'
magenta=$'\033[35m'
cyan=$'\033[36m'

#############################  PRE-SCRIPT CHECKS  #############################

# Check if user is running under Cygwin and if so, warn user and exit
if [[ "$(uname -o)" == 'Cygwin' ]]; then
  _error 'This version of redoflacs is meant to be run under\n'
  _error "${cyan}UNIX/Linux/BSD${reset}.  Please use the ${cyan}Windows (Cygwin)${reset}\n"
  _error 'version located here:\n'
  _error "${cyan}https://github.com/sirjaren/redoflacsw${reset}\n"
  exit 1
fi

#------------------------------------------------------------------------------

# Create/source either system or user config
if (( EUID == 0 )); then
  config_file='/etc/redoflacs.conf'               # System (root) config
else
  config_file="${HOME}/.config/redoflacs/config"  # User config
fi

# Check if system-wide configuration doesn't exist
if [[ ! -f "${config_file}" ]]; then
  mkdir -p "${config_file%/*}"  # Create directory if it doesn't exist
  _create_config                # Create configuration file

  _info 'A configuration file has been created here:\n'
  _info "${cyan}${config_file}${reset}\n\n"

  _info 'Please review it before running this program.\n'

  exit 0
else
  _parse_config                 # Parse and source configuration file
fi

#------------------------------------------------------------------------------

# Generate log file location
#--
# Ensure we don't overwrite an existing log file by incrementing the current PID
# by 1 until the log file that is to be set, doesn't exist
pid="$$"
log_file="${error_log}/redoflacs_${pid}.log"

until [[ ! -f "${log_file}" ]]; do
  log_file="${error_log}/redoflacs_log_$((pid++)).log"
done

#------------------------------------------------------------------------------

_process_positional_parameters "${@}"  # Process CLI arguments

#------------------------------------------------------------------------------

# Disable color if user called '-n, --no-color'
[[ "${no_color}" == 'true' ]] && unset -v blue green red cyan magenta yellow

#------------------------------------------------------------------------------

# Make sure we are running BASH 4 or greater
if (( ${BASH_VERSINFO[0]} < 4 )); then
  _error "You must be running ${cyan}BASH 4${reset} or greater to use\n"
  _error '"this program!\n'
  exit 1
fi

#------------------------------------------------------------------------------

# Check for any conflicting operations/arguments called and warn user
_check_conflicting_operations

#------------------------------------------------------------------------------

# For each operation that was selected, add to $operation_summary[@]
for operation in "${operations[@]}"; do
  _update_operation_status "${operation}" 'Operation Did Not Run'
done
#------------------------------------------------------------------------------

_check_missing_programs  # Check for missing programs vital to this script

#------------------------------------------------------------------------------

# Check whether directory exists
if [[ ! -d "${directory}" ]]; then
  printf ' Usage: redoflacs [OPTION] [PATH_TO_FLAC(s)]...\n' >&2
  _error 'Please specify a directory!\n'
  exit 1
fi

#------------------------------------------------------------------------------

# Check for at least 1 FLAC file
read -r find_flacs < <( printf "%s\n" "${directory}"/**/*${flac_extension} )

if [[ ! -f "${find_flacs}" ]]; then
  _error 'There are not any FLAC files to process!\n'
  exit 1
fi

#------------------------------------------------------------------------------

# If '-e, --extract-artwork' was called, make sure $artwork_location is valid
if [[ "${operations[9]}" == 'extract_images' ]]; then
  # Check if artwork_location is user-defined
  if [[ -n "${artwork_location}" ]]; then
    # Put extracted artwork in user-defined location, testing to make sure
    # the directory exists
    if [[ ! -d "${artwork_location}" ]]; then
      _error "${cyan}${artwork_location}${reset} doesn't exist!\n"
      _error 'Please set a valid directory in the configuration file!\n'
      exit 1
    fi
  fi
fi

# If '-A, --aucdtect-spectrogram' was called, make sure $spectrogram_location is
# valid
if [[ "${create_spectrogram}" == 'true' ]]; then
  # Check if spectrogram_location is user-defined
  if [[ -n "${spectrogram_location}" ]]; then
    # Put spectrograms in user-defined location, testing to make sure the
    # directory exists
    if [[ ! -d "${spectrogram_location}" ]]; then
      _error "${cyan}${spectrogram_location}${reset} doesn't exist!\n"
      _error 'Please set a valid directory in the configuration file!\n'
      exit 1
    fi
  fi
fi

#------------------------------------------------------------------------------

# If $jobs wasn't set on invocation, determine the number of jobs to use based
# off of the number of CPU's available
if [[ -z "${jobs}" ]]; then
  _find_cores
else
  jobs_display='(User Defined)'
fi

###################################  MAIN  ####################################

old_stty="$(stty -g)"              # Store current stty settings
stty -ctlecho 2>/dev/null          # Disable ctrl+c '^C'
printf '\033[?25l'                 # Hide cursor
printf '\033[?7l'                  # Disable terminal wrapping

_check_config_version              # Check if script config is newer than user's
job_fifo="/tmp/redoflacs_fifo_$$"  # Job manager FIFO

tmp_aucdtect_fd="/tmp/redoflacs_aucdtect_fifo_$$"    # auCDtect's STDOUT FIFO
trap 'rm -f "${job_fifo}" "${tmp_aucdtect_fd}"' EXIT # Allow for FIFO removal
mkfifo "${tmp_aucdtect_fd}"                          # Create auCDtect FIFO
exec 4<>"${tmp_aucdtect_fd}"                         # Open read/write on fd '4'

issue_ticks="/tmp/redoflacs_issue_file_$$"           # Issues/Errors file

# _retag_apply: Display a countdown
[[ -n "${operations[8]}" ]] && _countdown_metadata

_top_banner                                          # Display top banner

# Total FLACs to process
pushd "$directory" >/dev/null
total_items=( "${PWD}"/**/*${flac_extension} )  # Absolute pathname
popd >/dev/null

# This displays '[ ok ]' after 'Finding FLAC files to process...'
printf "%11s${blue}[ ${green}ok${blue} ]${reset}\n" ''

#------------------------------------------------------------------------------

for operation in "${operations[@]}"; do
  # Loop through the various operations to run.  All the operations are to be
  # run, in order, which is detailed below:
  #   operations[0]='aucdtect'
  #   operations[1]='md5_check'
  #   operations[2]='compress_verify'
  #   operations[3]='compress_no_test'
  #   operations[4]='test'
  #   operations[5]='replaygain_test'
  #   operations[6]='replaygain_force_apply'   # Conditionally set
  #   operations[6]='replaygain_apply'         # Conditionally set
  #   operations[7]='retag_analyze'
  #   operations[8]='retag_apply'
  #   operations[9]='extract_images'
  #   operations[10]='prune'
  #--
  case "${operation}" in
    'replaygain_'*'apply')
      total_items_backup=( "${total_items[@]}" )  # Total FLACs backup array
      _get_directory_list "${total_items[@]}"     # Returns $total_dirs[@]
      total_items=( "${total_dirs[@]}" )          # Now process directories
    ;;
    'prune')
      # Set which FLAC metadata BLOCKS to remove
      if [[ "${remove_artwork}" == 'true' ]]; then
        # Remove PICTURE block
        dont_prune_flac_metadata='STREAMINFO,VORBIS_COMMENT'
      else
        # Do not remove PICTURE block
        dont_prune_flac_metadata='STREAMINFO,PICTURE,VORBIS_COMMENT'
      fi
    ;;
  esac

  _message "${operation}"        # Display title message of current operation
  _scroll_terminal "$(_row)"     # Scroll terminal up (if needed)
  _clear_jobs_fd "${job_fifo}"   # Clear job manager file descriptor (3)

  if (( ${#total_items[@]} < jobs )); then
    # Set row position to place cursor after completing an operation or trap
    #--
    # If the items to process are less than the number of jobs, add the number
    # of items to the current row position, else add the number of jobs to run
    items_processed="${#total_items[@]}"
  else
    items_processed="${jobs}"
  fi

  post_row=$(( $(_row) + items_processed ))  # After operation row position

  trap '_trap_sigint "${operation}"' SIGINT  # Clean exit on SIGINT
  _run_parallel "${operation}"   # Run a given operation with parallel jobs

  for (( i=1; i<=items_processed; i++)); do
    # Clear all the operation lines by moving up each line and clearing it,
    # until we are just below the operation's title message
    #--
    printf "\033[$(( post_row - i))H%${columns}s" ''
  done

  # Display number of finished items minus items with issues
  _message "${operation}" "$(( iteration - $(_num_issues) ))"  # Update title message

  # Update status for the current operation
  _update_operation_status "${operation}" 'Operation Completed'

  if [[ -f "${log_file}" ]]; then
    _message_log_exists "${operation}"  # Print out log exists to STDERR
    _summary                            # Display Summary Of Operations
    exit 1
  fi

  # Restore the items to process from directories to FLACs
  [[ "${operation}" == 'replaygain_'*'apply' ]] && total_items=( "${total_items_backup[@]}" )
done

#------------------------------------------------------------------------------

_summary  # Display Summary Of Operations
