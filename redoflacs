#!/usr/bin/env bash

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You can follow development of this script on Github at:
# https://github.com/sirjaren/redoflacs
#
# Please submit requests/changes/patches and/or comments
#-------------------------------------------------------------------------------
# TODO: When flac releases a new version, create a check for
#       ReplayGain values greater than 48kHz, and abort if flac
#       is 1.2.1 or less
#===============================================================================
# // THIS IS THE CYGWIN VERSION OF REDOFLACS \\
#===============================================================================

tags=(
#-------------------------------------------------------------------------------
#  USER CONFIGURATION
#-------------------------------------------------------------------------------
# List the tags to be kept in each FLAC file
# The default is listed below.
#
# Be sure not to delete the parenthesis ")" below
# or put wanted tags below it!
#
# Another common tag
# not added by default is ALBUMARTIST.  Uncomment
# ALBUMARTIST below to allow script to keep this
# tag.

TITLE
ARTIST
#ALBUMARTIST
ALBUM
DISCNUMBER
DATE
TRACKNUMBER
TRACKTOTAL
GENRE

# The COMPRESSION tag is a custom tag to allow
# the script to determine which level of compression
# the FLAC file(s) has/have been compressed at.
COMPRESSION

# The RELEASETYPE tag is a custom tag the author
# of this script uses to catalogue what kind of
# release the album is (ie, Full Length, EP,
# Demo, etc.).
RELEASETYPE

# The SOURCE tag is a custom tag the author of
# this script uses to catalogue which source the
# album has derived from (ie, CD, Vinyl,
# Digital, etc.).
SOURCE

# The MASTERING tag is a custom tag the author of
# this script uses to catalogue how the album has
# been mastered (ie, Lossless, or Lossy).
MASTERING

# The REPLAYGAIN tags below, are added by the
# '-g, --replaygain' or '-G, --replaygain-noforce'
# argument.  If you want to keep the replaygain
# tags, make sure you leave these here.
REPLAYGAIN_REFERENCE_LOUDNESS
REPLAYGAIN_TRACK_GAIN
REPLAYGAIN_TRACK_PEAK
REPLAYGAIN_ALBUM_GAIN
REPLAYGAIN_ALBUM_PEAK

) # <- DO NOT DELETE PARENTHESIS!

# Set whether to remove embedded artwork within FLAC
# files.  By default, this script will remove any
# artwork it can find, whether it's in the legacy
# COVERART tag or METADATA_BLOCK_PICTURE.  Legal
# values are:
#    "true"  (Remove Artwork)
#    "false" (Keep Artwork)
remove_artwork="true"

# Set the type of COMPRESSION to compress the
# FLAC files.  Numbers range from 1-8, with 1 being
# the lowest compression and 8 being the highest
# compression.  The default is 8.
compression_level=8

# Set the where you want the error logs to
# be placed. By default, they are placed in
# the user's HOME directory.
error_log="${HOME}"

# Set where the created spectrogram files should
# be placed. By default, the spectrogram PNG files
# will be placed in the same directory as the tested
# FLAC files. Each PNG will have the same name as
# the tested FLAC file but with the extension ".png"
#
# The special value, "default" does the default
# action.  Other values are interpreted as a
# directory. An example of a user-defined location:
# spectrogram_location="${HOME}/Spectrogram_Images"
#
# See "--help" or "-h" for more information.
spectrogram_location="default"
#== END USER CONFIGURATION =====================================================


#-------------------------------------------------------------------------------
#  STATIC VARIABLES
#-------------------------------------------------------------------------------
# Version
version="0.18.1_cygwin"

# Various file extensions
export flac_extension=".[Ff][Ll][Aa][Cc]"
export wav_extension=".[Ww][Aa][Vv]"

# Colors on by default
export blue="\033[34m"
export green="\033[32m"
export red="\033[31m"
export cyan="\033[36m"
export magenta="\033[35m"
export yellow="\033[33m"
export normal="\033[0m"

# Log files with timestamp
export verify_errors="${error_log}/FLAC_Verify_Errors_$$.log"
export test_errors="${error_log}/FLAC_Test_Errors_$$.log"
export md5_errors="${error_log}/MD5_Signature_Errors_$$.log"
export metadata_errors="${error_log}/FLAC_Metadata_Errors_$$.log"
export replay_test_errors="${error_log}/ReplayGain_Test_Errors_$$.log"
export replay_add_errors="${error_log}/ReplayGain_Add_Errors_$$.log"
export aucdtect_errors="${error_log}/auCDtect_Errors_$$.log"
export prune_errors="${error_log}/FLAC_Prune_Errors_$$.log"

# Set arguments to null
# If enabled they will be changed to true
export compress_flac=""
export test_flac=""
export aucdtect_flac=""
export md5check_flac=""
export replaygain_flac=""
export retag_flac=""
export prune_flac=""

# Export USER CONFIGURATION variables
export remove_artwork
export compression_level
export error_log
export spectrogram_location
#== END STATIC VARIABLES =======================================================


#-------------------------------------------------------------------------------
#  SCRIPT MESSAGES
#-------------------------------------------------------------------------------
# Bold green message
__info () {
	printf "${normal}%s${green}%s${normal}%s" \
	" " "*" " ${@}"
}
export -f __info

# Yellow message
__warn () {
	printf "${normal}%s${yellow}%s${normal}%s" \
	" " "*" " ${@}"
}
export -f __warn

# Bold red message
__error () {
	printf "${normal}%s${red}%s${normal}%s" \
	" " "*" " ${@}"
}
export -f __error

# No FLACS found error message
__no_flacs () {
	{ __error "There are not any FLAC files to process!" ; __newline ;} >&2
}

# Display why COVERART tag should not be used
__coverart_warning () {
	__newline >&2
	{ __warn "The COVERART tag is deprecated and should not be" ; __newline ;} >&2
	{ __warn "used. Instead, consider migrating over to the new format:" ; __newline ;} >&2
	{ __warn "METADATA_BLOCK_PICTURE, using modern tag editors. Read:" ; __newline ;} >&2
	{ __warn "http://wiki.xiph.org/VorbisComment#Unofficial_COVERART_field_.28deprecated.29" ; __newline ;} >&2
	{ __warn "for more details." ; __newline ;} >&2
}
export -f __coverart_warning

# Display (in bold red) message that system is missing vital programs
__display_missing_commands_header () {
	{ __error "You seem to be missing one or more necessary programs" ; __newline ;} >&2
	{ __error "to run this script reliably.  Below shows the program(s)" ; __newline ;} >&2
	{ __error "missing, as well as where you can install them from:" ; __newline 2 ;} >&2
}

# Display a lot of help
__long_help () {
long_help="  Usage: ${0} [operations] [options] [target] ...
  Operations:
    -c, --compress
           Compress the FLAC files with the user-specified level of compression
           defined under USER CONFIGURATION (as the variable compression_level)
           and verify the resultant files.

           The default is 8, with the range of values starting from 1 to 8 with
           the smallest compression at 1, and the highest at 8.  This option
           will add a tag to all successfully verified FLAC files.  Below
           shows the default COMPRESSION tag added to each successfully
           verified FLAC:

                       COMPRESSION=8

           If any FLAC files already have the defined compression_level tag (a
           good indicator the files are already compressed at that level), the
           script will instead test the FLAC files for any errors.  This is useful
           to check your entire music library to make sure all the FLAC files are
           compressed at the level specified as well as make sure they are intact.

           If any files are found to be corrupt, this script will quit upon
           finishing the compression of any other files and produce an error
           log.

    -C, --compress-notest
           Same as the '--compress' option, but if any FLAC files already have the
           defined compression_level tag, the script will skip the file and continue
           on to the next without test the FLAC file's integrity.  Useful for
           checking all your FLAC files are compressed at the level specified.

    -t, --test
           Same as compress but instead of compressing the FLAC files, this
           script just verfies the files.  This option will NOT add the
           COMPRESSION tag to the files.

           As with the '--compress' option, this will produce an error log if
           any FLAC files are found to be corrupt.

    -a, --aucdtect
           Uses the auCDtect program by Oleg Berngardt and Alexander Djourik to
           analyze FLAC files and check with fairly accurate precision whether
           the FLAC files are lossy sourced or not.  For example, an MP3 file
           converted to FLAC is no longer lossless therefore lossy sourced.

           While this program isn't foolproof, it gives a good idea which FLAC
           files will need further investigation (ie a spectrogram).  This program
           does not work on FLAC files which have a bit depth more than a typical
           audio CD (16bit), and will skip the files that have a higher bit depth.

           If any files are found to not be perfect (100% CDDA), a log will be created
           with the questionable FLAC files recorded in it.

    -A, --aucdtect-spectrogram
           Same as '-a, --aucdtect' with the addition of creating a spectrogram for
           each FLAC file that fails auCDtect, that is, any FLAC file that does not
           return 100% CDDA from auCDtect will be scanned and a spectrogram will be
           created.

           Any FLAC file skipped (due to having a higher bit depth than 16), will
           NOT have a spectrogram created.

           By default, each spectrogram will be created in the same folder as the
           tested FLAC file with the same name as the tested FLAC file:

               03 - Some FLAC File.flac --> 03 - Some FLAC File.png

           If there already is a PNG file with the same name as the tested FLAC,
           the name 'spectrogram' will prepend the '.png' extension:

               03 - Some FLAC File.flac --> 03 - Some FLAC File.spectrogram.png

           The user can change the location of where to store the created
           spectrogram images by changing the value of spectrogram_location under
           the USER CONFIGURATION section of this script.  The location defined by
           the user will be tested to see if it exists before starting the script.
           If the location does NOT exist, the script will warn the user and exit.

           The created PNG file is large in resolution to best capture the
           FLAC file's waveform (roughly 5140x2149).

           The spectrogram is created using the program SoX.  If the user tries
           to use this option without having SoX installed, the script will warn
           the user that SoX is missing and exit.

    -m, --md5check
           Check the FLAC files for unset MD5 Signatures and log the output of
           any unset signatures.  An unset MD5 signature doesn't necessarily mean
           a FLAC file is corrupt, and can be repaired with a re-encoding of said
           FLAC file.

    -p, --prune
           Delete every METADATA block in each FLAC file except the STREAMINFO and
           VORBIS_COMMENT block.  If remove_artwork is set to 'false', then the
           PICTURE block will NOT be removed.

    -g, --replaygain
           Add ReplayGain tags to the FLAC files.  The ReplayGain is calculated
           for ALBUM and TRACK values. ReplayGain is applied via VORBIS_TAGS and
           as such, will require the redo, '--r argument' to have these tags kept
           in order to preserve the added ReplayGain values.  The tags added are:

                      REPLAYGAIN_REFERENCE_LOUDNESS
                      REPLAYGAIN_TRACK_GAIN
                      REPLAYGAIN_TRACK_PEAK
                      REPLAYGAIN_ALBUM_GAIN
                      REPLAYGAIN_ALBUM_PEAK

           This option ignores any ReplayGain tags that may already be set,
           removing existing values before applying new ones.

           In order for the ReplayGain values to be applied correctly, the
           script has to determine which FLAC files to add values by directory.
           What this means is that the script must add the ReplayGain values by
           working off the FLAC files' parent directory.  If there are some FLAC
           files found, the script will move up one directory and begin applying
           the ReplayGain values.  This is necessary in order to get the
           REPLAYGAIN_ALBUM_GAIN and REPLAYGAIN_ALBUM_PEAK values set correctly.
           Without doing this, the ALBUM and TRACK values would be identical.

           If a user has many FLAC files under one directory (of different
           albums/artists), the ReplayGain ALBUM values are going to be incorrect
           as the script will perceive all those FLAC files to essentially be
           from the same album.  This is mitigated by having your music library
           somewhat organized with each album housing the correct FLAC files and
           no others.  Keep in mind, multi-disc albums must be in separate folders
           in order to be processed with different ALBUM GAIN and PEAK values.

           If there are any errors found while creating the ReplayGain values
           and/or setting the values, an error log will be produced.

    -G, --replaygain-noforce
           Same as '-g, --replaygain' but will check for existing ReplayGain
           tags before reapplying new ones.  If any one of the five ReplayGain
           tags are missing from any FLAC file, the script will apply new values
           to each FLAC file in that folder (first removing the old ReplayGain
           tags - if any).

           If all five ReplayGain tags are intact in every FLAC
           file in a directory, that directory will be skipped and no new
           ReplayGain tags will be added.

    -r, --redo
           Extract the configured tags in each FLAC file and clear the rest before
           retagging the file.  The default tags kept are:

                      TITLE
                      ARTIST
                      ALBUM
                      DISCNUMBER
                      DATE
                      TRACKNUMBER
                      TRACKTOTAL
                      GENRE
                      COMPRESSION
                      RELEASETYPE
                      SOURCE
                      MASTERING
                      REPLAYGAIN_REFERENCE_LOUDNESS
                      REPLAYGAIN_TRACK_GAIN
                      REPLAYGAIN_TRACK_PEAK
                      REPLAYGAIN_ALBUM_GAIN
                      REPLAYGAIN_ALBUM_PEAK

           If any FLAC files have missing tags (from those configured to be kept),
           the file and the missing tag will be recorded in a log.

           The tags that can be kept are eseentially infinite, as long as the
           tags to be kept are set in the tag configuration located at the top of
           this script under USER CONFIGURATION.

           If this option is specified, a warning will appear upon script
           execution.  This warning will show which of the configured TAG fields
           to keep when re-tagging the FLAC files.  A countdown will appear
           giving the user 10 seconds to abort the script, after which, the script
           will begin running it's course.

    -l, --all
           This option is short for:

                      -c, --compress
                      -m, --md5check
                      -p, --prune
                      -g, --replaygain
                      -r, --redo

           If any of these options (or variations of the above options) are called, this
           script will warn the user of conflicting options and exit.

    -L, --reallyall
           This option is short for:

                      -c, --compress
                      -m, --md5check
                      -p, --prune
                      -g, --replaygain
                      -r, --redo
                      -A, --aucdtect-spectrogram

           If any of these options (or variations of the above options) are called, this
           script will warn the user of conflicting options and exit.

  Options:
    -j[N], --jobs[=N]
           Set the number of parallel jobs to run on script invocation.  If this is not set,
           this script will attempt to find the number of CPU cores available, using the number
           found as the number of parallel jobs to run.

           If the script is unable to find the number of CPU cores available, the number of jobs
           will be set to two (2) by default.

    -n, --no-color
           Turn off color output.

    -v, --version
           Display script version and exit.

    -h, --help
           Shows this help message."

# Print out help (will be piped to ${PAGER} elsewhere)
printf "%s\n" "${long_help}"
}

# Display short help
__short_help () {
	printf "%s\n" " Usage: ${0} [operations] [options] [target] ..."
	printf "%s\n" " Operations:"
	printf "%s\n" "   -c, --compress"
	printf "%s\n" "   -C, --compress-notest"
	printf "%s\n" "   -t, --test"
	printf "%s\n" "   -m, --md5check"
	printf "%s\n" "   -a, --aucdtect"
	printf "%s\n" "   -A, --aucdtect-spectrogram"
	printf "%s\n" "   -p, --prune"
	printf "%s\n" "   -g, --replaygain"
	printf "%s\n" "   -G, --replaygain-noforce"
	printf "%s\n" "   -r, --redo"
	printf "%s\n" "   -l, --all"
	printf "%s\n" "   -L, --reallyall"
	printf "%s\n" " Options:"
	printf "%s\n" "   -j[N], --jobs[=N]"
	printf "%s\n" "   -n, --no-color"
	printf "%s\n" "   -v, --version"
	printf "%s\n" "   -h, --help"
	printf "%s\n" " This is the short help; for details use '${0} --help' or '${0} -h'"
}

# Display usage
__usage () {
	printf "%s\n" " Usage: ${0} [operations] [options] [target] ..."
}
#== END SCRIPT MESSAGES ========================================================


#-------------------------------------------------------------------------------
#  LOG MESSAGES
#-------------------------------------------------------------------------------
# ReplayGain test error log message
__log_replaygain_test () {
	__newline >&2
	{ __error "There were issues with some of the FLAC files," ; __newline ;} >&2
	{ __error "please check:" ; __newline ;} >&2
	{ __error "\"${replay_test_errors}\" for details." ; __newline ;} >&2
}

# ReplayGain process error log message
__log_replaygain_process () {
	__newline >&2
	{ __error "There were issues adding ReplayGain values," ; __newline ;} >&2
	{ __error "please check:" ; __newline ;} >&2
	{ __error "\"${replay_add_errors}\" for details." ; __newline ;} >&2
}

# Compress and verify error log message
__log_compress_verify () {
	__newline >&2
	{ __error "Errors found in some FLAC files, please check:" ; __newline ;} >&2
	{ __error "\"${verify_errors}\" for errors" ; __newline ;} >&2
}

# Test error log message
__log_test () {
	__newline >&2
	{ __error "Errors found in some FLAC files, please check:" ; __newline ;} >&2
	{ __error "\"${test_errors}\" for errors" ; __newline ;} >&2
}

# auCDtect error log message
__log_aucdtect () {
	__newline >&2
	{ __error "Some FLAC files may be lossy sourced, please check:" ; __newline ;} >&2
	{ __error "\"${aucdtect_errors}\" for details" ; __newline ;} >&2
}

# MD5 check error log message
__log_md5_check () {
	__newline >&2
	{ __error "The MD5 Signature is unset for some FLAC files or there were" ; __newline ;} >&2
	{ __error "issues with some of the FLAC files, please check:" ; __newline ;} >&2
	{ __error "\"${md5_errors}\" for details" ; __newline ;} >&2
}

# Missing tags error log message
__log_missing_tags () {
	__newline >&2
	{ __error "Some FLAC files have missing tags or there were" ; __newline ;} >&2
	{ __error "issues with some of the FLAC files, please check:" ; __newline ;} >&2
	{ __error "\"${metadata_errors}\" for details." ; __newline ;} >&2
	{ __error "Not Re-Tagging files." ; __newline ;} >&2
}

# Prune error log message
__log_prune () {
	__newline >&2
	{ __error "There were issues with some of the FLAC files," ; __newline ;} >&2
	{ __error "please check:" ; __newline ;} >&2
	{ __error "\"${prune_errors}\" for details." ; __newline ;} >&2
}
#== END LOG MESSAGES ===========================================================


#-------------------------------------------------------------------------------
#  TITLE MESSAGES
#-------------------------------------------------------------------------------
# Compress FLACS & verify
__title_compress_flac () {
	__newline
	__info "Compressing & Verifying FLAC Files :: "
	printf "${cyan}%s${normal}\n" "[Compression: ${compression_level}]"
}

# Compress FLACS & no verify
__title_compress_notest_flac () {
	__newline
	__info "Compressing FLAC Files :: "
	printf "${cyan}%s${normal}\n" "[Compression: ${compression_level}]"
}

# Apply ReplayGain to FLACS
__title_replaygain () {
	__newline
	__info "Generating & Applying ReplayGain" ; __newline
}

# Retag FLACS
__title_retag () {
	__newline
	__info "Retagging FLAC Files" ; __newline
}

# Testing FLACS
__title_testing_flac () {
	__newline
	__info "Testing FLAC Files" ; __newline
}

# Validating FLACS with auCDtect
__title_aucdtect_flac () {
	__newline
	__info "Validating FLAC Files with auCDtect" ; __newline
}

# Checking MD5 of FLACS
__title_md5check_flac () {
	__newline
	__info "Checking MD5 Signature" ; __newline
}

# Pruning FLACS
__title_prune_flac () {
	# Change printed title based on whether embedded artwork is to be removed
	if [[ "${remove_artwork}" == "false" ]] ; then
		# Keep artwork
		local metadata_removed="STREAMINFO, VORBIS_COMMENT and PICTURE"
	else
		# Remove artwork
		local metadata_removed="STREAMINFO and VORBIS_COMMENT"
	fi

	__newline
	__info "Pruning blocks except ${metadata_removed}" ; __newline
}
#== END TITLE MESSAGES =========================================================


#-------------------------------------------------------------------------------
#  SUB MESSAGES
#-------------------------------------------------------------------------------
# Test for ReplayGain
__sub_test_replaygain () {
	printf "%s${green}%s${normal}%s${normal}%s${normal}\n" \
	"   " ">" " " "Testing ReplayGain"
}

# Adding ReplayGain values
__sub_add_replaygain () {
	printf "%s${green}%s${normal}%s${normal}%s${normal}\n" \
	"   " ">" " " "Adding ReplayGain"
}

# Analyze FLAC tags
__sub_analyze_tags () {
	printf "%s${green}%s${normal}%s${normal}%s${normal}\n" \
	"   " ">" " " "Analyze Tags"
}

# Applying new tags
__sub_applying_tags () {
	printf "%s${green}%s${normal}%s${normal}%s${normal}\n" \
	"   " ">" " " "Applying Tags"
}
#== END SUB MESSAGES ===========================================================


#-------------------------------------------------------------------------------
#  PROCESSED FILE/DIRECTORY MESSAGES
#-------------------------------------------------------------------------------
# Compressing
__print_compressing_flac () {
	# Obtain the number of columns returned as ${columns}
	__columns

	# This is the maximum length of a string to be displayed based on column width,
	# obtained via the number of columns minus the length of displayed characters:
	#
	#             ${columns}:  Width of terminal
	#          ${#iteration}:  Length of the # of FLACs processed
	#  ${total_flacs_length}:  Length of the total # of FLAC files
	#                     30:  Length of:
	#                            [ Compressing FLAC ] (20)
	#                            5 Spaces
	#                            3 Characters: [/]
	#                            2 Gap and ellipsis (…)
	max_filename_length="$(( ${columns} - ${#iteration} - ${total_flacs_length} - 30 ))"

	# Create and cull filename if needed returned as ${filename}
	__filename

	printf "\r${normal}%s${magenta}%s${normal}%s%$(__current_length)s${blue}%s${normal}%s${yellow}%s${normal}%s${blue}%s${normal}%s" \
	"   " "[${iteration}/${total_flacs}]" " ${filename} " "" "[" " " "Compressing FLAC" " " "]" " "
}

# Testing ReplayGain
__print_test_replaygain () {
	# Obtain the number of columns returned as ${columns}
	__columns

	# This is the maximum length of a string to be displayed based on column width,
	# obtained via the number of columns minus the length of displayed characters:
	#
	#             ${columns}:  Width of terminal
	#          ${#iteration}:  Length of the # of FLACs processed
	#  ${total_flacs_length}:  Length of the total # of FLAC files
	#                     34:  Length of:
	#                            [ Testing ReplayGain ] (22)
	#                            7 Spaces
	#                            3 Characters: [/]
	#                            2 Gap and ellipsis (…)
	max_filename_length="$(( ${columns} - ${#iteration} - ${total_flacs_length} - 34 ))"

	# Create and cull filename if needed returned as ${filename}
	__filename

	printf "\r${normal}%s${magenta}%s${normal}%s%$(__current_length)s${blue}%s${normal}%s${yellow}%s${normal}%s${blue}%s${normal}%s" \
	"     " "[${iteration}/${total_flacs}]" " ${filename} " "" "[" " " "Testing ReplayGain" " " "]" " "
}

# Applying ReplayGain
__print_add_replaygain () {
	# Obtain the number of columns returned as ${columns}
	__columns

	# This is the maximum length of a string to be displayed based on column width,
	# obtained via the number of columns minus the length of displayed characters:
	#
	#             ${columns}:  Width of terminal
	#          ${#iteration}:  Length of the # processed directories
	#  ${#total_directories}:  Length of the total # of directories
	#                     33:  Length of:
	#                            [ Adding ReplayGain ] (21)
	#                            7 Spaces
	#                            3 Characters: [/]
	#                            2 Gap and ellipsis (…)
	max_filename_length="$(( ${columns} - ${#iteration} - ${#total_directories} - 33 ))"

	# Create and cull filename if needed returned as ${filename}
	__filename

	printf "\r${normal}%s${magenta}%s${normal}%s%$(__current_length)s${blue}%s${normal}%s${yellow}%s${normal}%s${blue}%s${normal}%s" \
	"     " "[${iteration}/${total_directories}]" " ${filename} " "" "[" " " "Adding ReplayGain" " " "]" " "
}

# Testing
__print_testing_flac () {
	# Obtain the number of columns returned as ${columns}
	__columns

	# This is the maximum length of a string to be displayed based on column width,
	# obtained via the number of columns minus the length of displayed characters:
	#
	#             ${columns}:  Width of terminal
	#          ${#iteration}:  Length of the # of FLACs processed
	#  ${total_flacs_length}:  Length of the total # of FLAC files
	#                     26:  Length of:
	#                            [ Testing FLAC ] (16)
	#                            5 Spaces
	#                            3 Characters: [/]
	#                            2 Gap and ellipsis (…)
	max_filename_length="$(( ${columns} - ${#iteration} - ${total_flacs_length} - 26 ))"

	# Create and cull filename if needed returned as ${filename}
	__filename

	printf "\r${normal}%s${magenta}%s${normal}%s%$(__current_length)s${blue}%s${normal}%s${yellow}%s${normal}%s${blue}%s${normal}%s" \
	"   " "[${iteration}/${total_flacs}]" " ${filename} " "" "[" " " "Testing FLAC" " " "]" " "
}

# Failed
__print_failed_flac () {
	# Obtain the number of columns returned as ${columns}
	__columns

	# This is the maximum length of a string to be displayed based on column width,
	# obtained via the number of columns minus the length of displayed characters:
	#
	#             ${columns}:  Width of terminal
	#          ${#iteration}:  Length of the # of FLACs processed
	#  ${total_flacs_length}:  Length of the total # of FLAC files
	#                     20:  Length of:
	#                            [ Failed ] (10)
	#                            7 Spaces
	#                            1 Asterisk: *
	#                            2 Gap and ellipsis (…)
	max_filename_length="$(( ${columns} - 20 ))"

	# Create and cull filename if needed returned as ${filename}
	__filename

	printf "\r${normal}%s${red}%s${normal}%s%$(__current_length)s${blue}%s${normal}%s${red}%s${normal}%s${blue}%s${normal}%s\n" \
	"     " "*" " ${filename} " "" "[" " " "Failed" " " "]" " "
}

# Checking MD5
__print_checking_md5 () {
	# Obtain the number of columns returned as ${columns}
	__columns

	# This is the maximum length of a string to be displayed based on column width,
	# obtained via the number of columns minus the length of displayed characters:
	#
	#             ${columns}:  Width of terminal
	#          ${#iteration}:  Length of the # of FLACs processed
	#  ${total_flacs_length}:  Length of the total # of FLAC files
	#                     26:  Length of:
	#                            [ Checking MD5 ] (16)
	#                            5 Spaces
	#                            3 Characters: [/]
	#                            2 Gap and ellipsis (…)
	max_filename_length="$(( ${columns} - ${#iteration} - ${total_flacs_length} - 26 ))"

	# Create and cull filename if needed returned as ${filename}
	__filename

	printf "\r${normal}%s${magenta}%s${normal}%s%$(__current_length)s${blue}%s${normal}%s${yellow}%s${normal}%s${blue}%s${normal}%s" \
	"   " "[${iteration}/${total_flacs}]" " ${filename} " "" "[" " " "Checking MD5" " " "]" " "
}

# File ok
__print_ok_flac () {
	# Obtain the number of columns returned as ${columns}
	__columns

	# Obtain iteration and filename
	# for the displayed message below
	__obtain_count_filename

	# This is the maximum length of a string to be displayed based on column width,
	# obtained via the number of columns minus the length of displayed characters:
	#
	#             ${columns}:  Width of terminal
	#          ${#iteration}:  Length of the # of FLACs processed
	#  ${total_flacs_length}:  Length of the total # of FLAC files
	#                     16:  Length of:
	#                            [ ok ] (6)
	#                            5 Spaces
	#                            3 Characters: [/]
	#                            2 Gap and ellipsis (…)
	max_filename_length="$(( ${columns} - ${#iteration} - ${total_flacs_length} - 16 ))"

	# Create and cull filename if needed returned as ${filename}
	__filename

	printf "\r${normal}%s${magenta}%s${normal}%s%$(__current_length)s${blue}%s${normal}%s${green}%s${normal}%s${blue}%s${normal}%s" \
	"   " "[${iteration}/${total_flacs}]" " ${filename} " "" "[" " " "ok" " " "]" " "
}

# ReplayGain file ok
__print_ok_replaygain_file () {
	# Obtain the number of columns returned as ${columns}
	__columns

	# Obtain iteration and filename
	# for the displayed message below
	__obtain_count_filename

	# This is the maximum length of a string to be displayed based on column width,
	# obtained via the number of columns minus the length of displayed characters:
	#
	#             ${columns}:  Width of terminal
	#          ${#iteration}:  Length of the # of FLACs processed
	#  ${total_flacs_length}:  Length of the total # of FLAC files
	#                     18:  Length of:
	#                            [ ok ] (6)
	#                            7 Spaces
	#                            3 Characters: [/]
	#                            2 Gap and ellipsis (…)
	max_filename_length="$(( ${columns} - ${#iteration} - ${total_flacs_length} - 18 ))"

	# Create and cull filename if needed returned as ${filename}
	__filename

	printf "\r${normal}%s${magenta}%s${normal}%s%$(__current_length)s${blue}%s${normal}%s${green}%s${normal}%s${blue}%s${normal}%s" \
	"     " "[${iteration}/${total_flacs}]" " ${filename} " "" "[" " " "ok" " " "]" " "
}

# ReplayGain file interrupted
__print_interrupt_replaygain_file () {
	# Obtain the number of columns returned as ${columns}
	__columns

	# This is the maximum length of a string to be displayed based on column width,
	# obtained via the number of columns minus the length of displayed characters:
	#
	#             ${columns}:  Width of terminal
	#          ${#iteration}:  Length of the # of FLACs processed
	#  ${total_flacs_length}:  Length of the total # of FLAC files
	#                     27:  Length of:
	#                            [ Interrupted ] (15)
	#                            7 Spaces
	#                            3 Characters: [/]
	#                            2 Gap and ellipsis (…)
	max_filename_length="$(( ${columns} - ${#iteration} - ${total_flacs_length} - 27 ))"

	# Create and cull filename if needed returned as ${filename}
	__filename

	printf "\r${normal}%s${magenta}%s${normal}%s%$(__current_length)s${blue}%s${normal}%s${yellow}%s${normal}%s${blue}%s${normal}%s" \
	"     " "[${iteration}/${total_flacs}]" " ${filename} " "" "[" " " "Interrupted" " " "]" " "
}

# ReplayGain directory ok
__print_ok_replaygain_dir () {
	# Obtain the number of columns returned as ${columns}
	__columns

	# Obtain iteration and filename
	# for the displayed message below
	__obtain_count_filename

	# This is the maximum length of a string to be displayed based on column width,
	# obtained via the number of columns minus the length of displayed characters:
	#
	#             ${columns}:  Width of terminal
	#          ${#iteration}:  Length of the # of processed directories
	#  ${#total_directories}:  Length of the total # of directories
	#                     18:  Length of:
	#                            [ ok ] (6)
	#                            7 Spaces
	#                            3 Characters: [/]
	#                            2 Gap and ellipsis (…)
	max_filename_length="$(( ${columns} - ${#iteration} - ${#total_directories} - 18 ))"

	# Create and cull filename if needed returned as ${filename}
	__filename

	printf "\r${normal}%s${magenta}%s${normal}%s%$(__current_length)s${blue}%s${normal}%s${green}%s${normal}%s${blue}%s${normal}%s" \
	"     " "[${iteration}/${total_directories}]" " ${filename} " "" "[" " " "ok" " " "]" " "
}

# ReplayGain directory interrupted
__print_interrupt_replaygain_dir () {
	# Obtain the number of columns returned as ${columns}
	__columns

	# This is the maximum length of a string to be displayed based on column width,
	# obtained via the number of columns minus the length of displayed characters:
	#
	#             ${columns}:  Width of terminal
	#          ${#iteration}:  Length of the # processed directories
	#  ${#total_directories}:  Length of the total # of directories
	#                     27:  Length of:
	#                            [ Interrupted ] (15)
	#                            7 Spaces
	#                            3 Characters: [/]
	#                            2 Gap and ellipsis (…)
	max_filename_length="$(( ${columns} - ${#iteration} - ${#total_directories} - 27 ))"

	# Create and cull filename if needed returned as ${filename}
	__filename

	printf "\r${normal}%s${magenta}%s${normal}%s%$(__current_length)s${blue}%s${normal}%s${yellow}%s${normal}%s${blue}%s${normal}%s" \
	"     " "[${iteration}/${flac_directories}]" " ${filename} " "" "[" " " "Interrupted" " " "]" " "
}

# ReplayGain directory failed
__print_failed_replaygain () {
	# Obtain the number of columns returned as ${columns}
	__columns

	# This is the maximum length of a string to be displayed based on column width,
	# obtained via the number of columns minus the length of displayed characters:
	#
	#             ${columns}:  Width of terminal
	#          ${#iteration}:  Length of the # processed directories
	#  ${#total_directories}:  Length of the total # of directories
	#                     20:  Length of:
	#                            [ Failed ] (10)
	#                            7 Spaces
	#                            1 Characters: *
	#                            2 Gap and ellipsis (…)
	max_filename_length="$(( ${columns} - ${#iteration} - ${#total_directories} - 20 ))"

	# Create and cull filename if needed returned as ${filename}
	__filename

	printf "\r${normal}%s${red}%s${normal}%s%$(__current_length)s${blue}%s${normal}%s${red}%s${normal}%s${blue}%s${normal}%s\n" \
	"     " "*" " ${filename} " "" "[" " " "Failed" " " "]" " "
}

# Validating with auCDtect
__print_aucdtect_flac () {
	# Obtain the number of columns returned as ${columns}
	__columns

	# This is the maximum length of a string to be displayed based on column width,
	# obtained via the number of columns minus the length of displayed characters:
	#
	#             ${columns}:  Width of terminal
	#          ${#iteration}:  Length of the # of FLACs processed
	#  ${total_flacs_length}:  Length of the total # of FLAC files
	#                     29:  Length of:
	#                            [ Validating FLAC ] (19)
	#                            5 Spaces
	#                            3 Characters: [/]
	#                            2 Gap and ellipsis (…)
	max_filename_length="$(( ${columns} - ${#iteration} - ${total_flacs_length} - 29 ))"

	# Create and cull filename if needed returned as ${filename}
	__filename

	printf "\r${normal}%s${magenta}%s${normal}%s%$(__current_length)s${blue}%s${normal}%s${yellow}%s${normal}%s${blue}%s${normal}%s" \
	"   " "[${iteration}/${total_flacs}]" " ${filename} " "" "[" " " "Validating FLAC" " " "]" " "
}

# auCDtect issue
__print_aucdtect_issue () {
	# Obtain the number of columns returned as ${columns}
	__columns

	# This is the maximum length of a string to be displayed based on column width,
	# obtained via the number of columns minus the length of displayed characters:
	#
	#             ${columns}:  Width of terminal
	#          ${#iteration}:  Length of the # of FLACs processed
	#  ${total_flacs_length}:  Length of the total # of FLAC files
	#                     19:  Length of:
	#                            [ Issue ] (9)
	#                            7 Spaces
	#                            1 Asterisk: *
	#                            2 Gap and ellipsis (…)
	max_filename_length="$(( ${columns} - 19 ))"

	# Create and cull filename if needed returned as ${filename}
	__filename

	printf "\r${normal}%s${yellow}%s${normal}%s%$(__current_length)s${blue}%s${normal}%s${yellow}%s${normal}%s${blue}%s${normal}%s\n" \
	"     " "*" " ${filename} " "" "[" " " "Issue" " " "]" " "
}

# auCDtect spectrogram
__print_aucdtect_spectrogram () {
	# Obtain the number of columns returned as ${columns}
	__columns

	# This is the maximum length of a string to be displayed based on column width,
	# obtained via the number of columns minus the length of displayed characters:
	#
	#             ${columns}:  Width of terminal
	#          ${#iteration}:  Length of the # of FLACs processed
	#  ${total_flacs_length}:  Length of the total # of FLAC files
	#                     34:  Length of:
	#                            [ Creating Spectrogram ] (24)
	#                            5 Spaces
	#                            3 Characters: [/]
	#                            2 Gap and ellipsis (…)
	max_filename_length="$(( ${columns} - ${#iteration} - ${total_flacs_length} - 34 ))"

	# Create and cull filename if needed returned as ${filename}
	__filename

	printf "\r${normal}%s${magenta}%s${normal}%s%$(__current_length)s${blue}%s${normal}%s${yellow}%s${normal}%s${blue}%s${normal}%s" \
	"   " "[${iteration}/${total_flacs}]" " ${filename} " "" "[" " " "Creating Spectrogram" " " "]" " "
}

# auCDtect skip
__print_aucdtect_skip () {
	# Obtain the number of columns returned as ${columns}
	__columns

	# This is the maximum length of a string to be displayed based on column width,
	# obtained via the number of columns minus the length of displayed characters:
	#
	#             ${columns}:  Width of terminal
	#          ${#iteration}:  Length of the # of FLACs processed
	#  ${total_flacs_length}:  Length of the total # of FLAC files
	#                     21:  Length of:
	#                            [ Skipped ] (11)
	#                            7 Spaces
	#                            1 Asterisk: *
	#                            2 Gap and ellipsis (…)
	max_filename_length="$(( ${columns} - 21 ))"

	# Create and cull filename if needed returned as ${filename}
	__filename

	printf "\r${normal}%s${red}%s${normal}%s%$(__current_length)s${blue}%s${normal}%s${yellow}%s${normal}%s${blue}%s${normal}%s\n" \
	"     " "*" " ${filename} " "" "[" " " "Skipped" " " "]" " "
}

# Tag ok
__print_ok_tag () {
	# Obtain the number of columns returned as ${columns}
	__columns

	# Obtain iteration and filename
	# for the displayed message below
	__obtain_count_filename

	# This is the maximum length of a string to be displayed based on column width,
	# obtained via the number of columns minus the length of displayed characters:
	#
	#             ${columns}:  Width of terminal
	#          ${#iteration}:  Length of the # of FLACs processed
	#  ${total_flacs_length}:  Length of the total # of FLAC files
	#                     18:  Length of:
	#                            [ ok ] (6)
	#                            7 Spaces
	#                            3 Characters: [/]
	#                            2 Gap and ellipsis (…)
	max_filename_length="$(( ${columns} - ${#iteration} - ${total_flacs_length} - 18 ))"

	# Create and cull filename if needed returned as ${filename}
	__filename

	printf "\r${normal}%s${magenta}%s${normal}%s%$(__current_length)s${blue}%s${normal}%s${green}%s${normal}%s${blue}%s${normal}%s" \
	"     " "[${iteration}/${total_flacs}]" " ${filename} " "" "[" " " "ok" " " "]" " "
}

# Compression level the same
__print_level_same_compression () {
	# Obtain the number of columns returned as ${columns}
	__columns

	# This is the maximum length of a string to be displayed based on column width,
	# obtained via the number of columns minus the length of displayed characters:
	#
	#             ${columns}:  Width of terminal
	#          ${#iteration}:  Length of the # of FLACs processed
	#  ${total_flacs_length}:  Length of the total # of FLAC files
	#                     32:  Length of:
	#                            [ Already At Level ${compression_level} ] (22)
	#                            5 Spaces
	#                            3 Characters: [/]
	#                            2 Gap and ellipsis (…)
	max_filename_length="$(( ${columns} - ${#iteration} - ${total_flacs_length} - 32 ))"

	# Create and cull filename if needed returned as ${filename}
	__filename

	printf "\r${normal}%s${magenta}%s${normal}%s%$(__current_length)s${blue}%s${normal}%s${yellow}%s${normal}%s${blue}%s${normal}%s" \
	"   " "[${iteration}/${total_flacs}]" " ${filename} " "" "[" " " "Already At Level ${compression_level}" " " "]" " "
}

# Analyzing tags
__print_analyzing_tags () {
	# Obtain the number of columns returned as ${columns}
	__columns

	# This is the maximum length of a string to be displayed based on column width,
	# obtained via the number of columns minus the length of displayed characters:
	#
	#             ${columns}:  Width of terminal
	#          ${#iteration}:  Length of the # of FLACs processed
	#  ${total_flacs_length}:  Length of the total # of FLAC files
	#                     30:  Length of:
	#                            [ Analyzing Tags ] (18)
	#                            7 Spaces
	#                            3 Characters: [/]
	#                            2 Gap and ellipsis (…)
	max_filename_length="$(( ${columns} - ${#iteration} - ${total_flacs_length} - 30 ))"

	# Create and cull filename if needed returned as ${filename}
	__filename

	printf "\r${normal}%s${magenta}%s${normal}%s%$(__current_length)s${blue}%s${normal}%s${yellow}%s${normal}%s${blue}%s${normal}%s" \
	"     " "[${iteration}/${total_flacs}]" " ${filename} " "" "[" " " "Analyzing Tags" " " "]" " "
}

# Applying tags
__print_applying_tags () {
	# Obtain the number of columns returned as ${columns}
	__columns

	# This is the maximum length of a string to be displayed based on column width,
	# obtained via the number of columns minus the length of displayed characters:
	#
	#             ${columns}:  Width of terminal
	#          ${#iteration}:  Length of the # of FLACs processed
	#  ${total_flacs_length}:  Length of the total # of FLAC files
	#                     29:  Length of:
	#                            [ Applying Tags ] (17)
	#                            7 Spaces
	#                            3 Characters: [/]
	#                            2 Gap and ellipsis (…)
	max_filename_length="$(( ${columns} - ${#iteration} - ${total_flacs_length} - 29 ))"

	# Create and cull filename if needed returned as ${filename}
	__filename

	printf "\r${normal}%s${magenta}%s${normal}%s%$(__current_length)s${blue}%s${normal}%s${yellow}%s${normal}%s${blue}%s${normal}%s" \
	"     " "[${iteration}/${total_flacs}]" " ${filename} " "" "[" " " "Applying Tags" " " "]" " "
}

# Pruning
__print_prune_flac () {
	# Obtain the number of columns returned as ${columns}
	__columns

	# This is the maximum length of a string to be displayed based on column width,
	# obtained via the number of columns minus the length of displayed characters:
	#
	#             ${columns}:  Width of terminal
	#          ${#iteration}:  Length of the # of FLACs processed
	#  ${total_flacs_length}:  Length of the total # of FLAC files
	#                     30:  Length of:
	#                            [ Pruning Metadata ] (20)
	#                            5 Spaces
	#                            3 Characters: [/]
	#                            2 Gap and ellipsis (…)
	max_filename_length="$(( ${columns} - ${#iteration} - ${total_flacs_length} - 30 ))"

	# Create and cull filename if needed returned as ${filename}
	__filename

	printf "\r${normal}%s${magenta}%s${normal}%s%$(__current_length)s${blue}%s${normal}%s${yellow}%s${normal}%s${blue}%s${normal}%s" \
	"   " "[${iteration}/${total_flacs}]" " ${filename} " "" "[" " " "Pruning Metadata" " " "]" " "
}

# Retag analyze interrupted
__print_retag_analyze_interrupt () {
	# Obtain the number of columns returned as ${columns}
	__columns

	# This is the maximum length of a string to be displayed based on column width,
	# obtained via the number of columns minus the length of displayed characters:
	#
	#             ${columns}:  Width of terminal
	#          ${#iteration}:  Length of the # of FLACs processed
	#  ${total_flacs_length}:  Length of the total # of FLAC files
	#                     27:  Length of:
	#                            [ Interrupted ] (15)
	#                            7 Spaces
	#                            3 Characters: [/]
	#                            2 Gap and ellipsis (…)
	max_filename_length="$(( ${columns} - ${#iteration} - ${total_flacs_length} - 27 ))"

	# Create and cull filename if needed returned as ${filename}
	__filename

	printf "\r${normal}%s${magenta}%s${normal}%s%$(__current_length)s${blue}%s${normal}%s${yellow}%s${normal}%s${blue}%s${normal}%s" \
	"     " "[${iteration}/${total_flacs}]" " ${filename} " "" "[" " " "Interrupted" " " "]" " "
}

# Retag apply interrupted
__print_retag_apply_interrupt () {
	# Obtain the number of columns returned as ${columns}
	__columns

	# This is the maximum length of a string to be displayed based on column width,
	# obtained via the number of columns minus the length of displayed characters:
	#
	#             ${columns}:  Width of terminal
	#          ${#iteration}:  Length of the # of FLACs processed
	#  ${total_flacs_length}:  Length of the total # of FLAC files
	#                     27:  Length of:
	#                            [ Interrupted ] (15)
	#                            7 Spaces
	#                            3 Characters: [/]
	#                            2 Gap and ellipsis (…)
	max_filename_length="$(( ${columns} - ${#iteration} - ${total_flacs_length} - 27 ))"

	# Create and cull filename if needed returned as ${filename}
	__filename

	printf "\r${normal}%s${magenta}%s${normal}%s%$(__current_length)s${blue}%s${normal}%s${yellow}%s${normal}%s${blue}%s${normal}%s" \
	"     " "[${iteration}/${total_flacs}]" " ${filename} " "" "[" " " "Interrupted" " " "]" " "
}

# Interrupted file
__print_interrupt () {
	# Obtain the number of columns returned as ${columns}
	__columns

	# This is the maximum length of a string to be displayed based on column width,
	# obtained via the number of columns minus the length of displayed characters:
	#
	#             ${columns}:  Width of terminal
	#          ${#iteration}:  Length of the # of FLACs processed
	#  ${total_flacs_length}:  Length of the total # of FLAC files
	#                     25:  Length of:
	#                            [ Interrupted ] (15)
	#                            5 Spaces
	#                            3 Characters: [/]
	#                            2 Gap and ellipsis (…)
	max_filename_length="$(( ${columns} - ${#iteration} - ${total_flacs_length} - 25 ))"

	# Create and cull filename if needed returned as ${filename}
	__filename

	printf "\r${normal}%s${magenta}%s${normal}%s%$(__current_length)s${blue}%s${normal}%s${yellow}%s${normal}%s${blue}%s${normal}%s" \
	"   " "[${iteration}/${total_flacs}]" " ${filename} " "" "[" " " "Interrupted" " " "]" " "
}
#== PROCESSED FILE/DIRECTORY MESSAGES ==========================================


#-------------------------------------------------------------------------------
#  TRAPS
#-------------------------------------------------------------------------------
# Countdown abort
__countdown_abort () {
	__newline
	__info "Control-C received, exiting. Please wait..." ; __newline

	# Restore old stty settings, make stty happy
	# by redirecting /dev/stderr
	stty ${old_stty} < /dev/stderr

	# Remove temporary iteration file
	rm -f "${tmp_count_file}"

	# Remove the failed count file
	rm -f "${tmp_fail_count}"

	# Remove the temporary filename file
	rm -f "${tmp_filename}"

	# Restore the cursor
	printf "\033[?25h"

	exit 1
}

# ReplayGain test abort
__replaygain_test_abort () {
	# Obtain iteration and filename
	# for the displayed message below
	__obtain_count_filename

	__print_interrupt_replaygain_file

	__newline
	__info "Control-C received, generating summary. Please wait..."

	if [[ -f "${replay_test_errors}" ]] ; then
		__log_replaygain_test
	fi

	testing_replaygain_complete="interrupt"
	__operation_summary

	exit 1
}

# ReplayGain process abort
__replaygain_process_abort () {
	# Obtain iteration and filename
	# for the displayed message below
	__obtain_count_filename

	__print_interrupt_replaygain_dir

	__newline
	__info "Control-C received, generating summary. Please wait..." ; __newline

	if [[ -f "${replay_add_errors}" ]] ; then
		__log_replaygain_process
	fi

	adding_replaygain_complete="interrupt"
	__operation_summary

	exit 1
}

# FLAC compress abort and remove temporarily encoded files (if any)
__compress_abort () {
	# Obtain iteration and filename
	# for the displayed message below
	__obtain_count_filename

	__print_interrupt

	__newline
	__info "Control-C received, removing temporary files and" ; __newline
	__info "generating summary. Please wait..." ; __newline

	# Remove temporarily encoded FLAC files
	rm -f "${directory}"/**/*.tmp,fl-ac+en\'c

	if [[ -f "${verify_errors}" ]] ; then
		__log_compress_verify
	fi

	compress_complete="interrupt"
	__operation_summary

	exit 1
}

# FLAC test abort
__test_abort () {
	# Obtain iteration and filename
	# for the displayed message below
	__obtain_count_filename

	__print_interrupt

	__newline
	__info "Control-C received, generating summary. Please wait..." ; __newline

	if [[ -f "${test_errors}" ]] ; then
		__log_test
	fi

	test_complete="interrupt"
	__operation_summary

	exit 1
}

# auCDtect abort.  Removes temporary WAV files (if any)
__aucdtect_abort () {
	# Obtain iteration and filename
	# for the displayed message below
	__obtain_count_filename

	__print_interrupt

	__newline
	__info "Control-C received, removing temporary files and" ; __newline
	__info "generating summary. Please wait..." ; __newline

	# Remove temporarily created WAV files (if any)
	rm -f "${directory}"/**/*_redoflacs_"$$".wav

	if [[ -f "${aucdtect_errors}" ]] ; then
		__log_aucdtect
	fi

	aucdtect_complete="interrupt"
	__operation_summary

	exit 1
}

# MD5 check abort
__md5_check_abort () {
	# Obtain iteration and filename
	# for the displayed message below
	__obtain_count_filename

	__print_interrupt

	__newline
	__info "Control-C received, generating summary. Please wait..." ; __newline

	if [[ -f "${md5_errors}" ]] ; then
		__log_md5_check
	fi

	md5check_complete="interrupt"
	__operation_summary

	exit 130
}

# Analyzing tags abort
__analyzing_tags_abort () {
	# Obtain iteration and filename
	# for the displayed message below
	__obtain_count_filename

	__print_retag_analyze_interrupt

	__newline
	__info "Control-C received, generating summary. Please wait..." ; __newline

	# Test for DEPRECATED tag, COVERART in METADATA_ERROR log.  If it
	# exists, set coverart_warning variable to make script output
	# warning upon completion
	if [[ -f "${metadata_errors}" ]] ; then
		while read -r i ; do
			# Indentation is culled from reading in "${i}"
			# To change this, set IFS to '\n'
			if [[ "${i}" == "the new format: METADATA_BLOCK_PICTURE." ]] ; then
				coverart_warning="true"
				break
			fi
		done < "${metadata_errors}"
	fi

	if [[ -f "${metadata_errors}"  && "${coverart_warning}" == "true" ]] ; then
		# Display COVERART warning function and metadata issues
		__newline >&2

		# Below is already redirected to STDERR
		__coverart_warning

		# Display metadata issue
		__log_missing_tags

	elif [[ -f "${metadata_errors}" ]] ; then
		# Display metadata issue
		__log_missing_tags
	fi

	analyzing_retag_complete="interrupt"
	__operation_summary

	exit 1
}

# Applying tags abort
__applying_tags_abort () {
	# Obtain iteration and filename
	# for the displayed message below
	__obtain_count_filename

	__print_retag_apply_interrupt

	__newline
	__info "Control-C received, generating summary. Please wait..." ; __newline

	# Test for DEPRECATED tag, COVERART in METADATA_ERROR log.  If it
	# exists, set coverart_warning variable to make script output
	# warning upon completion
	if [[ -f "${metadata_errors}" ]] ; then
		while read -r i ; do
			# Indentation is culled from reading in "${i}"
			# To change this, set IFS to '\n'
			if [[ "${i}" == "the new format: METADATA_BLOCK_PICTURE." ]] ; then
				coverart_warning="true"
				break
			fi
		done < "${metadata_errors}"
	fi

	if [[ -f "${metadata_errors}"  && "${coverart_warning}" == "true" ]] ; then
		# Display COVERART warning function and metadata issues
		__newline >&2

		# Below is already redirected to STDERR
		__coverart_warning

		# Display metadata issue
		__log_missing_tags

	elif [[ -f "${metadata_errors}" ]] ; then
		# Display metadata issue
		__log_missing_tags
	fi

	applying_retag_complete="interrupt"
	__operation_summary

	exit 1
}

# Prune FLACS abort
__prune_abort () {
	# Obtain iteration and filename
	# for the displayed message below
	__obtain_count_filename

	__print_interrupt

	__newline
	__info "Control-C received, generating summary. Please wait..." ; __newline

	if [[ -f "${prune_errors}" ]] ; then
		__log_prune
	fi

	prune_complete="interrupt"
	__operation_summary

	exit 1
}
#== END TRAPS ==================================================================


#-------------------------------------------------------------------------------
#  VARIOUS COMMANDS
#-------------------------------------------------------------------------------
# Display script version
__print_version () {
	printf "%s\n" "Version ${version}"
}

# Determine the width of the terminal in columns
__columns () {
	# Grab the first line of 'stty -a' output
	# Redirecting '/dev/stderr' to 'stty' allows valid arguments
	read -r columns < <(stty -a < /dev/stderr)

	# Remove superflous information from 'stty -a'
	# Ends up with the width of terminal
	columns="${columns/#*columns }"

	# Stores total columns of terminal
	export columns="${columns/%;*}"
}
export -f __columns

# Creates filename of current FLAC and culls it if the length
# is bigger than then width of the terminal
__filename () {
	filename="${i##*/}"
	# Replace possible newlines in filename with '?' (like 'ls' output)
	export filename="${filename//$'\n'/?}"

	# Cull filename and add an ellipsis if the filename is too long
	if [[ "${#filename}" -gt "${max_filename_length}" ]] ; then
		export filename="${filename::${max_filename_length}}…"
	fi
}
export -f __filename

# Display current length spacing between filename and operation message
__current_length () {
	# The current length is obtained via the length of what's printed now minus
	# the length of the filename and gaps:
	#
	#  [1234/123456] 07 - Some_FLAC_Filename.flac <- ${current_length} -> [ Operation Message ]
	#                                             ^^^^^^^^^^^^^^^^^^^^^^^
	#                ${#filename}:  Length of the current filename
	#  ${max_filename_length} + 1:  Total length of what's printed minus the operation
	#                               message plus one because we do not want the ellipsis
	#                               from ${max_filename_length}, just the space/gap
	printf "%s" "$(( ${max_filename_length} - ${#filename} + 1 ))"
}
export -f __current_length

# Determine number of jobs to run via the number
# of CPUs/cores available
__find_cores () {
	# Check if /proc is mounted by comparing device numbers of
	# /proc and / and see if they don't match (ie, /proc is mounted)
	if [[ "$(stat -c %d%D /proc)" == "$(stat -c %d%D /)" ]] ; then
		# /proc is not mounted, default to 2 jobs
		jobs_display="(Default)"
		jobs=2
	else
		# /proc is mounted, check for cpuinfo
		if [[ ! -f /proc/cpuinfo ]] ; then
			# /proc/cpuinfo doesn't exist
			jobs_display="(Default)"
			jobs=2
		else
			# /proc/cpuinfo exists, find total number
			# of cores to use

			# Store contents of /proc/cpuinfo into
			# cores_array
			mapfile -n0 -t cores_array < /proc/cpuinfo

			# For each line, if matched string is found,
			# add processor number to jobs variable
			for i in "${cores_array[@]}" ; do
				if [[ "${i}" == processor$'\t':\ * ]] ; then
					jobs="${i#processor$'\t': }"
				fi
			done

			# Add +1 to jobs since the number of useable cores
			# starts at 0
			((jobs++))
			jobs_display="(/proc/cpuinfo)"
		fi
	fi
}

# Prints the number of newlines specified
# by ${1}
__newline () {
	newlines="${1}"

	# If ${newlines} is empty, set to 1 in order
	# to allow one newline to be printed
	if [[ -z "${newlines}" ]] ; then
		newlines="1"
	fi

	# Print the number of newlines specified
	for (( count=0; count < ${newlines}; count++ )) ; do
		printf "\n"
	done
}
export -f __newline

# If COVERART tag is kept and remove_artwork is set to 'true'
# display conflict and exit
__coverart_remove_conflict () {
	# Check if COVERART exists in the tag array.  Notify user
	# of its deprecation and advise against using it, preferring
	# METADATA_BLOCK_PICTURE
	for j in "${tags[@]}" ; do

		if [[ "${j}" == "COVERART" ]] ; then

			# If remove_artwork is "true" (remove the artwork), then
			# exit and warn the user you can't specify whether you want to
			# remove artwork, yet keep the COVERART tag in USER CONFIGURATION
			if [[ "${remove_artwork}" == "true" ]] ; then

				# Display COVERART tag warning
				__coverart_warning

				__newline >&2
				{ __error "It appears you have remove_artwork set to \"true\" under" ; __newline ;} >&2
				{ __error "USER CONFIGURATION, yet COVERART is specified as one" ; __newline ;} >&2
				{ __error "(or more) of the FLAC tags to be kept. Please choose either" ; __newline ;} >&2
				{ __error "to keep album artwork (ie remove_artwork=\"false\") or remove" ; __newline ;} >&2
				{ __error "the COVERART tag under the USER CONFIGURATION portion of this" ; __newline ;} >&2
				{ __error "script." ; __newline ;} >&2

				exit 1

			# COVERART was found, but artwork is to be removed,
			# so warn user of its deprecation
			else

				# Create coverart_warning variable, so script can append
				# the coverart_warning function after completion as well as
				# determine whether the script should temporarily add COVERART
				# to the tag array
				coverart_warning="true"
			fi
		fi
	done
}

# Top banner displaying invocation settings
__top_banner () {
	# If Redo Tags is called, create the necessary spacing
	if [[ "${retag_flac}" == "true" ]] ; then
		__newline 2
	fi

	# Top title line
	printf "${normal}%s${blue}%s${normal}\n" \
	" " "---------------------------------------------------"

	# Title
	printf "${normal}%s\n" \
	"                Runtime Information"

	# Bottom title line
	printf "${normal}%s${blue}%s${normal}\n" \
	" " "-------------------------+-------------------------"

	# Script version
	printf "${normal}%s${blue}%s${normal}%s${cyan}%s${normal}\n" \
	"                  Version " "|" " " "${version}"

	# Processes to be used
	printf "${normal}%s${blue}%s${normal}%s${cyan}%s${normal}%s${cyan}%s${normal}\n" \
	"            Parallel Jobs " "|" " " "${jobs}" " " "${jobs_display}"

	# Log directory
	printf "${normal}%s${blue}%s${normal}%s${cyan}%s${normal}\n" \
	"            Log Directory " "|" " " "${error_log}"

	# Bottom banner line
	printf "${normal}%s${blue}%s${normal}\n\n" \
	" " "-------------------------+-------------------------"

	# Message indicating the searching of FLAC files
	__info "Finding FLAC files to process..."
}

# Below creates the '[ ok ]' message to print after the info
# line above.  This will be displayed when all the FLAC files
# have been mapped to an array
__processed_flacs_ok () {
	__columns
	# ${flacs_ok_spacing} is the spacing from the number of
	# ${columns} minus the number of printed characters:
	#
	#  * Finding FLAC files to process... <- ${flacs_ok_spacing} -> [ ok ]
	#                                     ^^^^^^^^^^^^^^^^^^^^^^^^^
	# 42 is the number of printed characters printed and is what is subtracted
	# from ${columns) to get ${flacs_ok_spacing}:
	#
	#  ' * Finding FLAC files to process...'  (35 characters)
	#                              '[ ok ] '  ( 7 characters)
	printf "${normal}%$(( ${columns} - 42 ))s${blue}%s${normal}%s${green}%s${normal}%s${blue}%s${normal}" \
	"" "[" " " "ok" " " "]"
}

# Create a countdown function for the metadata
# to allow user to quit script safely
__countdown_metadata () {
	# Trap SIGINT (Control-C) to abort cleanly
	trap __countdown_abort SIGINT

	# Warning message
	__warn "CAUTION! These are the tag fields that will be kept" ; __newline
	__warn "when re-tagging the selected files:" ; __newline 2

	# Creates the listing of tags to be kept
	for i in "${tags[@]}" ; do
		printf "%s\n" "     ${i}"
	done

	# Warning message about embedded coverart
	__newline
	__error "By default, this script will REMOVE the legacy (deprecated)" ; __newline
	__error "COVERART tag when re-tagging files.  Change the remove_artwork" ; __newline
	__error "option under USER CONFIGURATION to \"false\" to keep the legacy" ; __newline
	__error "COVERART tag, or add the COVERART tag to the list of tags to" ; __newline
	__error "be kept under USER CONFIGURATION." ; __newline
	__error ; __newline
	__error "Keep in mind, if the remove_artwork option is set to \"false\"," ; __newline
	__error "embedded artwork in the PICTURE block will be kept when using" ; __newline
	__error "--prune (-p) option as well." ; __newline 2

	__warn "Waiting 10 seconds before starting script..." ; __newline
	__warn "Ctrl+C (Control-C) to abort..." ; __newline
	__info "Starting in: "

	# 10 second countdown
	for (( count=10; count>0; count-- )); do
		printf "${red}%s${normal}%s" "$count" " "
		sleep 1
	done
}

# Obtain the total number of directories to process, repesented
# as ${total_directories}
__total_directories () {
	# Find all the directories in which to process the FLAC files.
	for i in "${total_flacs_array[@]}" ; do
		if [[ "${processed_directory}" != "${i%/*}" ]] ; then
			flac_directories_array+=( "${i%/*}" )
		fi
		local processed_directory="${i%/*}"
	done

	# The total number of directories in a string variable
	export total_directories="${#flac_directories_array[@]}"
}
export -f __total_directories

# This adds one to current iteration and returns the
# current number processed represented as ${iteration}
# Also adds the currently processed filename to a
# temporary file to be retrieved by abort functions
__iterate_count () {
	# Add one to iteration count file
	printf '.' >> "${tmp_count_file}"

	# Add current filename to tmp file
	printf "${i}" > "${tmp_filename}"

	# Load ${tmp_count_file} into array
	mapfile -n0 -t iteration_array < "${tmp_count_file}"

	# Store array into string
	iteration="${iteration_array}"

	# Count length of iteration string
	iteration="${#iteration}"
}
export -f __iterate_count

# Obtain count and file (used for abort functions)
__obtain_count_filename () {
	### Obtain iteration count ###

	# Load ${tmp_count_file} into array
	mapfile -n0 -t iteration_array < "${tmp_count_file}"

	# Store array into string
	iteration="${iteration_array}"

	# Count length of iteration string
	iteration="${#iteration}"

	### Obtain filename ###

	# Load ${tmp_filename} into ${i}
	read -r i < "${tmp_filename}"
}
export -f __obtain_count_filename

# Add one to fail count
__fail_count () {
	# Add one to fail count 
	printf '.' >> "${tmp_fail_count}"
}
export -f __fail_count

# Unset the various functions (to provide a small environment for
# xargs).  If any of the variables are NOT null (meaning the operations
# they represent have been run), unset the functions indicative to
# those operations
__tidy_env () {
	# auCDtect
	if [[ -n "${aucdtect_complete}" ]] ; then
		unset -f \
			__operation_aucdtect \
			__aucdtect_abort \
			__print_aucdtect_flac \
			__print_aucdtect_issue \
			__print_aucdtect_spectrogram \
			__print_aucdtect_skip \
			__log_aucdtect
	fi

	# Compress FLACs
	if [[ -n "${compress_complete}" ]] ; then
		unset -f \
			__operation_compress \
			__compress_abort \
			__print_compressing_flac \
			__print_level_same_compression \
			__print_testing_flac \
			__log_compress_verify
	fi

	# Test FLACs
	if [[ -n "${test_complete}" ]] ; then
		unset -f \
			__operation_test \
			__test_abort \
			__print_testing_flac \
			__log_test
	fi

	# MD5 Check
	if [[ -n "${md5check_complete}" ]] ; then
		unset -f \
			__operation_md5_check \
			__md5_check_abort \
			__print_checking_md5 \
			__log_md5_check
	fi

	# Test ReplayGain
	if [[ -n "${testing_replaygain_complete}" ]] ; then
		unset -f \
			__operation_test_replaygain \
			__replaygain_test_abort \
			__print_test_replaygain \
			__print_ok_replaygain_file \
			__print_interrupt_replaygain_file \
			__log_replaygain_test

	fi

	# Applying ReplayGain
	if [[ -n "${adding_replaygain_complete}" ]] ; then
		unset -f \
			__operation_replaygain_force \
			__operation_replaygain_noforce \
			__replaygain_process_abort \
			__print_add_replaygain \
			__print_ok_replaygain_dir \
			__print_failed_replaygain \
			__print_interrupt_replaygain_dir \
			__log_replaygain_process
	fi

	# Analyze tags
	if [[ -n "${analyzing_retag_complete}" ]] ; then
		unset -f \
			__operation_analyze_tags \
			__operation_analyze_tags_dont_log_coverart \
			__analyzing_tags_abort \
			__print_analyzing_tags \
			__print_retag_analyze_interrupt
	fi

	# Applying tags
	if [[ -n "${applying_retag_complete}" ]] ; then
		unset -f \
			__operation_set_tags \
			__applying_tags_abort \
			__print_applying_tags \
			__print_ok_tag \
			__print_retag_apply_interrupt \
			__log_missing_tags
	fi

	# Prune FLACs
	if [[ -n "${prune_complete}" ]] ; then
		unset -f \
			__operation_prune \
			__prune_abort \
			__print_prune_flac \
			__log_prune
	fi
}

# Obtain and process the positional parameters invoked
# with the script
__process_positional_parameters () {
	# If no arguments are made to the script show usage & short help
	if [[ "${#}" -eq 0 ]] ; then
		__short_help
		exit 1
	fi

	# Add case where only one argument is specified
	if [[ "${#}" -eq 1 ]] ; then
		case "${1}" in
			--version|-v)
				__print_version
				exit 0
			;;
			--help|-h)
				# Check for ${PAGER}. If a pager is available
				# lets use it. If not, just display help
				if [[ -n "${PAGER}" ]] ; then
					__long_help | "${PAGER}"
					exit 0
				else
					__long_help
					exit 0
				fi
			;;
			*)
				__usage >&2
				exit 1
			;;
		esac
	fi

	# Add case where two arguments are specified and the
	# arguments called are not to have anything after them
	if [[ "${#}" -eq 2 ]] ; then
		case "${1}" in
			--jobs=[0-9]*|-j[0-9]*)
				__usage >&2
				exit 1
			;;
			--no-color|-n)
				__usage >&2
				exit 1
			;;
			--version|-v)
				__usage >&2
				exit 1
			;;
			--help|-h)
				__usage >&2
				exit 1
			;;
		esac
	fi

	# Separate the long and short style arguments into their
	# own arrays as well as capture the last non-arguements, to
	# prevent multiple directories being called
	for i in "${@}" ; do
		if [[ "${i}" == --* ]] ; then
			long_style_arguments_array+=( "${i}" )
		elif [[ "${i}" == -* ]] ; then
			short_style_arguments_array+=( "${i}" )
		else
			non_arguments_array+=( "${i}" )
		fi
	done

	# If there are 0 (zero) directories or more than 1, exit script
	if [[ "${#non_arguments_array[@]}" -eq 0 || "${#non_arguments_array[@]}" -gt 1 ]] ; then
		__usage >&2
		exit 1
	fi

	# If there were any long style arguments called, convert them
	# to short style in order for getopts to be able to process
	# them correctly (ignoring "--help" and "--version" since
	# this is taken care of above).  Add invalid arguments to it's
	# own array
	if [[ -n "${long_style_arguments_array[@]}" ]] ; then
		for i in "${long_style_arguments_array[@]}" ; do
			case "${i}" in
				--compress)
					converted_arguments_array+=( -c )
				;;
				--compress-notest)
					converted_arguments_array+=( -C )
				;;
				--test)
					converted_arguments_array+=( -t )
				;;
				--md5check)
					converted_arguments_array+=( -m )
				;;
				--aucdtect)
					converted_arguments_array+=( -a )
				;;
				--aucdtect-spectrogram)
					converted_arguments_array+=( -A )
				;;
				--prune)
					converted_arguments_array+=( -p )
				;;
				--replaygain)
					converted_arguments_array+=( -g )
				;;
				--replaygain-noforce)
					converted_arguments_array+=( -G )
				;;
				--redo)
					converted_arguments_array+=( -r )
				;;
				--all)
					converted_arguments_array+=( -l )
				;;
				--reallyall)
					converted_arguments_array+=( -L )
				;;
				--no-color)
					converted_arguments_array+=( -n )
				;;
				--jobs=[0-9]*)
					# Set number of jobs to run via the required
					# integer argument after '-j'
					jobs="${i##*=}"
				;;
				--version)
					__usage >&2
					exit 1
				;;
				--help)
					__usage >&2
					exit 1
				;;
				*)
					# Set invalid argument into array
					invalid_arguments_array+=( "${i}" )
				;;
			esac
		done
	fi

	# If there were any short style arguments called, go through
	# them, adding the valid arguments to the "converted_arguments"
	# array and adding invalid arguments to it's own array
	if [[ -n "${short_style_arguments_array[@]}" ]] ; then
		while getopts ":LlcCtgGaAmprnj:hv" arguments "${short_style_arguments_array[@]}" ; do
			case "${arguments}" in
				l)
					converted_arguments_array+=( -l )
				;;
				L)
					converted_arguments_array+=( -L )
				;;
				c)
					converted_arguments_array+=( -c )
				;;
				C)
					converted_arguments_array+=( -C )
				;;
				t)
					converted_arguments_array+=( -t )
				;;
				g)
					converted_arguments_array+=( -g )
				;;
				G)
					converted_arguments_array+=( -G )
				;;
				a)
					converted_arguments_array+=( -a )
				;;
				A)
					converted_arguments_array+=( -A )
				;;
				m)
					converted_arguments_array+=( -m )
				;;
				p)
					converted_arguments_array+=( -p )
				;;
				r)
					converted_arguments_array+=( -r )
				;;
				n)
					converted_arguments_array+=( -n )
				;;
				j)
					# Set number of jobs to run via the required
					# integer argument after '-j'
					jobs="${OPTARG}"
					converted_arguments_array+=( -j )
				;;
				h)
					converted_arguments_array+=( -h )
				;;
				v)
					converted_arguments_array+=( -v )
				;;
				:)
					# Currently, this is just for '-j' so we can explicity specify it
					parameter_errors_array+=( "-${OPTARG} requires an integer after it (eg. -${OPTARG}11)." )
				;;
				?)
					# Set invalid argument from getopts into
					# array using ${OPTARG}
					invalid_arguments_array+=( "-${OPTARG}" )
				;;
			esac
		done
	fi

	# If there were invalid arguments called, display them and
	# exit script
	if [[ -n "${invalid_arguments_array[@]}" || -n "${parameter_errors_array[@]}" ]] ; then
		__usage >&2

		if [[ -n "${invalid_arguments_array[@]}" ]] ; then
			__newline >&2
			__error "Invalid options:" >&2

			for i in "${invalid_arguments_array[@]}" ; do
				printf "%s" " ${i}" >&2
			done

			__newline >&2
		fi

		if [[ -n "${parameter_errors_array[@]}" ]] ; then
			__newline >&2

			for i in "${parameter_errors_array[@]}" ; do
				{ __error "${i}" ; __newline ;} >&2
			done
		fi

		exit 1
	fi

	# Run through all the converted arguments and set up the correct
	# values based on what the user called, thereby allowing the
	# script to process said values and execute the corresponding
	# functions
	for i in "${converted_arguments_array[@]}" ; do
		case "${i}" in
			-l)
				all="true"
			;;
			-L)
				reallyall="true"
			;;
			-c)
				compress_flac="true"
				compress_test="true"
			;;
			-C)
				compress_flac="true"
				export skip_test="true"
			;;
			-t)
				test_flac="true"
			;;
			-g)
				replaygain_flac="true"
				# Below used only once to test for
				# command compatibility
				replaygain_force="true"
			;;
			-G)
				replaygain_flac="true"
				replaygain_noforce="true"
			;;
			-a)
				aucdtect_flac="true"
				no_spectrogram="true"
			;;
			-A)
				aucdtect_flac="true"
				export create_spectrogram="true"
			;;
			-m)
				md5check_flac="true"
			;;
			-p)
				prune_flac="true"
			;;
			-r)
				retag_flac="true"
			;;
			-n)
				no_color="true"
			;;
			-j)
				# Do nothing, ${jobs} has already been stored
				# in previous getopts loop
				:
			;;
			-v)
				__usage >&2
				exit 1
			;;
			-h)
				__usage >&2
				exit 1
			;;
			*)
				# Should not ever happen!
				{ __error "This is a BUG! Please report to:" ; __newline ;} >&2
				{ printf "%s\n" "   https://github.com/sirjaren/redoflacs/issues/new" ;} >&2

				exit 1
			;;
		esac
	done

	# Put all the called arguments into an array
	called_arguments_array=( "${@}" )

	# Set the last argument as the directory and remove the
	# ending slash (if any) to prevent double slashes from
	# appearing because of BASH's globstar.
	#
	# This only appears if the directory chosen is the direct
	# parent directory to the FLAC files to be processed.
	#
	# BASH 4.2 allows negative indices (ie):
	#
	# directory="${called_arguments_array[-1]%/}"
	directory="${called_arguments_array[$(( ${#called_arguments_array[@]} - 1 ))]%/}"
}

# Check for missing programs vital to this script
__check_missing_programs () {
	# Check if each command can be found in $PATH
	rm_exists="$(command -v rm)"
	sleep_exists="$(command -v sleep)"
	stty_exists="$(command -v stty)"
	stat_exists="$(command -v stat)"
	mkfifo_exists="$(command -v mkfifo)"
	find_exists="$(command -v find)"
	xargs_exists="$(command -v xargs)"
	metaflac_exists="$(command -v metaflac)"
	flac_exists="$(command -v flac)"

	# Go through and test if each command was found (by displaying its $PATH).  If
	# it's empty, add where you can find the package to an array to be displayed.
	if [[ -z "${rm_exists}" ]] ; then
		command_exists_array+=( "You can generally install \"rm\" with the \"coreutils\" package." )
	fi

	if [[ -z "${sleep_exists}" ]] ; then
		command_exists_array+=( "You can generally install \"sleep\" with the \"coreutils\" package." )
	fi

	if [[ -z "${stty_exists}" ]] ; then
		command_exists_array+=( "You can generally install \"stty\" with the \"coreutils\" package." )
	fi

	if [[ -z "${stat_exists}" ]] ; then
		command_exists_array+=( "You can generally install \"stat\" with the \"coreutils\" package." )
	fi

	if [[ -z "${mkfifo_exists}" ]] ; then
		command_exists_array+=( "You can generally install \"mkfifo\" with the \"coreutils\" package." )
	fi

	if [[ -z "${find_exists}" ]] ; then
		command_exists_array+=( "You can generally install \"find\" with the \"findutils\" package." )
	fi

	if [[ -z "${xargs_exists}" ]] ; then
		command_exists_array+=( "You can generally install \"xargs\" with the \"findutils\" package." )
	fi

	if [[ -z "${metaflac_exists}" ]] ; then
		command_exists_array+=( "You can generally install \"metaflac\" with the \"flac\" package." )
	fi

	if [[ -z "${flac_exists}" ]] ; then
		command_exists_array+=( "You can generally install \"flac\" with the \"flac\" package." )
	fi

	# If all the programs above were found, continue with script.  Else
	# display warning and exit script, printing out which package has
	# the missing programs
	if [[ -n "${command_exists_array[@]}" ]] ; then
		__display_missing_commands_header

		# Iterate through array and print each value
		for i in "${command_exists_array[@]}" ; do
			{ __warn "${i}" ; __newline ;} >&2
		done

		exit 1
	fi
}

# Check for any conflicting operations/arguments
__check_conflicting_operations () {
	# If "-l, --all" and "-L, --reallyall" are both called, warn and exit
	if [[ "${all}" == "true" && "${reallyall}" == "true" ]] ; then
		{ __error "Running both \"-l, --all\" and \"-L, --reallyall\" conflict!" ; __newline ;} >&2
		{ __error "Please choose one or the other." ; __newline ;} >&2

		exit 1
	fi

	# If "-l, --all" or "-L, --reallyall" was called, check if arguments
	# were called that already will be performed by the above argument(s).
	# If any were called, display a warning and exit the script
	if [[ "${all}" == "true" || "${reallyall}" == "true" ]] ; then

		# Check for "-c, --compress".  If used add it to array
		if [[ "${compress_flac}" == "true" && "${skip_test}" == "false" ]] ; then
			argument_conflict_array+=( "-c, --compress" )
		# Check for "-C, --compress-notest".  If used add it to array
		elif [[ "${compress_flac}" == "true" && "${skip_test}" == "true" ]] ; then
			argument_conflict_array+=( "-C, --compress-notest" )
		fi

		# Check for "-t, --test".  If used add it to array
		if [[ "${test_flac}" == "true" ]] ; then
			argument_conflict_array+=( "-t, --test" )
		fi

		# Check for "-m, --md5check".  If used add it to array
		if [[ "${md5check_flac}" == "true" ]] ; then
			argument_conflict_array+=( "-m, --md5check" )
		fi

		# Check for "-p, --prune".  If used add it to array
		if [[ "${prune_flac}" == "true" ]] ; then
			argument_conflict_array+=( "-p, --prune" )
		fi

		# Check for "-g, --replaygain".  If used add it to array
		if [[ "${replaygain_flac}" == "true" && "${replaygain_noforce}" != "true" ]] ; then
			argument_conflict_array+=( "-g, --replaygain" )
		# Check for "-G, --replaygain-noforce".  If used add it to array
		elif [[ "${replaygain_flac}" == "true" && "${replaygain_noforce}" == "true" ]] ; then
			argument_conflict_array+=( "-G, --replaygain-noforce" )
		fi

		# Check for "-r, --redo".  If used add it to array
		if [[ "${retag_flac}" == "true" ]] ; then
			argument_conflict_array+=( "-r, --redo" )
		fi

		# If "-L, --reallyall" was called, check for the various forms of calling
		# auCDtect.  If it was called, add it to array
		if [[ "${reallyall}" == "true" ]] ; then
			if [[ "${aucdtect_flac}" == "true" && "${create_spectrogram}" == "true" ]] ; then
				argument_conflict_array+=( "-A, --aucdtect-spectrogram" )
			elif [[ "${aucdtect_flac}" == "true" && "${create_spectrogram}" != "true" ]] ; then
				argument_conflict_array+=( "-a, --aucdtect" )
			fi
		fi

		# If the array is not empty, the user called some incompatible options with
		# "-l, --all" or "-L, --reallyall", so print which options were called that
		# are incompatible and exit script
		if [[ -n "${argument_conflict_array[@]}" ]] ; then
			# "-l, --all"
			if [[ "${all}" == "true" ]] ; then
				{ __error "The below options conflict with \"-l, --all\"" ; __newline ;} >&2
			# "-L, --reallyall"
			elif [[ "${reallyall}" == "true" ]] ; then
				{ __error "The below options conflict with \"-L, --reallyall\"" ; __newline ;} >&2
			fi

			# Iterate through array and print each value
			for i in "${argument_conflict_array[@]}" ; do
				{ __error "     ${i}" ; __newline ;} >&2
			done

			{ __error "Please remove incompatible options." ; __newline ;} >&2

			exit 1
		fi
	fi

	# If "-C, --compress-notest" and "-c, --compress" are both called, warn and exit
	if [[ "${skip_test}" == "true" && "${compress_test}" == "true" ]] ; then
		{ __error "Running both \"-c, --compress\" and \"-C, --compress-notest\" conflict!" ; __newline ;} >&2
		{ __error "Please choose one or the other." ; __newline ;} >&2
		exit 1
	fi

	# If "-c, --compress" and "-t, --test" are both called, warn and exit
	if [[ "${compress_test}" == "true" && "${test_flac}" == "true" ]] ; then
		{ __error "Running both \"-c, --compress\" and \"-t, --test\" conflict!" ; __newline ;} >&2
		{ __error "Please choose one or the other." ; __newline ;} >&2
		exit 1
	fi

	# If "-g, --replaygain" and "-G, --replaygain-noforce" are both called, warn and exit
	if [[ "${replaygain_force}" == "true" && "${replaygain_noforce}" == "true" ]] ; then
		{ __error "Running both \"-g, --replaygain\" and \"-G, --replaygain-noforce\" conflict!" ; __newline ;} >&2
		{ __error "Please choose one or the other." ; __newline ;} >&2
		exit 1
	fi

	# If "-a, --aucdtect" and "-A, --aucdtect-spectrogram" are both called, warn and exit
	if [[ "${no_spectrogram}" == "true"  && "${create_spectrogram}" == "true" ]] ; then
		{ __error "Running both \"-a, --aucdtect\" and \"-A, --aucdtect-spectrogram\" conflict!" ; __newline ;} >&2
		{ __error "Please choose one or the other." ; __newline ;} >&2
		exit 1
	fi

	# If "-l, --all" or "-L, --reallyall" was called,
	# enable the various arguments to allow script to
	# run them
	if [[ "${all}" == "true" ]] ; then
		compress_flac="true"
		md5check_flac="true"
		prune_flac="true"
		replaygain_flac="true"
		retag_flac="true"
	elif [[ "${reallyall}" == "true" ]] ; then
		compress_flac="true"
		md5check_flac="true"
		prune_flac="true"
		replaygain_flac="true"
		retag_flac="true"
		aucdtect_flac="true"
		# This is needed to let script know that we want auCDtect
		# to create a spectrogram (ie "-A, --aucdtect-spectrogram")
		create_spectrogram="true"
	fi
}

# Display the summary of operations chart
__operation_summary () {
	# Build the operation line in the Summary Of Operations
	__summary_line () {
		# Set up spacing for Operation
		case "${operation}" in
			"Validate with auCDtect")
				operation_spacing="   "
			;;
			"Compress FLACS")
				operation_spacing="           "
			;;
			"Test Flacs")
				operation_spacing="               "
			;;
			"Check MD5 Signature")
				operation_spacing="      "
			;;
			"Testing ReplayGain")
				# Print the outer operation, with the sub operations
				# to follow (from the below case statement)
				printf "%s${yellow}%s${normal}%s${blue}%s${normal}\n" \
				"      " "Applying ReplayGain" " " "|" 

				# Change yellow color to cyan, but leave the yellow
				# name to keep the below case statement sane
				if [[ "${no_color}" != "true" ]] ; then
					yellow="${magenta}"
				fi

				operation="> Testing"
				operation_spacing="                "
			;;
			"Adding ReplayGain")
				operation="> Adding"
				operation_spacing="                 "
			;;
			"Analyzing Tags")
				# Print the outer operation, with the sub operations
				# to follow (from the below case statement)
				printf "%s${yellow}%s${normal}%s${blue}%s${normal}\n" \
				"          " "Retagging Files" " " "|"

				# Change yellow color to cyan, but leave the yellow
				# name to keep the below case statement sane
				if [[ "${no_color}" != "true" ]] ; then
					yellow="${magenta}"
				fi

				operation="> Analyzing"
				operation_spacing="              "
			;;
			"Applying Tags")
				operation="> Applying"
				operation_spacing="               "
			;;
			"Prune METADATA Blocks")
				operation_spacing="    "
			;;
		esac

		case "${operation_summary}" in
			"complete")
				# Set up the printed string with colors
				printf "%s${yellow}%s${normal}%s${blue}%s${normal}%s${green}%s${normal}\n" \
				"${operation_spacing}" "${operation}" " " "|" " " "Operation Completed"
			;;

			"failed")
				# Store everything from ${tmp_fail_count} into an array
				mapfile -n0 -t fail_count_array < "${tmp_fail_count}"

				fail_count="${fail_count_array[@]}"

				# If ${#fail_count} is one, change the message
				# to singular
				if [[ "${#fail_count}" -eq 1 ]] ; then
					fail_count_message="${#fail_count} File Failed"
				else
					fail_count_message="${#fail_count} Files Failed"
				fi

				# Set up the printed string with colors
				printf "%s${yellow}%s${normal}%s${blue}%s${normal}%s${red}%s${normal}\n" \
				"${operation_spacing}" "${operation}" " " "|" " " "${fail_count_message}"
			;;

			"interrupted")
				# Set up the printed string with colors
				printf "%s${yellow}%s${normal}%s${blue}%s${normal}%s${cyan}%s${normal}\n" \
				"${operation_spacing}" "${operation}" " " "|" " " "Operation Interrupted"
			;;

			"did not run")
				# Set up the printed string with colors
				printf "%s${yellow}%s${normal}%s${blue}%s${normal}%s${magenta}%s${normal}\n" \
				"${operation_spacing}" "${operation}" " " "|" " " "Operation Did Not Run"
			;;

			*)
				# Should not ever happen!
			;;
		esac
	}

	# Begin printing the table

	# Title
	printf "\n${normal}%s${blue}%s${normal}\n" \
	" " "---------------------------------------------------"
	printf "${normal}%s\n" \
	"                Summary Of Operations"
	printf "${normal}%s${blue}%s${normal}\n" \
	" " "-------------------------+-------------------------"

	# auCDtect operations
	if [[ "${aucdtect_flac}" == "true" && "${aucdtect_complete}" == "true" ]] ; then
		operation="Validate with auCDtect"
		operation_summary="complete"
		__summary_line
	elif [[ "${aucdtect_flac}" == "true" && "${aucdtect_complete}" == "false" ]] ; then
		operation="Validate with auCDtect"
		operation_summary="failed"
		__summary_line
	elif [[ "${aucdtect_flac}" == "true" && "${aucdtect_complete}" == "interrupt" ]] ; then
		operation="Validate with auCDtect"
		operation_summary="interrupted"
		__summary_line
	elif [[ "${aucdtect_flac}" == "true" ]] ; then
		operation="Validate with auCDtect"
		operation_summary="did not run"
		__summary_line
	fi

	# Compress Flacs operations
	if [[ "${compress_flac}" == "true" && "${compress_complete}" == "true" ]] ; then
		operation="Compress FLACS"
		operation_summary="complete"
		__summary_line
	elif [[ "${compress_flac}" == "true" && "${compress_complete}" == "false" ]] ; then
		operation="Compress FLACS"
		operation_summary="failed"
		__summary_line
	elif [[ "${compress_flac}" == "true" && "${compress_complete}" == "interrupt" ]] ; then
		operation="Compress FLACS"
		operation_summary="interrupted"
		__summary_line
	elif [[ "${compress_flac}" == "true" ]] ; then
		operation="Compress FLACS"
		operation_summary="did not run"
		__summary_line
	fi

	# Test Flacs operations
	if [[ "${test_flac}" == "true" && "${test_complete}" == "true" ]] ; then
		operation="Test Flacs"
		operation_summary="complete"
		__summary_line
	elif [[ "${test_flac}" == "true" && "${test_complete}" == "false" ]] ; then
		operation="Test Flacs"
		operation_summary="failed"
		__summary_line
	elif [[ "${test_flac}" == "true" && "${test_complete}" == "interrupt" ]] ; then
		operation="Test Flacs"
		operation_summary="interrupted"
		__summary_line
	elif [[ "${test_flac}" == "true" ]] ; then
		operation="Test Flacs"
		operation_summary="did not run"
		__summary_line
	fi

	# MD5 Check operations
	if [[ "${md5check_flac}" == "true" && "${md5check_complete}" == "true" ]] ; then
		operation="Check MD5 Signature"
		operation_summary="complete"
		__summary_line
	elif [[ "${md5check_flac}" == "true" && "${md5check_complete}" == "false" ]] ; then
		operation="Check MD5 Signature"
		operation_summary="failed"
		__summary_line
	elif [[ "${md5check_flac}" == "true" && "${md5check_complete}" == "interrupt" ]] ; then
		operation="Check MD5 Signature"
		operation_summary="interrupted"
		__summary_line
	elif [[ "${md5check_flac}" == "true" ]] ; then
		operation="Check MD5 Signature"
		operation_summary="did not run"
		__summary_line
	fi

	# ReplayGain test operations
	if [[ "${replaygain_flac}" == "true" && "${testing_replaygain_complete}" == "true" ]] ; then
		operation="Testing ReplayGain"
		operation_summary="complete"
		__summary_line
	elif [[ "${replaygain_flac}" == "true" && "${testing_replaygain_complete}" == "false" ]] ; then
		operation="Testing ReplayGain"
		operation_summary="failed"
		__summary_line
	elif [[ "${replaygain_flac}" == "true" && "${testing_replaygain_complete}" == "interrupt" ]] ; then
		operation="Testing ReplayGain"
		operation_summary="interrupted"
		__summary_line
	elif [[ "${replaygain_flac}" == "true" ]] ; then
		operation="Testing ReplayGain"
		operation_summary="did not run"
		__summary_line
	fi

	# ReplayGain apply operations
	if [[ "${replaygain_flac}" == "true" && "${adding_replaygain_complete}" == "true" ]] ; then
		operation="Adding ReplayGain"
		operation_summary="complete"
		__summary_line
	elif [[ "${replaygain_flac}" == "true" && "${adding_replaygain_complete}" == "false" ]] ; then
		operation="Adding ReplayGain"
		operation_summary="failed"
		__summary_line
	elif [[ "${replaygain_flac}" == "true" && "${adding_replaygain_complete}" == "interrupt" ]] ; then
		operation="Adding ReplayGain"
		operation_summary="interrupted"
		__summary_line
	elif [[ "${replaygain_flac}" == "true" ]] ; then
		operation="Adding ReplayGain"
		operation_summary="did not run"
		__summary_line
	fi

	# Change ${yellow} color back to yellow (could have been
	# changed in ReplayGain operations above)
	if [[ "${no_color}" != "true" ]] ; then
		yellow="\033[33m"
	fi

	# Retag analyze operations
	if [[ "${retag_flac}" == "true" && "${analyzing_retag_complete}" == "true" ]] ; then
		operation="Analyzing Tags"
		operation_summary="complete"
		__summary_line
	elif [[ "${retag_flac}" == "true" && "${analyzing_retag_complete}" == "false" ]] ; then
		operation="Analyzing Tags"
		operation_summary="failed"
		__summary_line
	elif [[ "${retag_flac}" == "true" && "${analyzing_retag_complete}" == "interrupt" ]] ; then
		operation="Analyzing Tags"
		operation_summary="interrupted"
		__summary_line
	elif [[ "${retag_flac}" == "true" ]] ; then
		operation="Analyzing Tags"
		operation_summary="did not run"
		__summary_line
	fi

	# Retag apply operations
	if [[ "${retag_flac}" == "true" && "${applying_retag_complete}" == "true" ]] ; then
		operation="Applying Tags"
		operation_summary="complete"
		__summary_line
	elif [[ "${retag_flac}" == "true" && "${applying_retag_complete}" == "false" ]] ; then
		operation="Applying Tags"
		operation_summary="failed"
		__summary_line
	elif [[ "${retag_flac}" == "true" && "${applying_retag_complete}" == "interrupt" ]] ; then
		operation="Applying Tags"
		operation_summary="interrupted"
		__summary_line
	elif [[ "${retag_flac}" == "true" ]] ; then
		operation="Applying Tags"
		operation_summary="did not run"
		__summary_line
	fi

	# Change ${yellow} color back to yellow (could have been
	# changed in Retag operations above)
	if [[ "${no_color}" != "true" ]] ; then
		yellow="\033[33m"
	fi

	# Prune Flacs operations
	if [[ "${prune_flac}" == "true" && "${prune_complete}" == "true" ]] ; then
		operation="Prune METADATA Blocks"
		operation_summary="complete"
		__summary_line
	elif [[ "${prune_flac}" == "true" && "${prune_complete}" == "false" ]] ; then
		operation="Prune METADATA Blocks"
		operation_summary="failed"
		__summary_line
	elif [[ "${prune_flac}" == "true" && "${prune_complete}" == "interrupt" ]] ; then
		operation="Prune METADATA Blocks"
		operation_summary="interrupted"
		__summary_line
	elif [[ "${prune_flac}" == "true" ]] ; then
		operation="Prune METADATA Blocks"
		operation_summary="did not run"
		__summary_line
	fi

	printf "${normal}%s${blue}%s${normal}\n" \
	" " "-------------------------+-------------------------"

	## CLEANUP SECTION ##

	# Restore old stty settings, make stty happy
	# by redirecting /dev/stderr
	stty ${old_stty} < /dev/stderr

	# Remove temporary iteration file
	rm -f "${tmp_count_file}"

	# Remove the failed count file
	rm -f "${tmp_fail_count}"

	# Remove the temporary filename file
	rm -f "${tmp_filename}"

	# Restore the cursor
	printf "\033[?25h"
}
#== END VARIOUS COMMANDS =======================================================


#-------------------------------------------------------------------------------
#  OPERATIONS
#-------------------------------------------------------------------------------
# Test ReplayGain
__operation_test_replaygain () {
	for i ; do
		# Add one (iteration)
		__iterate_count

		# Prints current file and operation
		__print_test_replaygain

		# Check if file is a FLAC file (hide output)
		metaflac --show-md5sum "${i}" >/dev/null 2>&1

		# Exit code 130 is SIGINT so only check for exit code '1'
		if [[ "${?}" -eq "1" ]] ; then
			# File is not a FLAC file, display failed
			__print_failed_flac
			printf "%s\n%s\n%s\n" \
				   "FLAC:  ${i}" \
				   "ERROR: Not a FLAC file" \
				   "------------------------------------------------------------------" \
				   >> "${replay_test_errors}"

			# Add one to fail count
			__fail_count
		fi
	done
}

# Process Replaygain (only add values if missing)
__operation_replaygain_noforce () {
	for i ; do
		# Add one (iteration)
		__iterate_count

		# Prints current file and operation
		__print_add_replaygain

		# ${i} is the parent directory to the FLAC files
		# ${j} is a FLAC file -> under ${i}
		for j in "${i}"/*${flac_extension} ; do
			# Grab all of the ReplayGain tags
			mapfile -n0 -t replaygain_array < \
			<(
				metaflac \
					--show-tag=REPLAYGAIN_REFERENCE_LOUDNESS \
					--show-tag=REPLAYGAIN_TRACK_GAIN \
					--show-tag=REPLAYGAIN_TRACK_PEAK \
					--show-tag=REPLAYGAIN_ALBUM_GAIN \
					--show-tag=REPLAYGAIN_ALBUM_PEAK \
					"${j}"
			)

			# Strip out the tag fields (eg. REPLAYGAIN_TRACK_GAIN=)
			replaygain_array="${replaygain_array[@]#*=}"

			# Test if any ReplayGain values are empty (if there are less
			# than 5 values in the replaygain array)
			if [[ "${#replaygain_array[@]}" -lt 5 ]] ; then
				# At _least_ one tag is missing from current file, so
				# apply new ReplayGain values
				#
				# Add ReplayGain to FLAC files under directory.  Metaflac
				# automatically removes old ReplayGain values (if any)
				# before proceeding
				metaflac --add-replay-gain "${i}"/*${flac_extension} >/dev/null 2>&1

				# Exit code 130 is SIGINT so only check for exit code '1'
				if [[ "${?}" -eq 1 ]] ; then
					__print_failed_flac
					printf "%s\n%s\n%s\n%s\n" \
						   "Directory: ${i}" \
						   "ERROR:     There was an issue with some FLAC files in this directory." \
						   "           Check that the sample rate is the same for all FLAC files." \
						   "------------------------------------------------------------------" \
						   >> "${replay_add_errors}"

					# Add one to fail count
					__fail_count

					# Placeholder variable tested after this loop
					# if the loop completes with 'break'
					broke_out_of_loop="true"

					# Break out of loop and on to next directory
					break
				fi
			fi
		done
	done
}

# Process ReplayGain (force new values)
__operation_replaygain_force () {
	for i ; do
		# Add one (iteration)
		__iterate_count

		# Prints current file and operation
		__print_add_replaygain

		# Add ReplayGain to FLAC files under directory 
		metaflac --add-replay-gain "${i}"/*${flac_extension} >/dev/null 2>&1

		# Exit code 130 is SIGINT so only check for exit code '1'
		if [[ "${?}" -eq 1 ]] ; then
			__print_failed_replaygain
			printf "%s\n%s\n%s\n%s\n" \
				   "Directory: ${i}" \
				   "ERROR:     There was an issue with some FLAC files in this directory." \
				   "           Check that the sample rate is the same for all FLAC files." \
				   "------------------------------------------------------------------" \
				   >> "${replay_add_errors}"

			# Add one to fail count
			__fail_count
		fi
	done
}

# Compress FLAC files
__operation_compress () {
	for i ; do
		# Add one (iteration)
		__iterate_count

		# Test for COMPRESSION level in FLAC file. Hide error output since
		# we'll be verifying the FLAC file later
		COMPRESSION="$(metaflac --show-tag=COMPRESSION "${i}" 2> /dev/null)"
		COMPRESSION="${COMPRESSION#*=}"

		if [[ "${COMPRESSION}" != "${compression_level}" ]] ; then
			__print_compressing_flac

			# Compress FLAC file with user defined COMPRESSION
			flac -f -${compression_level} -V --totally-silent "${i}"

			# Exit code 130 is SIGINT so only check for exit code '1'
			if [[ "${?}" -eq 1 ]] ; then
				__print_failed_flac
				printf "%s\n%s\n%s\n" \
					   "FLAC:  ${i}" \
					   "ERROR: Not a FLAC file or failed verification." \
					   "------------------------------------------------------------------" \
					   >> "${verify_errors}"

				# Add one to fail count
				__fail_count
			else
				metaflac \
					--remove-tag=COMPRESSION \
					--set-tag=COMPRESSION=${compression_level} "${i}"
			fi

		# If already at compression_level, test the FLAC file instead
		# or skip the file if '-C, --compress-notest' was specified
		else
			__print_level_same_compression

			if [[ "${skip_test}" != "true" ]] ; then
				__print_testing_flac

				# Test FLAC file
				flac -t --totally-silent "${i}"

				# Exit code 130 is SIGINT so only check for exit code '1'
				if [[ "${?}" -eq 1 ]] ; then
					__print_failed_flac
					printf "%s\n%s\n%s\n" \
						   "FLAC:  ${i}" \
						   "ERROR: Not a FLAC file or failed testing." \
						   "------------------------------------------------------------------" \
						   >> "${verify_errors}"

					# Add one to fail count
					__fail_count
				fi
			fi

		fi
	done
}

# Test FLAC files
__operation_test () {
	for i ; do
		# Add one (iteration)
		__iterate_count

		__print_testing_flac

		# Test FLAC file
		flac -t --totally-silent "${i}"

		# Exit code 130 is SIGINT so only check for exit code '1'
		if [[ "${?}" -eq 1 ]] ; then
			__print_failed_flac
			printf "%s\n%s\n%s\n" \
				   "FLAC:  ${i}" \
				   "ERROR: Not a FLAC file or failed testing." \
				   "------------------------------------------------------------------" \
				   >> "${test_errors}"

			# Add one to fail count
			__fail_count
		fi
	done
}

# Test FLAC validity with auCDtect
__operation_aucdtect () {
	for i ; do
		# Add one (iteration)
		__iterate_count

		__print_aucdtect_flac

		# Get the bit depth of a FLAC file, also used to check
		# if FLAC file is real.  Hide stderr output
		bits="$(metaflac --show-bps "${i}" 2> /dev/null)"

		# Exit code 130 is SIGINT so only check for exit code '1'
		if [[ "${?}" -eq "1" ]] ; then
			# File is not a FLAC file, display failed
			__print_failed_flac
			printf "%s\n%s\n%s\n" \
				   "FLAC:  ${i}" \
				   "ERROR: Not a FLAC file" \
				   "------------------------------------------------------------------" \
				   >> "${aucdtect_errors}"

			# Add one to fail count
			__fail_count

		# Skip the FLAC file if it has a bit depth greater
		# than 16 since auCDtect doesn't support audio
		# files with a higher resolution than a CD.
		elif [[ "${bits}" -gt "16" ]] ; then
			__print_aucdtect_skip
			printf "%s\n%s\n%s\n" \
				   "FLAC:  ${i}" \
				   "ERROR: The above file has a bit depth greater than 16 and was skipped" \
				   "------------------------------------------------------------------" \
				   >> "${aucdtect_errors}"

			# Add one to fail count
			__fail_count

		# FLAC checks out, continue processing
		else
			# The WAV file to be created from current FLAC file
			decoded_wav="${i%${flac_extension}}_redoflacs_"$$".wav"

			# Decompress FLAC to WAV so auCDtect can read the audio file
			flac --totally-silent -d "${i}" -o "${decoded_wav}"

			# Exit code 130 is SIGINT so only check for exit code '1'
			# If FLAC file failed decoding to WAV, log error, otherwise
			# continue processing
			if [[ "${?}" -eq "1" ]] ; then
				__print_failed_flac
				printf "%s\n%s\n%s\n" \
					   "FLAC:  ${i}" \
					   "ERROR: Failed decoding FLAC file to WAV (most likely corrupt)" \
					   "------------------------------------------------------------------" \
					   >> "${aucdtect_errors}"

				# Add one to fail count
				__fail_count

			else
				# 'export MALLOC_CHECK_' allows the dynamic linked version of auCDtect
				# to run without throwing errors
				export MALLOC_CHECK_="0"

				# The actual auCDtect command with highest accuracy setting
				# 2> hides the displayed progress to /dev/null disabling the progress percentage
				aucdtect_output="$("${aucdtect_command}" -m0 "${decoded_wav}" 2>/dev/null)"

				# Exit code 130 is SIGINT so only check for exit code '1'
				# If auCDtect failed to 
				if [[ "${?}" -eq "1" ]] ; then
					__print_failed_flac
					printf "%s\n%s\n%s\n%s\n%s\n%s\n" \
						   "FLAC:  ${i}" \
						   "WAV:   ${decoded_wav}" \
						   "ERROR: auCDtect failed to analyze the decoded WAV file." \
						   "       Something may have happened when decoding the above FLAC" \
						   "       file.  Please verify the FLAC file is not corrupt." \
						   "------------------------------------------------------------------" \
						   >> "${aucdtect_errors}"

					# Add one to fail count
					__fail_count

				else
					# Grab the conclusion of auCDtect's command by only
					# reading what is necessary:
					#    -s7:  Discard first seven lines from auCDtect's output
					#    -n1:  Only grab 1 line from auCDtect's output
					#     -t:  Remove trailing newlines from auCDtect's output
					#  array:  Store captured output into 'aucdtect_check_array'
					mapfile -s7 -n1 -t aucdtect_check_array <<< "${aucdtect_output}"

					# Remove the last line (blank line) from ${aucdtect_check_array[@]}
					aucdtect_check_array=( "${aucdtect_check_array[@]%$'\n'}" )

					# There is an issue with the processed FLAC file
					if [[ "${aucdtect_check_array[0]}" != "This track looks like CDDA with probability 100%" ]] ; then
						# If user specified '-A, --aucdtect-spectrogram', then
						# create a spectrogram with SoX and change logging accordingly
						if [[ "${create_spectrogram}" == "true" ]] ; then
							# Check whether to place spectrogram images in user-defined location
							if [[ "${spectrogram_location}" == "default" ]] ; then
								# Place images in same directory as the FLAC files
								# Make sure we don't clobber any picture files
								if [[ -f "${i%${flac_extension}}.png" ]] ; then
									# File exists so prepend "spectrogram" before ".png"
									spectrogram_picture="${i%${flac_extension}}.spectrogram.png"
								else
									# File doesn't exist, so create the spectrogram with the basename of "$i"
									# with ".png" as the extension
									spectrogram_picture="${i%${flac_extension}}.png"
								fi
							else
								# Place images in user-defined location
								flac_file="${i##*/}"
								spectrogram_picture="${spectrogram_location}/${flac_file%${flac_extension}}.png"
							fi

							# Let's create the spectrogram for the failed FLAC file
							# and output progress
							__print_aucdtect_spectrogram

							# SoX command to create the spectrogram and place it in spectrogram_picture
							"${sox_command}" "${i}" -n spectrogram -c '' -t "${i}" -p1 -z90 -Z0 -q249 -wHann -x1800 -y513 -o "${spectrogram_picture}"

							# Use the below version of the command to create hi-res spectrograms
							#"${sox_command}" "${i}" -n spectrogram -c '' -t "${i}" -p1 -z90 -Z0 -q249 -wHann -x5000 -y1025 -o "${spectrogram_picture}"

							# Print ISSUE and log error, and show where to find
							# the created spectrogram of the processed FLAC file
							__print_aucdtect_issue
							printf "%s\n%s\n%s\n%s\n" \
								   "FLAC:        ${i}" \
								   "ERROR:       ${aucdtect_check_array[0]}" \
								   "SPECTROGRAM: ${spectrogram_picture}" \
								   "------------------------------------------------------------------" \
								   >> "${aucdtect_errors}"

							# Add one to fail count
							__fail_count

						else
							# Print ISSUE and log error
							__print_aucdtect_issue
							printf "%s\n%s\n%s\n" \
								   "FLAC:  ${i}" \
								   "ERROR: ${aucdtect_check_array[0]}" \
								   "------------------------------------------------------------------" \
								   >> "${aucdtect_errors}"

							# Add one to fail count
							__fail_count
						fi
					fi

					# Remove temporary WAV file
					rm "${decoded_wav}"
				fi
			fi
		fi
	done
}

# Check MD5 in each FLAC file
__operation_md5_check () {
	for i ; do
		# Add one (iteration)
		__iterate_count

		__print_checking_md5

		# Get the MD5 checksum (hide stderr output).  Also
		# used to check if FLAC file is real
		md5_sum="$(metaflac --show-md5sum "${i}" 2> /dev/null)"

		# Exit code 130 is SIGINT so only check for exit code '1'
		if [[ "${?}" -eq "1" ]] ; then
			# File is not a FLAC file, display failed
			__print_failed_flac
			printf "%s\n%s\n%s\n" \
				   "FLAC:  ${i}" \
				   "ERROR: Not a FLAC file" \
				   "------------------------------------------------------------------" \
				   >> "${md5_errors}"

			# Add one to fail count
			__fail_count

		# FLAC file is real, check for unset MD5 checksum
		elif [[ "${md5_sum}" == "00000000000000000000000000000000" ]] ; then
			__print_failed_flac
			printf "%s\n%s\n%s\n" \
				   "FLAC:  ${i}" \
				   "ERROR: MD5 Signature unset: (${md5_sum})" \
				   "------------------------------------------------------------------" \
				   >> "${md5_errors}"

			# Add one to fail count
			__fail_count
		fi
	done
}

# Analyze FLAC tags
__operation_analyze_tags () {
	for i ; do
		# Add one (iteration)
		__iterate_count

		__print_analyzing_tags

		# Recreate the tags array so it can be parsed easily
		eval "tags=(${exported_tags})"

		# Check if file is a FLAC file (variable hides output)
		check_flac="$(metaflac --show-md5sum "${i}" 2>&1)"

		# If above command return anything other than '0', log output
		if [[ "${?}" -ne "0" ]] ; then
			printf "%s\n%s\n%s\n" \
				  "FLAC:  ${i}" \
				  "ERROR: The above file does not appear to be a FLAC file" \
				  "------------------------------------------------------------------" \
				  >> "${metadata_errors}"

			# Add one to fail count
			__fail_count
		else
			# Iterate through each tag field and check if tag is missing
			for j in "${tags[@]}" ; do
				# Check if ALBUMARTIST is in tag array and apply operations on
				# the tag field if it exists
				if [[ "${j}" == "ALBUMARTIST" ]] ; then
					# ALBUMARTIST exists in tag array so allow script to check the
					# various naming conventions within the FLAC files (ie,
					# 'ALBUM ARTIST' or 'ALBUM_ARTIST')

					# "ALBUMARTIST" or "ALBUM ARTIST" or "ALBUM_ARTIST", case-insensitive
					if [[ -n "$(metaflac --show-tag=ALBUMARTIST "${i}")" ]] ; then
						show_tag_list+=( "--show-tag=ALBUMARTIST" )

					elif [[ -n "$(metaflac --show-tag="ALBUM ARTIST" "${i}")" ]] ; then
						show_tag_list+=( "--show-tag='ALBUM ARTIST'" )

					elif [[ -n "$(metaflac --show-tag="ALBUM_ARTIST" "${i}")" ]] ; then
						show_tag_list+=( "--show-tag=ALBUM_ARTIST" )
					fi
				else
					# Build up metaflac '--show-tag=' list
					show_tag_list+=( "--show-tag=${j}" )
				fi
			done

			# Load up all the tag values for current file
			mapfile -n0 -t metaflac_tag_array < \
			<(
				metaflac \
					"${show_tag_list[@]}" \
					"${i}"
			)

			# Take above tag values and create an associative
			# array using TAG_FIELD=TAG_VALUE as the key/value pair
			#
			# Specifically declare an empty associative array
			declare -A temp_tag_array

			# Run through the tag array from above and store
			# the values into a temporary tag array
			for tag_field_value in "${metaflac_tag_array[@]}" ; do
				# This is the tag field (eg. TITLE)
				tag_field="${tag_field_value%%=*}"

				# Enforce the tag field to be uppercase
				# ${tag_field_value} below is the tag value
				temp_tag_array+=( ["${tag_field^^}"]="${tag_field_value#*=}" )
			done

			# Run through the tags array (from USER CONFIGURATION) and test
			# each tag value from ${temp_tag_array} with the currently
			# processed tag in ${tag[@]}.  For each match found, test if the
			# tag value is null, reporting any missing tags. Then remove the
			# tag field (index) from the ${temp_tag_array}, so the next iteration
			# is faster and we can check for missing tags (tag fields)
			for j in "${tags[@]}" ; do

				# If the total # of indices in the temporary tag array is above
				# 0, continue testing, else store missing tag (${j}) into the
				# missing tags array
				if [[ "${#temp_tag_array[@]}" -gt 0 ]] ; then

					# Compare each tag field from the temporary array to ${j},
					# checking if they are equal and if so, check for missing
					# tag values
					for temp_tag_field in "${!temp_tag_array[@]}" ; do
						# Both tag fields are equal
						if [[ "${j}" == "${temp_tag_field}" ]] ; then
							# Check if tag value is null, logging missing tags if so
							if [[ -z "${temp_tag_array[${temp_tag_field}]}" ]] ; then
								if [[ "${file_printed}" != "true" ]] ; then
									# First instance of missing tag for current file
									missing_tags_array+=(
										"FLAC:  ${i}"
										"ERROR: ${j} tag not found"
									)
									file_printed="true"
								else
									# If more than one missing tag in current file,
									# don't print out filename, just the missing tag
									missing_tags_array+=( "       ${j} tag not found" )
								fi
							fi

							# Remove the current tag field from the temporary tag
							# array since it's been matched already
							unset -v temp_tag_array[${temp_tag_field}]

							# This variable let's the script know that the current
							# tag, ${j} has been matched up with a tag field in
							# ${temp_tag_array[@]}
							tag_match="true"

							# Break out of loop since the tag fields have been
							# matched, continuing on to the next iteration of ${j}
							break
						fi
					done

					# If there wasn't a tag field in the temporary tag array
					# ( eg. ${temp_tag_array[@]} ) that matched ${j}, the FLAC file
					# must have a missing tag, so log it by throwing the missing tag
					# into the missing tags array
					if [[ "${tag_match}" != "true" ]] ; then
						if [[ "${file_printed}" != "true" ]] ; then
							# First instance of missing tag for current file
							missing_tags_array+=(
								"FLAC:  ${i}"
								"ERROR: ${j} tag not found"
							)
							file_printed="true"
						else
							# If more than one missing tag in current file,
							# don't print out filename, just the missing tag
							missing_tags_array+=( "       ${j} tag not found" )
						fi
					fi

					# Reset the value of tag match (if any) for the next iteration
					# of ${j}
					unset -v tag_match

				# The total # of indices in the temporary tag array is 0, so
				# whatever is left in ${tags[@]} represented by ${j} is logged
				# as missing
				else
					if [[ "${file_printed}" != "true" ]] ; then
						# First instance of missing tag for current file
						missing_tags_array+=(
							"FLAC:  ${i}"
							"ERROR: ${j} tag not found"
						)
						file_printed="true"
					else
						# If more than one missing tag in current file,
						# don't print out filename, just the missing tag
						missing_tags_array+=( "       ${j} tag not found" )
					fi
				fi
			done

			# If missing_tags_array is not empty, there are missing
			# tags in the current file so log output
			if [[ -n "${missing_tags_array[@]}" ]] ; then
				# Add separator to log for each file
				missing_tags_array+=( "------------------------------------------------------------------" )
				# Print array into log file
				printf "%s\n" "${missing_tags_array[@]}" >> "${metadata_errors}"

				# Add one to fail count
				__fail_count
			fi
		fi
	done
}

# Analyze FLAC tags (not logging missing COVERART tag)
__operation_analyze_tags_dont_log_coverart () {
	for i ; do
		# Add one (iteration)
		__iterate_count

		__print_analyzing_tags

		# Recreate the tags array so it can be parsed easily
		eval "tags=(${exported_tags})"

		# Check if file is a FLAC file (variable hides output)
		check_flac="$(metaflac --show-md5sum "${i}" 2>&1)"

		# If above command return anything other than '0', log output
		if [[ "${?}" -ne "0" ]] ; then
			printf "$%s\n%s\n%s\n" \
				   "FLAC:  ${i}" \
				   "ERROR: The above file does not appear to be a FLAC file" \
				   "------------------------------------------------------------------" \
				   >> "${metadata_errors}"
			# File is not a FLAC file, display failed
			__print_failed_flac

			# Add one to fail count
			__fail_count
		else
			# Album artwork is to be kept so preserve COVERART by adding
			# it to the tag array (temporary)
			tags+=( COVERART )

			# Iterate through each tag field and check if tag is missing (except
			# for the COVERART tag)
			for j in "${tags[@]}" ; do
				# Check if ALBUMARTIST is in tag array and apply operations on
				# the tag field if it exists
				if [[ "${j}" == "ALBUMARTIST" ]] ; then
					# ALBUMARTIST exists in tag array so allow script to check the
					# various naming conventions within the FLAC files (ie,
					# 'ALBUM ARTIST' or 'ALBUM_ARTIST')

					# "ALBUMARTIST" or "ALBUM ARTIST" or "ALBUM_ARTIST", case-insensitive
					if [[ -n "$(metaflac --show-tag=ALBUMARTIST "${i}")" ]] ; then
						show_tag_list+=( "--show-tag=ALBUMARTIST" )

					elif [[ -n "$(metaflac --show-tag="ALBUM ARTIST" "${i}")" ]] ; then
						show_tag_list+=( "--show-tag='ALBUM ARTIST'" )

					elif [[ -n "$(metaflac --show-tag="ALBUM_ARTIST" "${i}")" ]] ; then
						show_tag_list+=( "--show-tag=ALBUM_ARTIST" )
					fi
				else
					# Build up metaflac '--show-tag=' list
					show_tag_list+=( "--show-tag=${j}" )
				fi

				# Check if COVERART exists and is not null
				if [[ "${j}" == "COVERART" ]] ; then
					# Obtain COVERART value
					coverart_value="$(metaflac --show-tag=COVERART "${i}")"

					# If COVERART value is not null, so log it exists and that
					# COVERART tag is depcrated
					if [[ -n "${coverart_value#*=}" ]] ; then
						printf "%s\n%s\n%s\n%s\n" \
							   "FLAC:  ${i}" \
							   "ERROR: \"${j}\" tag is DEPRECATED in above file. Consider migrating to" \
							   "       the new format: METADATA_BLOCK_PICTURE." \
							   "------------------------------------------------------------------" \
							   >> "${metadata_errors}"

						# Add one to fail count
						__fail_count
					fi
				fi
			done

			# Load up all the tag values for current file
			mapfile -n0 -t metaflac_tag_array < \
			<(
				metaflac \
					"${show_tag_list[@]}" \
					"${i}"
			)

			# Take above tag values and create an associative
			# array using TAG_FIELD=TAG_VALUE as the key/value pair
			#
			# Specifically declare an empty associative array
			declare -A temp_tag_array

			# Run through the tag array from above and store
			# the values into a temporary tag array
			for tag_field_value in "${metaflac_tag_array[@]}" ; do
				# This is the tag field (eg. TITLE)
				tag_field="${tag_field_value%%=*}"

				# Enforce the tag field to be uppercase
				# ${tag_field_value} below is the tag value
				temp_tag_array+=( ["${tag_field^^}"]="${tag_field_value#*=}" )
			done

			# Run through the tags array (from USER CONFIGURATION) and test
			# each tag value from ${temp_tag_array} with the currently
			# processed tag in ${tag[@]}.  For each match found, test if the
			# tag value is null, reporting any missing tags. Then remove the
			# tag field (index) from the ${temp_tag_array}, so the next iteration
			# is faster and we can check for missing tags (tag fields)
			for j in "${tags[@]}" ; do

				# If the total # of indices in the temporary tag array is above
				# 0, continue testing, else store missing tag (${j}) into the
				# missing tags array
				if [[ "${#temp_tag_array[@]}" -gt 0 ]] ; then

					# Compare each tag field from the temporary array to ${j},
					# checking if they are equal and if so, check for missing
					# tag values.
					# Skip output of COVERART tag as this is a temporary
					# addition to the tag array (for processing legacy artwork)
					for temp_tag_field in "${!temp_tag_array[@]}" ; do
						# Both tag fields are equal
						if [[ "${j}" == "${temp_tag_field}" && "${j}" != "COVERART" ]] ; then
							# Check if tag value is null, logging missing tags if so
							if [[ -z "${temp_tag_array[${temp_tag_field}]}" ]] ; then
								if [[ "${file_printed}" != "true" ]] ; then
									# First instance of missing tag for current file
									missing_tags_array+=(
										"FLAC:  ${i}"
										"ERROR: ${j} tag not found"
									)
									file_printed="true"
								else
									# If more than one missing tag in current file,
									# don't print out filename, just the missing tag
									missing_tags_array+=( "       ${j} tag not found" )
								fi
							fi

							# Remove the current tag field from the temporary tag
							# array since it's been matched already
							unset -v temp_tag_array[${temp_tag_field}]

							# This variable let's the script know that the current
							# tag, ${j} has been matched up with a tag field in
							# ${temp_tag_array[@]}
							tag_match="true"

							# Break out of loop since the tag fields have been
							# matched, continuing on to the next iteration of ${j}
							break
						fi
					done

					# If there wasn't a tag field in the temporary tag array
					# ( eg. ${temp_tag_array[@]} ) that matched ${j}, the FLAC file
					# must have a missing tag, so log it by throwing the missing tag
					# into the missing tags array.  Also skip logging of COVERART tag
					if [[ "${tag_match}" != "true" && "${j}" != "COVERART" ]] ; then
						if [[ "${file_printed}" != "true" ]] ; then
							# First instance of missing tag for current file
							missing_tags_array+=(
								"FLAC:  ${i}"
								"ERROR: ${j} tag not found"
							)
							file_printed="true"
						else
							# If more than one missing tag in current file,
							# don't print out filename, just the missing tag
							missing_tags_array+=( "       ${j} tag not found" )
						fi
					fi

					# Reset the value of tag match (if any) for the next iteration
					# of ${j}
					unset -v tag_match

				# The total # of indices in the temporary tag array is 0, so
				# whatever is left in ${tags[@]} represented by ${j} is logged
				# as missing.  Also skip logging of COVERART tag
				elif [[ "${j}" != "COVERART" ]] ; then
					if [[ "${file_printed}" != "true" ]] ; then
						# First instance of missing tag for current file
						missing_tags_array+=(
							"FLAC:  ${i}"
							"ERROR: ${j} tag not found"
						)
						file_printed="true"
					else
						# If more than one missing tag in current file,
						# don't print out filename, just the missing tag
						missing_tags_array+=( "       ${j} tag not found" )
					fi
				fi
			done

			# If missing_tags_array is not empty, there are missing
			# tags in the current file so log output
			if [[ -n "${missing_tags_array[@]}" ]] ; then
				# Add separator to log for each file
				missing_tags_array+=( "------------------------------------------------------------------" )
				# Print array into log file
				printf "%s\n" "${missing_tags_array[@]}" >> "${metadata_errors}"

				# Add one to fail count
				__fail_count
			fi
		fi
	done
}

# Re-tag FLAC files
__operation_set_tags () {
	for i ; do
		# Add one (iteration)
		__iterate_count

		__print_applying_tags

		# Recreate the tags array so it can be parsed easily
		eval "tags=(${exported_tags})"

		# Remove and set new tags
		#
		# Iterate through the tag array and set a variable for each tag
		for j in "${tags[@]}" ; do
			# Check if ALBUMARTIST is in tag array and apply operations on
			# the tag field if it exists
			if [[ "${j}" == "ALBUMARTIST" ]] ; then
				# ALBUMARTIST exists in tag array so allow script to check the
				# various naming conventions within the FLAC files (ie,
				# 'ALBUM ARTIST' or 'ALBUM_ARTIST')

				# "ALBUMARTIST"
				if [[ -n "$(metaflac --show-tag=ALBUMARTIST "${i}")" ]] ; then
					show_tag_list+=( "--show-tag=ALBUMARTIST" )

				elif [[ -n "$(metaflac --show-tag="ALBUM ARTIST" "${i}")" ]] ; then
					show_tag_list+=( "--show-tag='ALBUM ARTIST'" )

				elif [[ -n "$(metaflac --show-tag="ALBUM_ARTIST" "${i}")" ]] ; then
					show_tag_list+=( "--show-tag=ALBUM_ARTIST" )
				fi
			else
				# Build up metaflac '--show-tag=' list
				show_tag_list+=( "--show-tag=${j}" )
			fi
		done

		# Load up all the tag values for current file
		mapfile -n0 -t metaflac_tag_array < \
		<(
			metaflac \
				"${show_tag_list[@]}" \
				"${i}"
		)

		# Add the saved tags back, by printing each tag field and value
		# on a separate line to STDOUT.  This will be read in by metaflac.
		# Use process substitution to allow this to finish if user
		# invokes SIGINT
		metaflac --remove-all-tags --import-tags-from=- "${i}" < \
		<(
			# This prints each tag key and value pair
			# (eg. ARTIST=Kamelot)
			printf "%s\n" "${metaflac_tag_array[@]}"
		)
	done
}

# Prune FLACS
__operation_prune () {
	for i ; do
		# Add one (iteration)
		__iterate_count

		__print_prune_flac

		# Check if file is a FLAC file (hide output)
		metaflac --show-md5sum "${i}" >/dev/null 2>&1

		# Exit code 130 is SIGINT so only check for exit code '1'
		if [[ "${?}" -eq "1" ]] ; then
			# File is not a FLAC file, display failed
			__print_failed_flac
			printf "%s\n%s\n%s\n" \
				   "FLAC:  ${i}" \
				   "ERROR: The above file does not appear to be a FLAC file" \
				   "------------------------------------------------------------------" \
				   >> "${prune_errors}"

			# Add one to fail count
			__fail_count
		else
			# Remove all information but STREAMINFO,VORBIS_COMMENTs, and
			# possibly METADATA_BLOCK_PICTURE
			metaflac --remove --dont-use-padding --except-block-type="${dont_prune_flac_metadata}" "${i}"
		fi
	done
}
export -f __operation_prune
#== END OPERATIONS =============================================================


#-------------------------------------------------------------------------------
#  PRE-SCRIPT CHECKS
#-------------------------------------------------------------------------------
# Enable BASH 4 globstar
shopt -s globstar

# Process positional parameters, allowing script to see
# which operations to run.  Make sure we send all the positional
# parameters called to the function, otherwise the function will
# think there aren't any positional parameters to process as it
# handles it's own positional parameters
__process_positional_parameters "${@}"

# Check if user set '-n, --no-color'
# This must come before everything (and after
# the positional parameters) to ensure color
# is set/unset
if [[ "${no_color}" == "true" ]] ; then
	blue=""
	green=""
	red=""
	cyan=""
	magenta=""
	yellow=""
	normal=""
fi

# Make sure we are running BASH 4 or greater
bash_version_check="${BASH_VERSION%%.*}"
if [[ "${bash_version_check}" -lt 4 ]] ; then
	{ __error "You must be running BASH version 4 or greater to use" ; __newline ;} >&2
	{ __error "this program!" ; __newline ;} >&2
	exit 1
fi

# Check for any conflicting operations/arguments called
# at script invocation and warn user
__check_conflicting_operations

# Check for any missing programs vital for this script
# to operate correctly, and exit if any programs are found
# to be missing
__check_missing_programs

# Check whether directory exists
if [[ ! -d "${directory}" ]] ; then
	{ printf "%s\n" "  Usage: ${0} [OPTION] [PATH_TO_FLAC(s)]..." ;} >&2
	{ __error "Please specify a directory!" ; __newline ;} >&2

	exit 1
fi

# Check for at least 1 FLAC file
read -r find_flacs < <( printf "%s\n" "${directory}"/**/*${flac_extension} )

# No FLAC files found
if [[ ! -f "${find_flacs}" ]] ; then
	__no_flacs
	exit 1
fi

# If ${jobs} wasn't set upon invocation, check in /proc
# to see how many jobs should be run
if [[ -z "${jobs}" ]] ; then
	__find_cores
else
	jobs_display="(User Defined)"
fi
#== END PRE-SCRIPT CHECKS ======================================================


#-------------------------------------------------------------------------------
#  START SCRIPT
#-------------------------------------------------------------------------------
# Store current stty settings
old_stty="$(stty -g)"

# Prevent Control-C from displaying '^C'.  May already be set
stty -ctlecho 2> /dev/null

# Hide the cursor
printf "\033[?25l"

# Temporary FIFO location
export tmp_fifo="/tmp/redoflacs_fifo_$$"

# Temporary count file
export tmp_count_file="/tmp/redoflacs_count_iteration_$$"

# Temporary fail count
export tmp_fail_count="/tmp/redoflacs_fail_count_$$"

# Temporary filename
export tmp_filename="/tmp/redoflacs_filename_$$"

# Display the top banner
if [[ "${retag_flac}" != "true" ]] ; then
	# Display top banner
	__top_banner
else
	# Force all the tag fields to be uppercase
	tags=( "${tags[@]^^}" )

	# Check for coverart conflicts.  Needed here
	# to allow script to exit right away if there
	# is a conflict
	__coverart_remove_conflict

	# Display a countdown before continuing
	__countdown_metadata

	# Display top banner
	__top_banner
fi

# Grab the total flacs to process
total_flacs_array=( "${directory}"/**/*${flac_extension} )
export total_flacs="${#total_flacs_array[@]}"

# String length of total number of flacs
total_flacs_length="${#total_flacs_array[@]}"
export total_flacs_length="${#total_flacs_length}"

# This displays '[ ok ]' after 'Finding FLAC files to process...'
__processed_flacs_ok

#-------------------------------------------------------------------------------
#  AUCDTECT
#-------------------------------------------------------------------------------
# The below order is probably the best bet in ensuring time
# isn't wasted on doing unnecessary operations if the
# FLAC files are corrupt or have metadata issues
if [[ "${aucdtect_flac}" == "true" ]] ; then

	# Check if auCDtect is found/installed
	export aucdtect_command="$(command -v auCDtect)"

	if [[ -z "${aucdtect_command}" ]] ; then
		# Check alternate spelling
		export aucdtect_command="$(command -v aucdtect)"
	fi

	if [[ -z "${aucdtect_command}" ]] ; then
		# auCDtect can't be found, exit
		{ __error "It appears auCDtect is not installed. Please verify you" ; __newline ;} >&2
		{ __error "have this program installed and can be found in \$PATH" ; __newline ;} >&2

		exit 1
	fi

	# If "-A, --aucdtect-spectrogram" was called
	# make sure SoX is installed before starting
	if [[ "${create_spectrogram}" == "true" ]] ; then
		# Check if SoX is found/installed
		export sox_command="$(command -v sox)"

		if [[ -z "${sox_command}" ]] ; then
			# SoX can't be found, exit
			{ __error "It appears SoX is not installed. Please verify you" ; __newline ;} >&2
			{ __error "have this program installed and can be found in \$PATH" ; __newline ;} >&2

			exit 1
		fi
	fi

	# Check if spectrogram_location is user-defined
	if [[ "${spectrogram_location}" != "default" ]] ; then

		# Put spectrograms in user-defined location
		# Test to make sure directory exists
		if [[ ! -d "${spectrogram_location}" ]] ; then
			{ __error "\"${spectrogram_location}\" doesn't exist!" ; __newline ;} >&2
			{ __error "Please choose a valid directory under USER CONFIGURATION!" ; __newline ;} >&2

			exit 1
		fi
	fi

	__title_aucdtect_flac

	# Trap SIGINT (Control-C) to abort cleanly
	trap __aucdtect_abort SIGINT

	# Clear/initialize iteration
	> "${tmp_count_file}"

	# Unset any functions that were a result of previous operations
	__tidy_env

	# Export the necessary functions to allow subshell access
	export -f \
		__operation_aucdtect \
		__aucdtect_abort \
		__print_aucdtect_flac \
		__print_aucdtect_issue \
		__print_aucdtect_spectrogram \
		__print_aucdtect_skip \
		__print_ok_flac \
		__print_failed_flac \
		__print_interrupt \
		__log_aucdtect

	# Run the above function with the configured jobs
	find "${directory}" -name "*${flac_extension}" -print0 2> /dev/null | xargs -0 -n 1 -P "${jobs}" bash -c '__operation_aucdtect "${@}"' --

	if [[ -f "${aucdtect_errors}" ]] ; then
		__log_aucdtect

		aucdtect_complete="false"
		__operation_summary

		exit 1
	fi

	# auCDtect completed successfully
	__print_ok_flac ; __newline
	aucdtect_complete="true"
fi
#== END AUCDTECT ===============================================================


#-------------------------------------------------------------------------------
#  COMPRESS/VERIFY
#-------------------------------------------------------------------------------
if [[ "${compress_flac}" == "true" ]] ; then

	# Set the correct title operation to print depending
	# what was called
	if [[ "${skip_test}" == "true" ]] ; then
		title_compress="__title_compress_notest_flac"
	else
		title_compress="__title_compress_flac"
	fi

	# Prints title message of current operation
	# ${title_compress} is an alias to the command to
	# run determined earlier
	"${title_compress}"

	# Trap SIGINT (Control-C) to abort cleanly
	trap __compress_abort SIGINT

	# Clear/initialize iteration
	> "${tmp_count_file}"

	# Unset any functions that were a result of previous operations
	__tidy_env

	# Export the necessary functions to allow subshell access
	export -f \
		__operation_compress \
		__compress_abort \
		__print_compressing_flac \
		__print_level_same_compression \
		__print_testing_flac \
		__print_ok_flac \
		__print_failed_flac \
		__print_interrupt \
		__log_compress_verify

	# Run the above function with the configured jobs
	find "${directory}" -name "*${flac_extension}" -print0 2> /dev/null | xargs -0 -n 1 -P "${jobs}" bash -c '__operation_compress "${@}"' --

	if [[ -f "${verify_errors}" ]] ; then
		__log_compress_verify

		compress_complete="false"
		__operation_summary

		exit 1
	fi

	# Compress FLACS completed successfully
	__print_ok_flac ; __newline
	compress_complete="true"
fi
#== END COMPRESS/VERIFY ========================================================


#-------------------------------------------------------------------------------
#  TEST
#-------------------------------------------------------------------------------
if [[ "${test_flac}" == "true" ]] ; then
	__title_testing_flac

	# Trap SIGINT (Control-C) to abort cleanly
	trap __test_abort SIGINT

	# Clear/initialize iteration
	> "${tmp_count_file}"

	# Unset any functions that were a result of previous operations
	__tidy_env

	# Export the necessary functions to allow subshell access
	export -f \
		__operation_test \
		__test_abort \
		__print_testing_flac \
		__print_ok_flac \
		__print_failed_flac \
		__print_interrupt \
		__log_test

	# Run the above function with the configured jobs
	find "${directory}" -name "*${flac_extension}" -print0 2> /dev/null | xargs -0 -n 1 -P "${jobs}" bash -c '__operation_test "${@}"' --

	if [[ -f "${test_errors}" ]] ; then
		__log_test

		test_complete="false"
		__operation_summary

		exit 1
	fi

	# Test FLACS completed successfully
	__print_ok_flac ; __newline
	test_complete="true"
fi
#== END TEST ===================================================================


#-------------------------------------------------------------------------------
#  MD5 CHECK
#-------------------------------------------------------------------------------
if [[ "${md5check_flac}" == "true" ]] ; then
	__title_md5check_flac

	# Trap SIGINT (Control-C) to abort cleanly
	trap __md5_check_abort SIGINT

	# Clear/initialize iteration
	> "${tmp_count_file}"

	# Unset any functions that were a result of previous operations
	__tidy_env

	# Export the necessary functions to allow subshell access
	export -f \
		__operation_md5_check \
		__md5_check_abort \
		__print_checking_md5 \
		__print_ok_flac \
		__print_failed_flac \
		__print_interrupt \
		__log_md5_check

	# Run the above function with the configured jobs
	find "${directory}" -name "*${flac_extension}" -print0 2> /dev/null | xargs -0 -n 1 -P "${jobs}" bash -c '__operation_md5_check "${@}"' --

	if [[ -f "${md5_errors}" ]] ; then
		__log_md5_check

		md5check_complete="false"
		__operation_summary

		exit 1
	fi

	# MD5 Check completed successfully
	__print_ok_flac ; __newline
	md5check_complete="true"
fi
#== END MD5 CHECK ==============================================================


#-------------------------------------------------------------------------------
#  REPLAYGAIN
#-------------------------------------------------------------------------------
if [[ "${replaygain_flac}" == "true" ]] ; then

	# Check if "-G, --replaygain-noforce" was called
	if [[ "${replaygain_noforce}" == "true" ]] ; then
		export process_replaygain="__operation_replaygain_noforce"
	else
		export process_replaygain="__operation_replaygain_force"
	fi

	# Prints title message of current operation
	__title_replaygain

	#---------------------------------------------------------------------------
	#  TEST REPLAYGAIN
	#---------------------------------------------------------------------------
	# Trap SIGINT (Control-C) to abort cleanly
	trap __replaygain_test_abort SIGINT

	# Clear/initialize iteration
	> "${tmp_count_file}"

	# Prints sub message of current operation
	__sub_test_replaygain

	# Unset any functions that were a result of previous operations
	__tidy_env

	# Export the necessary functions to allow subshell access
	export -f \
		__operation_test_replaygain \
		__replaygain_test_abort \
		__print_test_replaygain \
		__print_ok_replaygain_file \
		__print_failed_flac \
		__print_interrupt_replaygain_file \
		__log_replaygain_test

	# Run the above function with the configured jobs
	find "${directory}" -name "*${flac_extension}" -print0 2> /dev/null | xargs -0 -n 1 -P "${jobs}" bash -c '__operation_test_replaygain "${@}"' --

	if [[ -f "${replay_test_errors}" ]] ; then
		__log_replaygain_test

		testing_replaygain_complete="false"
		__operation_summary

		exit 1
	fi

	# ReplayGain test completed successfully
	__print_ok_replaygain_file
	testing_replaygain_complete="true"
	#== END TEST REPLAYGAIN ====================================================


	#---------------------------------------------------------------------------
	#  PROCESS REPLAYGAIN
	#---------------------------------------------------------------------------
	# Trap SIGINT (Control-C) to abort cleanly
	trap __replaygain_process_abort SIGINT

	# Clear/initialize iteration
	> "${tmp_count_file}"

	# Make printing pretty if specified directory is '.'
	if [[ "${directory}" == "." ]] ; then
		directory="${PWD}"
	fi

	# Grab number of directories to process provided as
	# ${total_directories}
	__total_directories

	# Prints sub message of current operation
	__sub_add_replaygain

	# Unset any functions that were a result of previous operations
	__tidy_env

	# Export the necessary functions to allow subshell access
	export -f \
		__operation_replaygain_force \
		__operation_replaygain_noforce \
		__replaygain_process_abort \
		__print_add_replaygain \
		__print_ok_replaygain_dir \
		__print_failed_replaygain \
		__print_interrupt_replaygain_dir \
		__log_replaygain_process

	# Run the above function with the configured jobs
	printf "%s\0" "${flac_directories_array[@]}" | xargs -0 -n 1 -P "${jobs}" bash -c '${process_replaygain} "${@}"' --

	if [[ -f "${replay_add_errors}" ]] ; then
		__log_replaygain_process

		adding_replaygain_complete="false"
		__operation_summary

		exit 1
	fi

	# ReplayGain processing completed successfully
	__print_ok_replaygain_dir ; __newline
	adding_replaygain_complete="true"
	#== END PROCESS REPLAYGAIN =================================================
fi
#== END REPLAYGAIN =============================================================


#-------------------------------------------------------------------------------
#  RETAG
#-------------------------------------------------------------------------------
if [[ "${retag_flac}" == "true" ]] ; then

	# If COVERART tag doesn't appear in any of the FLAC files'
	# tags, and if the user wants artwork to be kept, don't log
	# missing COVERART tags (in the event that the script adds
	# it into the tag array)
	if [[ "${coverart_warning}" != "true" && "${remove_artwork}" == "false" ]] ; then

		# Analyze tags but don't log COVERART as a missing
		# tag (if applicable)
		export analyze_tags="__operation_analyze_tags_dont_log_coverart"
	else

		# Log all the missing tags found in the ${tags} array under
		# USER CONFIGURATION, including COVERART tag, regardless of
		# whether it was added by the script or explicitly chosen
		# by the user
		export analyze_tags="__operation_analyze_tags"
	fi

	# Prints title message of current operation
	__title_retag

	# Copy the tag array because we will need to use it
	# later as we are _may_ add a temporary element to the
	# tag array
	old_tags=( "${tags[@]}" )

	#---------------------------------------------------------------------------
	#  ANALYZE TAGS
	#---------------------------------------------------------------------------
	# Analyze FLAC tags to ensure none are missing and/or empty
	#
	# Trap SIGINT (Control-C) to abort cleanly
	trap __analyzing_tags_abort SIGINT

	# Clear/initialize iteration
	> "${tmp_count_file}"

	# Prints sub message of current operation
	__sub_analyze_tags

	# Export the tag array using some trickery (BASH doesn't
	# support exporting arrays natively)
	export exported_tags="$(printf "%s\n" "${tags[@]}")"

	# Unset any functions that were a result of previous operations
	__tidy_env

	# Export the necessary functions to allow subshell access
	export -f \
		__operation_analyze_tags \
		__operation_analyze_tags_dont_log_coverart \
		__analyzing_tags_abort \
		__print_analyzing_tags \
		__print_ok_tag \
		__print_failed_flac \
		__print_retag_analyze_interrupt \
		__log_missing_tags

	# Run the above function with the configured jobs
	find "${directory}" -name "*${flac_extension}" -print0 2> /dev/null | xargs -0 -n 1 -P "${jobs}" bash -c '${analyze_tags} "${@}"' --

	# Test for DEPRECATED tag, COVERART in METADATA_ERROR log.  If it
	# exists, set coverart_warning variable to make script output
	# warning upon completion
	if [[ -f "${metadata_errors}" ]] ; then
		while read -r i ; do
			# Indentation is culled from reading in "${i}"
			# To change this, set IFS to '\n'
			if [[ "${i}" == "the new format: METADATA_BLOCK_PICTURE." ]] ; then
				coverart_warning="true"
				break
			fi
		done < "${metadata_errors}"
	fi

	if [[ -f "${metadata_errors}"  && "${coverart_warning}" == "true" ]] ; then
		# Display COVERART warning function and metadata issues
		__newline >&2

		# Below is already redirected to STDERR
		__coverart_warning

		__log_missing_tags

		analyzing_retag_complete="false"
		__operation_summary

		exit 1
	elif [[ -f "${metadata_errors}" ]] ; then
		# Just display metadata issues
		__log_missing_tags

		analyzing_retag_complete="false"
		__operation_summary

		exit 1
	fi

	# Analyze Tags completed successfully
	__print_ok_tag
	analyzing_retag_complete="true"
	#== END ANALYZE TAGS =======================================================


	#---------------------------------------------------------------------------
	#  SET TAGS
	#---------------------------------------------------------------------------
	# Clear the old tags and re-tag with the kept tags
	#
	# Trap SIGINT (Control-C) to abort cleanly
	trap __applying_tags_abort SIGINT

	# Clear/initialize iteration
	> "${tmp_count_file}"

	# Restore the original tags array as the script _may_ have
	# added the COVERART tag.  This way, we ensure that the
	# COVERART tag was, in fact, temporary.
	tags=( "${old_tags[@]}" )

	# Export the tag array using some trickery (BASH doesn't
	# support exporting arrays natively)
	export exported_tags="$(printf "%s\n" "${tags[@]}")"

	# Prints sub message of current operation
	__sub_applying_tags

	# Unset any functions that were a result of previous operations
	__tidy_env

	# Export the necessary functions to allow subshell access
	export -f \
		__operation_set_tags \
		__applying_tags_abort \
		__print_applying_tags \
		__print_ok_tag \
		__print_failed_flac \
		__print_retag_apply_interrupt

	# Run the above function with the configured jobs
	find "${directory}" -name "*${flac_extension}" -print0 2> /dev/null | xargs -0 -n 1 -P "${jobs}" bash -c '__operation_set_tags "${@}"' --

	# Applying Tags completed successfully
	__print_ok_tag ; __newline
	applying_retag_complete="true"
	#== END SET TAGS ===========================================================
fi
#== END RETAG ==================================================================


#-------------------------------------------------------------------------------
#  PRUNE
#-------------------------------------------------------------------------------
if [[ "${prune_flac}" == "true" ]] ; then

	# Don't remove artwork if user wants it kept.  We don't have to check
	# for the legacy COVERART tag as we are NOT removing any VORBIS_COMMENTs.
	if [[ "${remove_artwork}" == "true" ]] ; then
		# Remove artwork
		export dont_prune_flac_metadata="STREAMINFO,VORBIS_COMMENT"
	else
		# Don't remove artwork
		export dont_prune_flac_metadata="STREAMINFO,PICTURE,VORBIS_COMMENT"
	fi

	__title_prune_flac

	# Trap SIGINT (Control-C) to abort cleanly	
	trap __prune_abort SIGINT

	# Clear/initialize iteration
	> "${tmp_count_file}"

	# Unset any functions that were a result of previous operations
	__tidy_env

	# Export the necessary functions to allow subshell access
	export -f \
		__operation_prune \
		__prune_abort \
		__print_prune_flac \
		__print_ok_flac \
		__print_failed_flac \
		__print_interrupt \
		__log_prune

	# Run the above function with the configured jobs
	find "${directory}" -name "*${flac_extension}" -print0 2> /dev/null | xargs -0 -n 1 -P "${jobs}" bash -c '__operation_prune "${@}"' --

	if [[ -f "${prune_errors}" ]] ; then
		__log_prune

		prune_complete="false"
		__operation_summary

		exit 1
	fi

	# Prune FLACS completed successfully
	__print_ok_flac ; __newline
	prune_complete="true"
fi
#== END PRUNE ==================================================================


# Display warning about legacy COVERART tag, if applicable
if [[ "${coverart_warning}" == "true" ]] ; then
	__coverart_warning
fi

# Display summary of completed tasks
__operation_summary
#== END SCRIPT =================================================================
