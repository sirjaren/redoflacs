#!/usr/bin/env bash
#-------------------------------------------------------------------------------
# redoflacs - Parallel BASH commandline FLAC compressor, verifier, organizer,
#             analyzer, and retagger
#-------------------------------------------------------------------------------
# ~ THIS IS THE UNIX/LINUX/BSD VERSION OF REDOFLACS ~
#-------------------------------------------------------------------------------
# Copyright (C) 2010-2014  Jaren Stangret
#-------------------------------------------------------------------------------
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#-------------------------------------------------------------------------------
# You can follow development of this script on Github at:
# https://github.com/sirjaren/redoflacs
#
# Please submit requests/changes/patches and/or comments
#-------------------------------------------------------------------------------
# File Descriptors used in this script:
#    0: STDIN
#    1: STDOUT
#    2: STDERR
#    3: Jobs process manager (FIFO)
#    4: auCDtect's STDOUT output
#-------------------------------------------------------------------------------

__info()  { printf " ${green}*${reset} ${@}"  ;}   # Bold green message
__warn()  { printf " ${yellow}*${reset} ${@}" ;}   # Yellow message
__error() { printf " ${red}*${reset} ${@}"    ;}   # Bold red message

#-------------------------------------------------------------------------------

__long_help() {
   # Display a lot of help
   #--
   # Set up local variables
   declare tmp_man_page="/tmp/redoflacs_man_$$.1"  # Temp man page
   declare long_help                               # Man page data

   long_help=".TH \"REDOFLACS\" 1
.SH NAME
redoflacs \\- Parallel BASH commandline FLAC compressor, verifier, organizer, analyzer, and retagger
.SH SYNOPSIS
.B redoflacs
.RI [operations]
.RI [options]
.RI [target]
.RI ...
.SH DESCRIPTION
redoflacs is a BASH commandline program providing a series of operations to help
manage and verify a user's FLAC music library.  One of the key features of
redoflacs is it's ability to process a great number of FLAC files in parallel,
using as many jobs to complete an operation as possible, very similar to 'GNU
make'.

redoflacs searches for a config file (if run as a user) in:

.br
        \\fB~/.config/redoflacs/config\\fP

.br
or (if run as root) in:

.br
        \\fB/etc/redoflacs.conf\\fP

If a config file is not found (in either place), one is created.

More information can be found at <\\fBhttps://github.com/sirjaren/redoflacs\\fP>.
.SH OPERATIONS
.TP
.BI -c, --compress
Compress the FLAC files with the user-specified level of compression defined
from the configuration file as 'compression_level' and verify the resultant
files.

The default is 8, with the range of values starting from 1 to 8 with the
smallest compression at 1, and the highest at 8.  This option will add a tag
(VORBIS_COMMENT) to all successfully verified FLAC files.  Below shows the
default COMPRESSION tag added to each successfully compressed (and verified)
FLAC file:

        COMPRESSION=8

If any FLAC files already have the defined compression_level tag (a good
indicator the files are already compressed at that level), the script will
instead test the FLAC files for any errors.  This is useful to check your entire
music library to make sure all the FLAC files are compressed at the level
specified as well as make sure they are intact (ie, not corrupt).

If any files are found to be corrupt, this script will quit upon finishing the
compression of any other files and produce an error log.
.TP
.BI -C, --compress-notest
Same as the '-c, --compress' option, but if any FLAC files already have the
defined compression_level tag, the script will skip the file and continue on to
the next without testing the FLAC file's integrity.  This is useful for checking
if all your FLAC files are compressed at the level specified.
.TP
.BI -t, --test
Same as '-c, --compress' but instead of compressing the FLAC files, this script
just verfies the integrity of them.  This option will NOT add the COMPRESSION
tag to the files.

As with the '-c, --compress' option, this will produce an error log if any FLAC
files are found to be corrupt.
.TP
.BI -a, --aucdtect
Use the auCDtect program by Oleg Berngardt and Alexander Djourik to analyze
FLAC files and check with fairly accurate precision whether the FLAC files are
lossy sourced or not.  For example, an MP3 file converted to FLAC is no longer
lossless therefore lossy sourced.

While this program isn't foolproof, it gives a good idea which FLAC files will
need further investigation (ie, a spectrogram).  This program does not work on
FLAC files which have a bit depth of more than a typical audio CD (16bit), and
will skip the files that have a higher bit depth.

If any files are found to not be perfect (ie, 100% CDDA via auCDtect), a log
will be created with the questionable FLAC files recorded in it.
.TP
.BI -A, --aucdtect-spectrogram
Same as '-a, --aucdtect' with the addition of creating a spectrogram for each
FLAC file that fails auCDtect, that is, any FLAC file that does not return 100%
CDDA from auCDtect will be scanned and a spectrogram will be created.

Any FLAC file skipped (due to having a higher bit depth than 16), will NOT have
a spectrogram created.

By default, each spectrogram will be created in the same folder as the tested
FLAC file name as follows:

        [<# of current file processed>] <filename>.png

An example of this:

        [ FLAC file (7th file processed) ]
              03 - Some FLAC File.flac

        [ Spectrogram Image ]
              [7] 03 - Some FLAC File.png

The user can change the location of where to store the created spectrogram
images by changing the value of 'spectrogram_location' defined in the
configuration file.  The location defined by the user will be tested to see if
it exists before starting the script.  If the location does NOT exist, the
script will warn the user and exit.

The created PNG file is large in resolution to best capture the FLAC file's
waveform (roughly 1800x513).

The spectrogram is created using the program SoX.  If the user tries to use this
option without having SoX installed, the script will warn the user that SoX is
missing and exit.
.TP
.BI -m, --md5check
Check the FLAC files for unset MD5 Signatures and log the output of any unset
signatures.  An unset MD5 signature doesn't necessarily mean a FLAC file is
corrupt, and MAY be repaired with a re-encoding of said FLAC file.
.TP
.BI -e, --extract-artwork
Run through each FLAC file and extract any and all artwork that's embedded
within the PICTURE block.  This is useful in the event a user wants to save any
artwork before using the '-p, --prune' option to remove the artwork.

By default, each extracted image will be placed in a subdirectory where the FLAC
file is located.  The subdirectory will have the same name as the current FLAC
being processed with a fairly unique string appended to it.  For example:

        [ Current FLAC file ]
              /path/to/music/01_file.flac

        [ Example subdirectory ]
              /path/to/music/01_file.flac_[redoflacs_art]_4342/

The user can change the location of where to store the extracted images by
changing the value of 'artwork_location' defined in the configuration file.  The
location defined by the user will be tested to see if it exists before starting
the script.  If the location does not exist, the script will warn the user and
exit.

This operation supports all the various types of embedded artwork that
\`metaflac' supports:

         0: Other
.br
         1: 32x32 pixels 'file icon' (PNG only)
.br
         2: Other file icon
.br
         3: Cover (front)
.br
         4: Cover (back)
.br
         5: Leaflet page
.br
         6: Media (e.g. label side of CD)
.br
         7: Lead artist/lead performer/soloist
.br
         8: Artist/performer
.br
         9: Conductor
.br
        10: Band/Orchestra
.br
        11: Composer
.br
        12: Lyricist/text writer
.br
        13: Recording Location
.br
        14: During recording
.br
        15: During performance
.br
        16: Movie/video screen capture
.br
        17: A bright coloured fish
.br
        18: Illustration
.br
        19: Band/artist logotype
.br
        20: Publisher/Studio logotype

If there is more than one image of the same type, this operation will append a
number after the image filename to prevent clobbering:

        [ Example subdirectory ]
              /path/to/music/01_file.flac_[redoflacs_art]_4342/

        [ More than image in subdirectory ]
              Cover (front) (1).jpg
              Cover (front) (2).jpg
              Cover (front) (3).jpg
              Cover (front) (4).jpg
              Cover (front) (5).jpg
.TP
.BI -p, --prune
Delete every METADATA block in each FLAC file except the STREAMINFO and
VORBIS_COMMENT block.  If 'remove_artwork' is not set as 'true', defined in the
configuration file, then the PICTURE block will NOT be removed.
.TP
.BI -g, --replaygain
Add ReplayGain values to FLAC files.  ReplayGain is calculated for ALBUM and
TRACK values and applied via VORBIS_COMMENTS and as such, will require the
'-r, --retag' option to have these tags kept (see '-r, --retag' option) in order
to preserve the added ReplayGain values.  The tags added are:

        REPLAYGAIN_REFERENCE_LOUDNESS
.br
        REPLAYGAIN_TRACK_GAIN
.br
        REPLAYGAIN_TRACK_PEAK
.br
        REPLAYGAIN_ALBUM_GAIN
.br
        REPLAYGAIN_ALBUM_PEAK

This option ignores any ReplayGain tags that may already be set, removing
existing values before applying new ones.

In order for ReplayGain values to be applied correctly, the script has to
determine which FLAC files to add values to by looking at the directory housing
said files.  That is, the script must add ReplayGain values by working off the
FLAC files' parent directory.  If there are some FLAC files found, the script
will move up one directory and begin applying ReplayGain values.  This is
necessary in order to get the REPLAYGAIN_ALBUM_GAIN and REPLAYGAIN_ALBUM_PEAK
values set correctly.  Without doing this, the ALBUM and TRACK values would be
identical.

If a user has many FLAC files under one directory (of different albums/artists),
the ReplayGain ALBUM values are going to be incorrect as the script will
perceive all those FLAC files to essentially be from the same album.  This is
mitigated by having each album in a separate directory.  Keep in mind,
multi-disc albums must be in separate directories in order to be processed with
different ALBUM GAIN and ALBUM PEAK values.

If there are any errors found while generating and/or applying ReplayGain
values, an error log will be produced.
.TP
.BI -G, --replaygain-noforce
Same as '-g, --replaygain' but will check for existing ReplayGain tags before
re-applying new ones.  If any one of the five ReplayGain tags are missing from
any FLAC file (mentioned above), the script will apply new values to each FLAC
file in that directory (first removing the old ReplayGain tags -- if any).

If all five ReplayGain tags are intact in every FLAC file (in a given
directory), that directory will be skipped and no new ReplayGain tags will be
added.
.TP
.BI -r, --retag
Extract the configured tags in each FLAC file and clear the rest before
retagging the file.  The default tags kept are:

        TITLE
.br
        ARTIST
.br
        ALBUM
.br
        DISCNUMBER
.br
        DATE
.br
        TRACKNUMBER
.br
        TRACKTOTAL
.br
        GENRE
.br
        COMPRESSION
.br
        RELEASETYPE
.br
        SOURCE
.br
        MASTERING
.br
        REPLAYGAIN_REFERENCE_LOUDNESS
.br
        REPLAYGAIN_TRACK_GAIN
.br
        REPLAYGAIN_TRACK_PEAK
.br
        REPLAYGAIN_ALBUM_GAIN
.br
        REPLAYGAIN_ALBUM_PEAK

If any FLAC files have missing tags (from those configured to be kept), the file
and the missing tag will be recorded in a log.

The tags that can be kept are essentially infinite, as long as the tags to be
kept are set in the TAGGING SECTION of the configuration file.

If this option is specified, a warning will appear upon script execution.  This
warning will show which of the configured TAG fields to keep when re-tagging the
FLAC files.  A countdown will appear giving the user 10 seconds to abort the
script, after which, the program will begin running it's course.
.TP
.BI -l, --all
This option is short for:

        -c, --compress
.br
        -m, --md5check
.br
        -p, --prune
.br
        -g, --replaygain
.br
        -r, --retag
.TP
.BI -L, --reallyall
This option is short for:

        -c, --compress
.br
        -m, --md5check
.br
        -p, --prune
.br
        -g, --replaygain
.br
        -r, --retag
.br
        -A, --aucdtect-spectrogram
.SH OPTIONS
.TP
.BI -j[N], --jobs[=N]
Set the number of parallel jobs to run on script invocation.  If this is not
set, this script will attempt to find the number of CPU cores available,
using the number found as the number of parallel jobs to run.

If the script is unable to find the number of CPU cores available, the number of
jobs will be set to two (2), by default.
.TP
.BI -n, --no-color
Turn off color output.
.TP
.BI -o, --new-config
Force the creation of a new configuration file.  This option does _NOT_
overwrite any existing configuration file.
.TP
.BI -v, --version
Display script version and exit.
.TP
.BI -h, --help
Shows this help message.
.SH FILES
.TP
.BI ~/.config/redoflacs/config
User configuration file.
.TP
.BI /etc/redoflacs.conf
System configuration file.
.SH BUGS
If you find a bug, please report it at:
<\\fBhttps://github.com/sirjaren/redoflacs/issues/new\\fP>
.SH AUTHOR
Jaren Stangret <sirjaren@gmail.com>
.SH THANKS
Thanks to all the people whom have provided feedback and support!
.br
.SH REVISION
[ 4 ]"

   printf "%s\n" "${long_help}" > "${tmp_man_page}"  # Generate file for 'man'
   man "${tmp_man_page}"    # Display man page
   rm -f "${tmp_man_page}"  # Remove temporary 'man' file after exiting 'man'
}

#-------------------------------------------------------------------------------

__short_help() {
   # Display short help
   #--
   printf " Usage: redoflacs [operations] [options] [target] ...\n"
   printf " Operations:\n"
   printf "   -c, --compress\n"
   printf "   -C, --compress-notest\n"
   printf "   -t, --test\n"
   printf "   -m, --md5check\n"
   printf "   -a, --aucdtect\n"
   printf "   -A, --aucdtect-spectrogram\n"
   printf "   -e, --extract-artwork\n"
   printf "   -p, --prune\n"
   printf "   -g, --replaygain\n"
   printf "   -G, --replaygain-noforce\n"
   printf "   -r, --retag\n"
   printf "   -l, --all\n"
   printf "   -L, --reallyall\n"
   printf " Options:\n"
   printf "   -j[N], --jobs[=N]\n"
   printf "   -n, --no-color\n"
   printf "   -o, --new-config\n"
   printf "   -v, --version\n"
   printf "   -h, --help\n"
   printf " This is the short help; for details use 'redoflacs --help' or 'redoflacs -h'\n"
}

#-------------------------------------------------------------------------------

# Display usage
__usage() { printf " Usage: redoflacs [operations] [options] [target] ...\n" ;} >&2

#-------------------------------------------------------------------------------

__message_log_exists() {
   # Print out the correct operational message regarding a log file's existence
   # and what infomration that log may contain
   #--
   # $1 determines the log file to use, as well as how many lines are printed
   # out to correctly set the current row.  Possible values:
   #   aucdtect                  md5_check           compress_verify
   #   compress_no_test          test                replaygain_test
   #   replaygain_force_apply    replaygain_apply    retag_analyze
   #   retag_apply               extract_images      prune
   #--
   case "$1" in
      'aucdtect'*)
         __error "Some FLAC files may be lossy sourced, please check:\n"
      ;;
      'md5_check')
         __error "The MD5 Signature is unset for some FLAC files or there were\n"
         __error "issues with some of the FLAC files, please check:\n"
      ;;
      'compress_'*|'test'|'replaygain_test'|'extract_images'|'prune')
         __error "There were issues with some of the FLAC files,\n"
         __error "please check:\n"
      ;;
      'replaygain'*'apply')
         __error "There were issues adding ReplayGain values,\n"
         __error "please check:\n"
      ;;
      'retag_'*)
         __error "Some FLAC files have missing tags or there were\n"
         __error "issues with some of the FLAC files, please check:\n"
      ;;
   esac

   # Print the bottom half of the message (uniform across all operations)
   __error "${cyan}${log_file}${reset}\n"
   __error "for details.\n"
} >&2

#-------------------------------------------------------------------------------

__create_log() {
   # Take log file from the current operation, prepending a header to it as
   # as well as formatting/aligning log lines
   #--
   # $1 determines the log file to create, and is any one of these values:
   #   aucdtect                  md5_check           compress_verify
   #   compress_no_test          test                replaygain_test
   #   replaygain_force_apply    replaygain_apply    retag_analyze
   #   retag_apply               extract_images      prune
   #--
   # Set up local variables/arrays
   declare    error_msg  filename  line
   declare -i length
   declare -a header     log_array

   # Set log file and the type of header to prepend based on how this function
   # was called, via $1
   case "${1}" in
      'aucdtect'*)
         header=(
            "--------------------------------------------------------------------------------"
            "                            [ Aucdtect Report Log ]"
            ""
            "      This log details which FLAC files have errors when running auCDtect"
            "--------------------------------------------------------------------------------"
         ) ;;
      'md5_check')
         header=(
            "--------------------------------------------------------------------------------"
            "                            [ Md5 Check Error Log ]"
            ""
            " This log details which FLAC files have errors when checking the MD5 signature"
            "--------------------------------------------------------------------------------"
         ) ;;
      'compress_'*)
         header=(
            "--------------------------------------------------------------------------------"
            "                        [ Compress & Verify Error Log ]"
            ""
            " This log details which FLAC files have errors when compressing and/or verifying"
            "--------------------------------------------------------------------------------"
         ) ;;
      'test')
         header=(
            "--------------------------------------------------------------------------------"
            "                               [ Test Error Log ]"
            ""
            "          This log details which FLAC files have errors when testing"
            "--------------------------------------------------------------------------------"
         ) ;;
      'replaygain_test')
         header=(
            "--------------------------------------------------------------------------------"
            "                         [ ReplayGain Test Error Log ]"
            ""
            " This log details which FLAC files have errors when testing for ReplayGain"
            " compatability"
            "--------------------------------------------------------------------------------"
         ) ;;
      'replaygain'*'apply')
         header=(
            "--------------------------------------------------------------------------------"
            "                        [ ReplayGain Apply Error Log ]"
            ""
            " This log details which directories have FLAC files that have errors when"
            " applying ReplayGain values"
            "--------------------------------------------------------------------------------"
         ) ;;
      'retag_'*)
         header=(
            "--------------------------------------------------------------------------------"
            "                              [ Retag Error Log ]"
            ""
            "         This log details which FLAC files have errors when retagging"
            "--------------------------------------------------------------------------------"
         ) ;;
      'extract_images')
         header=(
            "--------------------------------------------------------------------------------"
            "                         [ Extract Images Error Log ]"
            ""
            " This log details which FLAC files have errors when extracting artwork images"
            "--------------------------------------------------------------------------------"
         ) ;;
      'prune')
         header=(
            "--------------------------------------------------------------------------------"
            "                              [ Prune Error Log ]"
            ""
            " This log details which FLAC files have errors when pruning METADATA blocks"
            "--------------------------------------------------------------------------------"
         ) ;;
   esac

   # Create array of current log file
   mapfile -n0 -t log_array < "${log_file}"

   for line in "${log_array[@]}" ; do
      # Find the longest filename in the log file, and store it's length
      #--
      # 'path/to/file.flac${unit_separator}error message' -> 'path/to/file.flac'
      filename="${line%%${unit_separator}*}"

      if (( $(wc -L <<< ${filename}) > length )) ; then
         length=$(wc -L <<< ${filename})  # 'wc -L' is for apparent length
      fi
   done

   # Log header, truncating old log
   printf "%s\n" "${header[@]}" > "${log_file}"

   for line in "${log_array[@]}" ; do
      # Left align filenames and line up error messages before appending to
      # log file
      #--
      # 'path/to/file.flac${unit_separator}error message' -> 'path/to/file.flac'
      filename="${line%%${unit_separator}*}"

      # Use 'wc -L' for apparent length, not number of characters
      filename_length=$(wc -L <<< "${filename}")

      # 'path/to/file.flac${unit_separator}error message' -> 'error message'
      error_msg="${line##*${unit_separator}}"

      # Example line: /media/Music/Artist/Album/file.flac  ->  Error Message
      printf "%s%$((length - filename_length))s  ->  %s\n" "${filename}" "" "${error_msg}" >> "${log_file}"
   done
}

#-------------------------------------------------------------------------------

__message() {
   # Print out current operation message.
   #--
   # $1 determines which title message to print (if any).  Possible values:
   #   aucdtect                  md5_check           compress_verify
   #   compress_no_test          test                replaygain_test
   #   replaygain_force_apply    replaygain_apply    retag_analyze
   #   retag_apply               extract_images      prune
   #--
   # Set up local variables
   declare message sub_message

   # Print title message if $1 is not NULL
   if [[ -n "${1}" ]] ; then
      case "${1}" in
         'aucdtect')            message="Validating FLAC files with auCDtect..."                                         ;;
         'md5_check')           message="Verifying FLAC files MD5 Signature..."                                          ;;
         'compress_verify')     message="Compressing & Verifying FLAC files [Compression Lvl: ${compression_level}]..."  ;;
         'compress_no_test')    message="Compressing FLAC files [Compression Lvl: ${compression_level}]..."              ;;
         'test')                message="Testing integrity of FLAC files..."                                             ;;
         'replaygain_'*)
            if [[ "${1}" == 'replaygain_test' ]] ; then
               message="Generating & Applying ReplayGain to FLAC files..."
               sub_message="Testing"
            else  #  'replaygain'*'apply'
               sub_message="Applying"
            fi
         ;;
         'retag_'*)
            if [[ "${1}" == 'retag_analyze' ]] ; then
               message="Re-Tagging FLAC files..."
               sub_message="Analyzing"
            else  #  'retag_apply'
               sub_message="Re-Tagging"
            fi
         ;;
         'extract_images')      message="Extracting artwork from FLAC files..."   ;;
         'prune')
            if [[ "${remove_artwork}" != "true" ]] ; then
               # Keep artwork
               message="Removing METADATA blocks [Except: STREAMINFO,VORBIS_COMMENT,PICTURE]..."
            else
               # Remove artwork
               message="Removing METADATA blocks [Except: STREAMINFO,VORBIS_COMMENT]..."
            fi
         ;;
      esac

      # Print title message, if applicable
      if [[ -n "${message}" ]] ; then
         printf "\033[$(__row)H ${green}*${reset} ${message}\n"
      fi

      # Print sub title message, if applicable
      if [[ -n "${sub_message}" ]] ; then
         printf "\033[$(__row);3H${green}>>${reset} ${sub_message}\n"
      fi
   fi
}

#-------------------------------------------------------------------------------

__update_operation_status () {
   # Update $operation_summary[@] with the current operation status
   #--
   # $1 determines which operational index to update; possible values:
   #   aucdtect                  md5_check           compress_verify
   #   compress_no_test          test                replaygain_test
   #   replaygain_force_apply    replaygain_apply    retag_analyze
   #   retag_apply               extract_images      prune
   #
   # $2 is the operational status, the values of which, can be:
   #   Operation Completed       Operation Interrupted
   #   Operation Did Not Run     <integer> Issues
   #--
   case "${1}" in
      'aucdtect'*)          operation_summary['Validate with auCDtect']="${2}" ;;
      'md5_check')          operation_summary['Check MD5 Signature']="${2}"    ;;
      'compress_'*)         operation_summary['Compress FLACs']="${2}"         ;;
      'test')               operation_summary['Test FLACs']="${2}"             ;;
      'replaygain_test')    operation_summary['>> Testing']="${2}"             ;;
      'replaygain'*'apply') operation_summary['>> Applying']="${2}"            ;;
      'retag_analyze')      operation_summary['>> Analyzing']="${2}"           ;;
      'retag_apply')        operation_summary['>> Re-Tagging']="${2}"          ;;
      'extract_images')     operation_summary['Extracting Artwork']="${2}"     ;;
      'prune')              operation_summary['Prune METADATA Blocks']="${2}"  ;;
   esac
}

#-------------------------------------------------------------------------------

__print_item() {
   # Display the current item being that's to be run through an operation
   #--
   # $1 is the filename to print
   # $2 is the filename length
   # $3 is the number completed, ie [12/345]
   # $4 determines whether this is a sub operational item to print
   #--
   # Set up local variables
   declare -i  print_spacing='1'

   (( max_length >= $2 )) && print_spacing=$(( max_length - $2 ))

   case "$4" in
      '')
         #       08 - track.flac                           [12/345]
         printf "\033[${placement};9H%s%${print_spacing}s${magenta}%s${reset}" \
            "$1" '' "${3}"
      ;;
      'sub')
         #      50% 08 - track.flac                        [12/345]
         printf "\033[${placement};6H${yellow}%s${reset} %s%${print_spacing}s${magenta}%s${reset}" \
            " 50%" "$1" '' "${3}"
      ;;
      'half')
         #   50% 08 - track.flac                           [12/345]
         printf "\033[${placement};4H${yellow}%s${reset} %s%${print_spacing}s${magenta}%s${reset}" \
            " 50%" "$1" '' "${3}"
      ;;
      'decode')
         #       [decoding->WAV] 08 - track.flac           [12/345]
         print_spacing=$(( print_spacing - 16 ))
         printf "\033[${placement};9H${cyan}[decoding->WAV]${reset} %s%${print_spacing}s${magenta}%s${reset}" \
            "$1" '' "${3}"
      ;;
      'aucdtect_fast')
         #       [auCDtect:fast] 08 - track.flac           [12/345]
         print_spacing=$(( print_spacing - 16 ))
         printf "\033[${placement};9H${cyan}[auCDtect:fast]${reset} %s%${print_spacing}s${magenta}%s${reset}" \
            "$1" '' "${3}"
      ;;
      'aucdtect_slow')
         #       [auCDtect:slow] 08 - track.flac           [12/345]
         print_spacing=$(( print_spacing - 16 ))
         printf "\033[${placement};9H${cyan}[auCDtect:slow]${reset} %s%${print_spacing}s${magenta}%s${reset}" \
            "$1" '' "${3}"
      ;;
      'spectrogram')
         #       [spectral->PNG] 08 - track.flac           [12/345]
         print_spacing=$(( print_spacing - 16 ))
         printf "\033[${placement};9H${cyan}[spectral->PNG]${reset} %s%${print_spacing}s${magenta}%s${reset}" \
            "$1" '' "${3}"
      ;;
   esac
}

#-------------------------------------------------------------------------------

__print_status() {
   # Display the result of current item that was operated on
   #--
   # $1 is the file/dir operation result, of which, can be:
   #   ok   fail   issue   skip
   # $2 is the basename of the file/dir
   # $3 is the filename length
   # $4 determines whether item is a sub operation or which action is being done
   #--
   # Set up local variables
   declare -i print_spacing='0' column_placement='4'

   case "$1" in
      'ok')     color="${green}"   result="100%"  ;;
      'fail')   color="${red}"     result="fail"  ;;
      'issue')  color="${yellow}"  result="chck"  ;;
      'skip')   color="${yellow}"  result="skip"  ;;
   esac

   (( max_length >= $3 )) && print_spacing=$(( max_length - $3 ))

   case "$4" in
      'sub')
         column_placement='6'
      ;;
      'decode')
         action="${cyan}[decoding->WAV]${reset} "
         (( print_spacing != 0 )) && print_spacing=$(( print_spacing - 16 ))
      ;;
      'aucdtect_fast')
         action="${cyan}[auCDtect:fast]${reset} "
         (( print_spacing != 0 )) && print_spacing=$(( print_spacing - 16 ))
      ;;
      'aucdtect_slow')
         action="${cyan}[auCDtect:slow]${reset} "
         (( print_spacing != 0 )) && print_spacing=$(( print_spacing - 16 ))
      ;;
      'spectrogram')
         action="${cyan}[spectral->PNG]${reset} "
         (( print_spacing != 0 )) && print_spacing=$(( print_spacing - 16 ))
      ;;
   esac

   printf "\033[${placement};${column_placement}H${color}%s${reset} ${action}%s%${print_spacing}s" \
      "${result}" "$2" ""
}

#-------------------------------------------------------------------------------

__print_progress() {
   # Display filename and current progress of operation
   #--
   # $1 is either the operation:
   #   aucdtect                  md5_check           compress_verify
   #   compress_no_test          test                replaygain_test
   #   replaygain_force_apply    replaygain_apply    retag_analyze
   #   retag_apply               extract_images      prune
   #   decode                    aucdtect_fast       aucdtect_slow
   #   spectrogram
   #
   # $2 is percent
   # $3 is filename to print (may be truncated)
   # $4 is filename length
   #--
   # Set up local variables
   declare  action  progress_bar_length

   case "$1" in
      'decode')
         action="${cyan}[decoding->WAV]${reset} "
         # max_length - 16: '[decoding -> WAV] ' is 18 characters long
         progress_bar_length=$(( ( ( max_length - 16 ) * $2 ) / 100 ))
      ;;
      'aucdtect_fast')
         action="${cyan}[auCDtect:fast]${reset} "
         # max_length - 16: '[auCDtect - fast] ' is 18 characters long
         progress_bar_length=$(( ( ( max_length - 16 ) * $2 ) / 100 ))
      ;;
      'aucdtect_slow')
         action="${cyan}[auCDtect:slow]${reset} "
         # max_length - 16: '[auCDtect: slow] ' is 16 characters long
         progress_bar_length=$(( ( ( max_length - 16 ) * $2 ) / 100 ))
      ;;
      'spectrogram')
         action="${cyan}[spectral->PNG]${reset} "
         # max_length - 16: '[spectral->PNG] ' is 16 characters long
         progress_bar_length=$(( ( ( max_length - 16 ) * $2 ) / 100 ))
      ;;
      *)
         progress_bar_length=$(( ( max_length * $2 ) / 100 ))
      ;;
   esac

   if (( progress_bar_length < $4 )) ; then
      # Print out the current item name as well as the progress bar
      #--
      # If $progress_bar_length is less than the current item's name length,
      # print out the item's name with the progress bar a part of the name.
      #
      # Otherwise, print out the item's name, and the progress bar after the
      # item's name
      printf "\033[${placement};4H${yellow}%4s${reset} ${action}${invert}%s${reset}" \
         "${2}%" "${3:0:${progress_bar_length}}"
   else
      printf "\033[${placement};4H${yellow}%4s${reset} ${action}${invert}%s%$(( progress_bar_length - $4 ))s${reset}" \
         "${2}%" "${3}" ""
   fi
}

#-------------------------------------------------------------------------------

__trap_sigint() {
   # Kill any children process and display the correct interrupt message when
   # a user sends SIGINT during script execution.
   #--
   # $1 is where to place the cursor (row-wise) in order to not overwrite
   # files/directories displayed already.
   #
   # $2 determines which additional cleanup may need to be performed when
   # starting '__exit_cleanup'.  Possible values:
   #   aucdtect                  md5_check           compress_verify
   #   compress_no_test          test                replaygain_test
   #   replaygain_force_apply    replaygain_apply    retag_analyze
   #   retag_apply               extract_images      prune
   #--
   __kill_jobs "$(jobs -rp)"

   # If $1 is NULL, it means that the user invoked SIGINT before any operation
   # started (eg, retag countdown or config countdown)
   if [[ -n "${1}" ]] ; then
      printf "\033[${1};2H${green}*${reset} Control-C received, generating summary. Please wait...\n"
   else
      printf "\n ${green}*${reset} Control-C received, generating summary. Please wait...\n"
   fi

   __exit_cleanup "${2}"
}

#-------------------------------------------------------------------------------

__exit_cleanup() {
   # Do any additional cleanup and check for the existence of a log file before
   # exiting script.
   #--
   # $1 determines which operation requires additional cleanup.  This value is
   # normally obtained from $2 in the '__trap_sigint' function.  Possible
   # values:
   #   aucdtect                  md5_check           compress_verify
   #   compress_no_test          test                replaygain_test
   #   replaygain_force_apply    replaygain_apply    retag_analyze
   #   retag_apply               extract_images      prune
   #--
   case "${1}" in
      # Remove temporary script-created files
      #--
      'aucdtect'*)   rm -f "${directory}"/**/*_redoflacs_"$$".wav  ;;
      'compress_'*)  rm -f "${directory}"/**/*.tmp,fl-ac+en\'c     ;;
   esac

   # Update status for the current operation
   __update_operation_status "${1}" 'Operation Interrupted'

   if [[ -f "${log_file}" ]] ; then
      __message_log_exists "${1}"  # Print out log exists to STDERR
      __create_log "${1}"          # Create and format log
   fi

   stty ${old_stty} < /dev/stderr  # Restore old stty settings
   printf "\033[?25h"              # Restore the cursor
   rm -f "${job_fifo}"             # Remove temporary FIFO
   rm -f "${tmp_picture_blocks}"   # Remove temporary 'metaflac' block streams
   __summary                       # Display Summary Of Operations

   exit 130
}

#-------------------------------------------------------------------------------

# Display redoflacs version
__print_version() { printf "Version %s\n" "${version}" ;}

#-------------------------------------------------------------------------------

__metaflac_version() {
   # Return metaflac version
   #--
   # Metaflacs version (ie: '2' in 1.2.1)
   IFS='.' read -r _ metaflac_version _ < <(metaflac --version)
   printf "%s" "${metaflac_version}"
}

#-------------------------------------------------------------------------------

__kill_jobs() {
   # Kill any children process (obtained via $@), hiding errors and suppressing
   # the shell's notification of terminated jobs
   #--
   for pid in $@ ; do
      kill ${pid} 2>/dev/null
      wait ${pid} 2>/dev/null
   done
}

#-------------------------------------------------------------------------------

__row() {
   # Print out the current cursor row position
   #--
   declare old_stty  row_pos        # Intialize local variables
   exec < /dev/tty                  # Set a new TTY to read in STDIN
   old_stty="$(stty -g)"            # Store current TTY settings
   stty raw -echo min 0             # Current TTY set at an absolute minimum
   printf "\033[6n" > /dev/tty      # Send escape into new TTY

   # Read in escape sequence output from TTY.  The escape sequence looks like:
   #   ^[<integer>;<integer>R
   #--
   # This is what is read in below:  ^[<integer>
   IFS=';' read -r -d'R' row_pos _ < /dev/tty 

   stty "${old_stty}"               # Restore the old TTY settings
   printf "%s" "${row_pos#??}"      # Return row position (removes: ^[)
}

#-------------------------------------------------------------------------------

__scroll_terminal() {
   # Scroll the terminal, dependant on the number of jobs to process.  If it's
   # not necessary, scrolling may not occur
   #--
   # $1 is the current cursor position in number of rows
   #--
   # Set up local variables
   declare    lines   remaining_lines   to_scroll
   declare -g columns

   # Redirecting '/dev/stderr' to 'stty' allows valid arguments
   read -r _ _ _ _ lines _ columns _ < <(stty -a < /dev/stderr)

   columns="${columns%;}"   # Terminal width - remove trailing semicolon
   lines="${lines%;}"       # Terminal height - remove trailing semicolon

   if (( ${#total_items[@]} < jobs )) ; then
      # Determine the remaining lines to the bottom of the terminal screen
      #--
      # If there are less items to process than jobs specified, add the
      # difference of lines to the remaining lines (obtained by the total number
      # of lines in the terminal minus the current row position)
      remaining_lines=$(( lines - $1 + (jobs - ${#total_items[@]}) ))
   else
      remaining_lines=$(( lines - $1 ))
   fi

   if (( jobs > remaining_lines )) ; then
      # Scroll the terminal if there are more jobs than lines available
      #--
      to_scroll=$(( jobs - remaining_lines ))  # Number of lines to scroll

      # Scroll terminal by printing as many newlines as determined above
      for ((i=1 ; i<=to_scroll ; i++)) ; do
         printf '\n'
      done

      printf "\033[$(( $1 - to_scroll ))H"  # Place cursor up $to_scroll lines
   fi
}

#-------------------------------------------------------------------------------

__get_percent_complete() {
   # Return an operation's completion percentage, expressed as an integer
   #--
   # $1 is the operation to choose how to obtain the percentage, which can be:
   #   aucdtect                  md5_check           compress_verify
   #   compress_no_test          test                replaygain_test
   #   replaygain_force_apply    replaygain_apply    retag_analyze
   #   retag_apply               extract_images      prune
   #   decode
   #
   # $2 is a (possibly multiline) string of text from a command binary's output
   # with a percentage string contained within
   #--
   # Set up local variables
   declare percent

   case "$1" in
      'compress_'*)
         percent="${2//$'\b'/}"                        # Remove backspaces
         percent="${percent##*: }"                     # complete0, ratio=0.307
         percent="${percent##*complete, ratio=?.???}"  # Percent (integer)
      ;;
      'test')
         percent="${2##* }"                            # Percent (integer)
      ;;
      'decode')
         percent="${2//$'\b'}"                         # Remove backspaces
         percent="${percent##*: }"                     # complete0
         percent="${percent##*complete}"               # Percent (integer)
      ;;
      'aucdtect')
         percent="${2##*[}"                            # Percent (integer)
      ;;
      'spectrogram')
         percent="${2##*In:}"                          # Percent (floating)
         percent="${percent%%.*}"                      # Percent (integer)
      ;;
   esac

   # Default to '0' if percentage is not an integer
   if [[ "${percent}" =~ ^[[:digit:]]+$ ]] ; then
      printf "%d" $percent
   else
      printf "%d" '0'
   fi
}

#-------------------------------------------------------------------------------

__new_config() {
   # Force the creation of a new configuration file
   #--
   # Check if configuration file exists based of ${EUID}.  If it doesn't
   # exist, create one
   if (( EUID == 0 )) ; then
      # User is root
      #--
      # Configuration file location
      config_file="/etc/redoflacs.conf"

      # If there already is a configuration file, do not overwrite it
      if [[ -f "${config_file}" ]] ; then
         config_file="/etc/_$$.redoflacs.conf"
      fi
   else
      # User is _NOT_ root
      #--
      # Configuration file location
      config_file="${HOME}/.config/redoflacs/config"

      # If there already is a configuration file, do not overwrite it
      if [[ -f "${config_file}" ]] ; then
         config_file="${HOME}/.config/redoflacs/_$$.config"
      fi
   fi

   # Creates the (new) configuration file
   __create_config

   # Explain to user where to find the new configuration file
   __info "A new configuration file has been created here:\n"
   __info "${cyan}${config_file}${reset}\n\n"

   __info "It's recommended to review the new configuration file\n"
   __info "and transfer over any changes you made in your old\n"
   __info "configuration file.\n\n"

   __info "After making the changes (if any), rename the new\n"
   __info "configuration file to your old configuration file\n"
   __info "name.  Here is the command you could use:\n"

   if (( EUID == 0 )) ; then
      __info "${cyan}mv${reset} ${cyan}${config_file}${reset} ${cyan}/etc/redoflacs.conf${reset}\n"
   else
      __info "${cyan}mv${reset} ${cyan}${config_file}${reset} ${cyan}${HOME}/.config/redoflacs/config${reset}\n"
   fi
}

#-------------------------------------------------------------------------------

__create_config() {
   # Create a configuration file
   #--
   # Set up local variable
   declare create_config

   create_config="################################################################################
#                                                                              #
#                         REDOFLACS USER CONFIGURATION                         #
#                         ----------------------------                         #
#                                                                              #
#  Any line that is _NOT_ prepended with a '#' will be interpreted as an       #
#  option (except for blank lines -- these are not interpreted)                #
#                                                                              #
#  See \`redoflacs --help\` for a detailed description of each parameter         #
#                                                                              #
################################################################################

#-------------------------------------------------------------------------------
#  :: TAGGING SECTION ::
#-------------------------------------------------------------------------------
# List the tags to be kept in each FLAC file.  The default is listed below.
#
# Another common tag not added by default is ALBUMARTIST.  Uncomment ALBUMARTIST
# below to allow script to keep this tag.

TITLE
ARTIST
#ALBUMARTIST
ALBUM
DISCNUMBER
DATE
TRACKNUMBER
TRACKTOTAL
GENRE

# The COMPRESSION tag is a custom tag to allow the script to determine which
# level of compression the FLAC file(s) has/have been compressed at.
COMPRESSION

# The RELEASETYPE tag is a custom tag the author of this script uses to
# catalogue what kind of release the album is (ie, Full Length, EP, Demo, etc.).
RELEASETYPE

# The SOURCE tag is a custom tag the author of this script uses to catalogue
# which source the album has derived from (ie, CD, Vinyl, Digital, etc.).
SOURCE

# The MASTERING tag is a custom tag the author of this script uses to catalogue
# how the album has been mastered (ie, Lossless, or Lossy).
MASTERING

# The REPLAYGAIN tags below, are added by the '-g, --replaygain' or
# '-G, --replaygain-noforce' argument.  If you want to keep the replaygain tags,
# make sure you leave these here.
REPLAYGAIN_REFERENCE_LOUDNESS
REPLAYGAIN_TRACK_GAIN
REPLAYGAIN_TRACK_PEAK
REPLAYGAIN_ALBUM_GAIN
REPLAYGAIN_ALBUM_PEAK

#== :: END TAGGING SECTION :: ==================================================

#-------------------------------------------------------------------------------
#  :: OPTIONS ::
#-------------------------------------------------------------------------------
#~~~~~~~~~~~~~~~~~~
#  REMOVE ARTWORK
#~~~~~~~~~~~~~~~~~~
# Set whether to remove embedded artwork within FLAC files.  By default, this
# script will remove any artwork it can find, whether it's in the legacy
# COVERART tag or METADATA_BLOCK_PICTURE.  Set 'remove_artwork' as 'true' to
# remove embedded artwork.  All other values are intepreted as 'false'.
remove_artwork=\"true\"

#~~~~~~~~~~~~~~~~~~~
#  SET COMPRESSION
#~~~~~~~~~~~~~~~~~~~
# Set the type of COMPRESSION to compress the FLAC files.  Numbers range from
# '1-8', with '1' being the lowest compression and '8' being the highest
# compression.  The default is '8'.
compression_level=\"8\"

#~~~~~~~~~~~~~~~~~~~~~~~
#  ERROR LOG DIRECTORY
#~~~~~~~~~~~~~~~~~~~~~~~
# Set the where you want the error logs to be placed.  By default, they are
# placed in the user's HOME directory.
error_log=\"\${HOME}\"

#~~~~~~~~~~~~~~~~~~~~~~~
#  AUCDTECT SKIP LOSSY
#~~~~~~~~~~~~~~~~~~~~~~~
# Set whether FLAC files should be skipped if the MASTERING tag is already set
# as 'Lossy' when analyzed with auCDtect.  Set 'skip_lossy' as 'true' to to skip
# FLAC files that have the tag: 'MASTERING=Lossy'.  All other values are
# intepreted as 'false'.
skip_lossy=\"true\"

#~~~~~~~~~~~~~~~~~~~~~~~~~
#  SPECTROGRAM DIRECTORY
#~~~~~~~~~~~~~~~~~~~~~~~~~
# Set where the created spectrogram files should be placed.  By default, the
# spectrogram images will be placed in the same directory as the tested FLAC
# files. Each image will have the same name as the tested FLAC file but with
# the extension '.png'.
#
# All values for 'spectrogram_location' are interpreted as a directory.  If left
# blank, the default location will be used.
#
# An example of a user-defined location:
#    spectrogram_location=\"\${HOME}/Spectrogram_Images\"
#
# See '--help' or '-h' for more information.
spectrogram_location=\"\"

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#  EXTRACTED ARTWORK DIRECTORY
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Set where the extracted artwork images should be placed.  By default, the
# extracted images will be placed in a subdirectory where the FLAC file is
# located.  The subdirectory has the same name as the FLAC file that's processed
# with a unique string appended to it:
#
#    [ Default directory example ]
#    /path/to/music/01_file.flac                          # FLAC with artwork
#    /path/to/music/01_file.flac_[redoflacs_art]_4342/    # Example subdirectory
#
# All values for 'artwork_location' are interpreted as a directory.  If left
# blank, the default location will be used.
#
# If there is a user-defined location, the extracted images will be placed in a
# subdirectory in that location with a naming scheme similar to the above
# example, but prefaced with the current number of FLAC files being processed:
#
#    [ User-defined location ]
#    artwork_location=\"\${HOME}/artwork\"
#
#    [ FLAC file to be processed ]
#    /path/to/music/01_file.flac
#
#    [ Resultant subdirectory with extracted artwork ]
#    \${HOME}/artwork/[1] 01_file.flac_[redoflacs_art]_4342/
#
# See '--help' or '-h' for more information.
artwork_location=\"\"

#~~~~~~~~~~~~~~~~~~~~~~~~
#  PREPEND TRACK NUMBER
#~~~~~~~~~~~~~~~~~~~~~~~~
# Change whether the '-r, --retag' operation will re-tag singular track numbers
# and track totals from:
#    [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
# to
#    [ 01, 02, 03, 04, 05, 06, 07, 08, 09 ]
#
# For example, if you had:
#    TRACKNUMBER=4
#     TRACKTOTAL=9
#
# You would end up with:
#    TRACKNUMBER=04
#     TRACKTOTAL=09
#
# This is enabled by setting 'prepend_zero' option as 'true'.  All other values
# are interpreted as 'false'.
prepend_zero=\"false\"

#== :: END OPTIONS :: ====== DO NOT DELETE THIS LINE! ====== :: REVISION 2 :: =="

   # Print out the configuration file to the specified location (either system-
   # wide or local)
   printf "%s\n" "${create_config}" > "${config_file}"
}

#-------------------------------------------------------------------------------

__parse_config() {
   # Parse the user/system configuration file
   #--
   # Load the config file into an array and process each line, grabbing the
   # user-specified FLAC tags and setting up the configuration variables
   #--
   # Set up local variables/arrays
   declare    config_option
   declare -a config_array

   mapfile -n0 -t config_array < "${config_file}"

   for line in "${config_array[@]}" ; do
      # Run through the array, evaluating the configuration option into the
      # current enviroment and storing the tag fields into an array
      #--
      # Test and use only the tag and config options
      if [[ -n "${line###*}" && -n "${line}" ]] ; then
         config_option="${line//*=*/}"  # Null if line is a config option

         if [[ -n "${config_option}" ]] ; then
            tags+=( "${line^^}" )      # Store uppercase tag in array
         else
            eval "${line}"             # Put config option in environment
         fi
      fi
   done
}

#-------------------------------------------------------------------------------

__check_config_version() {
   # Check current configuration, if the version in the script is newer
   # warn user and display a countdown before starting script
   #--
   # Set up local variables/arrays
   declare    config_file  config_last_line  user_config_revision
   declare -a config_array

   # Check if configuration file exists based of ${EUID}.  If it doesn't
   # exist, create one
   if (( EUID == 0 )) ; then
      # User is root
      #--
      # Configuration file location
      config_file="/etc/redoflacs.conf"
   else
      # User is _NOT_ root
      #--
      # Configuration file location
      config_file="${HOME}/.config/redoflacs/config"
   fi

   # Load configuration file into an array
   mapfile -n0 -t config_array < "${config_file}"

   # Obtain only the last line of the config
   config_last_line="${config_array[$(( ${#config_array[@]} - 1 ))]}"

   # Remove everything from the last line, except the REVISION number
   #
   # Below leaves:
   #  '<revision number> :: =='
   user_config_revision="${config_last_line#*REVISION }"
   # Obtains REVISION number
   user_config_revision="${user_config_revision% ::*}"

   # Check if ${user_config_revision} is an integer.  If not, display countdown
   # and warn user of new config file, else test if the user config revision is
   # less than the script config revision
   if [[ "${user_config_revision}" =~ ^[[:digit:]]+$ ]] ; then
      # If ${script_config_revision} is greater than ${user_config_revision}
      # warn user and display countdown
      if (( script_config_revision > user_config_revision )) ; then
         # Display warning and countdown
         __countdown_config ; printf '\n\n'
      fi
   else
      # Display warning and countdown
      __countdown_config ; printf '\n\n'
   fi
}

#-------------------------------------------------------------------------------

__truncate_filename() {
   # Truncate the processed item's filename if it's bigger than terminal width,
   # returning the filename (possibly truncated) as well as the length of the
   # filename (in characters)
   #--
   # $1 is the filename to truncate/process
   #--
   # Set up local variables
   declare    filename
   declare -i filename_length  truncated_length

   # Basename of file/directory
   if [[ "${1#"${1%?}"}" == '/' ]] ; then  # Last character is a '/'
      # Directory
      filename="${1%?}"                    # Remove last character
      filename="${filename##*/}/"          # Basename of directory, append '/'
   else
      # File
      filename="${1##*/}"                  # Basename of file
   fi

   filename="${filename//$'\n'/?}"         # Replace '\n' with '?'

   # Column length of filename. 'wc -L' handles multi-byte characters correctly
   filename_length="$(wc -L <<< "${filename}")"

   # If filename is longer than the width allowed in the terminal, truncate it
   if (( filename_length > max_length )) ; then
      # Truncate filename by $max_length and grab the _real_ length
      truncated_length="$(wc -L <<< "${filename:0:${max_length}}")"

      until (( truncated_length == max_length )) ; do
         # Multibyte characters can make $truncated_length smaller than
         # $max_length, so keep slicing a character off $max_length
         # until $truncated_length equals $max_length
         #--
         ((--max_length))
         truncated_length="$(wc -L <<< "${filename:0:${max_length}}")"
      done

      # Return truncated filename with ellipsis and filename length
      printf "%s${unit_separator}%d" "${filename:0:$((max_length - 2))}" "${filename_length}"
   else
      # Return filename and filename length
      printf "%s${unit_separator}%d" "${filename}" "${filename_length}"
   fi
}

#-------------------------------------------------------------------------------

__find_cores() {
   # Determine number of jobs to run via the number CPUs/cores available
   #--
   # Set up global variable
   declare -gi jobs='2'                  # By default, set $jobs to '2'
   declare -g  jobs_display='(Default)'  # Default $jobs determination

   # Check /proc/cpuinfo if /proc is mounted by comparing device numbers to /
   if (( $(stat -c %d /proc) != $(stat -c %d /) )) ; then
      if [[ -f /proc/cpuinfo ]] ; then
         # /proc/cpuinfo exists, find total number of cores to use
         #--
         # Store contents of /proc/cpuinfo inta core_array
         mapfile -n0 -t cores_array < /proc/cpuinfo

         for i in "${cores_array[@]}" ; do
            # For each line, add processor number to jobs if matched
            #--
            [[ "${i}" == 'processor'*:' '* ]] && jobs="${i#processor*: }"
         done

         ((jobs++))  # +1 to $jobs since 'processor' starts at '0'
         jobs_display="(/proc/cpuinfo)"  # $jobs dynamically determined
      fi
   fi
}

#-------------------------------------------------------------------------------

__find_artwork() {
   # Find all the artwork blocks in a given FLAC file, storing each instance
   # into an array, to be returned as $artwork[@]
   #--
   # Set up local variables/array
   declare -a artwork_blocks
   declare tmp_picture_blocks="/tmp/redoflacs_block_stream_${BASHPID}"

   # Grab all the PICTURE blocks from current FLAC file, storing into an array
   #--
   # It's much faster to read in from a temporary file than via process
   # substitution
   metaflac --list --block-type=PICTURE "${1}" > "${tmp_picture_blocks}"

   # Continue if there were any PICTURE blocks found in current FLAC
   if [[ -s "${tmp_picture_blocks}" ]] ; then
      # Only read in the lines we care about and store into array
      mapfile -n0 -t artwork_blocks < \
      <(
         while read -r ; do
            # We only care about the block, picture and MIME type lines
            [[ "${REPLY}" == 'METADATA'* || "${REPLY}" == '  '[tM]* ]] && printf "%s\n" "${REPLY}"
         done < "${tmp_picture_blocks}"
      )

      # Run through each line obtained and parse out the information wanted
      #--
      # $artwork_blocks[@] looks something like this:
      #   'METADATA block #2'
      #   '  type: 6 (PICTURE)'
      #   '  type: 5 (Leaflet page)'
      #   '  MIME type: image/jpeg'
      #   'METADATA block #3'
      #   '  type: 6 (PICTURE)'
      #   '  type: 6 (Media (e.g. label side of CD))'
      #   '  MIME type: image/jpeg'
      #   'METADATA block #4'
      #   '  type: 6 (PICTURE)'
      #   '  type: 7 (Lead artist/lead performer/soloist)'
      #   '  MIME type: image/jpg'
      #--
      for i in "${!artwork_blocks[@]}" ; do
         if [[ "${artwork_blocks[$i]}" == 'METADATA'* ]] ; then
            block_id="${artwork_blocks[$i]##* #}"  # METADATA block #4 -> 4

            # type: 8 (Artist/Performer) -> art_id='8', art_desc='(Artist-Performer)'
            read -r _ art_id art_desc <<< "${artwork_blocks[$((i + 2))]//\//-}"

            # MIME type: image/jpeg -> 'jpg'
            IFS='/' read -r _ art_ext <<< "${artwork_blocks[$((i + 3))]/jpeg/jpg}"

            # Store artwork information into array as a single index
            artwork+=( "${block_id}:${art_id} ${art_desc}.${art_ext}" )
         fi
      done
   fi

   rm -f "${tmp_picture_blocks}"  # Remove temporary 'metaflac' block streams
}

#-------------------------------------------------------------------------------

__top_banner() {
   # Top banner displaying invocation settings
   #--
   read -r _ flac_version < <(flac --version)                # Flac Version

   printf " ${blue}%s${reset}\n" \
      "---------------------------------------------------"  # Top title line

   printf "%16sRuntime Information\n"                        # Title

   printf " ${blue}%s${reset}\n" \
      "-------------------------+-------------------------"  # Bottom title line

   printf "                redoflacs ${blue}|${reset} ${cyan}%s${reset}\n" \
      "${version}"                                           # Script version

   printf "                     FLAC ${blue}|${reset} ${cyan}%s${reset}\n" \
      "${flac_version}"                                      # Flac version

   printf "                     Jobs ${blue}|${reset} ${cyan}%s %s${reset}\n" \
      "${jobs}" "${jobs_display}"                            # Number of jobs

   printf "            Log Directory ${blue}|${reset} ${cyan}%s${reset}\n" \
      "${error_log}/"                                        # Log directory

   # Set configuration directory
   if (( EUID == 0 )) ; then
      config_directory="/etc/"                               # System config
   else
      config_directory="~/.config/redoflacs/"                # User config
   fi

   printf "         Config Directory ${blue}|${reset} ${cyan}%s${reset}\n" \
      "${config_directory}"                                  # Config directory

   printf " ${blue}%s${reset}\n" \
      "-------------------------+-------------------------"  # End banner line

   __info "Finding FLAC files to process..."                 # Show FLAC search
}

#-------------------------------------------------------------------------------

__countdown_metadata() {
   # Display countdown before retagging to allow user to quit script safely
   #--
   trap __trap_sigint SIGINT     # Trap SIGINT to abort cleanly

   # Warning message
   __error "${yellow}CAUTION!${reset} These are the tag fields that will be kept\n" >&2
   __error "when re-tagging the selected files:\n" >&2

   # Creates the listing of tags to be kept
   printf "     %s\n" "${tags[@]}" >&2

   # Warning message about embedded coverart
   __error "By default, this script will ${cyan}REMOVE${reset} the legacy ${cyan}COVERART${reset} tag.\n" >&2
   __error "Add the ${cyan}COVERART${reset} tag to the list of tags to be kept in the\n" >&2
   __error "${cyan}TAGGING SECTION${reset} of the configuration file.\n\n" >&2

   __error "Keep in mind, if the ${cyan}remove_artwork${reset} option is set to ${cyan}false${reset},\n" >&2
   __error "embedded artwork in the ${cyan}PICTURE${reset} block will be kept when using\n" >&2
   __error "the ${cyan}-p, --prune${reset} option as well.\n\n" >&2

   __warn "Waiting ${red}10${reset} seconds before starting program...\n" >&2
   __warn "Ctrl+C (Control-C) to abort...\n" >&2
   __info "Starting in: "

   # 10 second countdown
   for count in {10..1} ; do
      printf "${red}%d ${reset}" "$count"
      read -t1  # Sleep 1
   done

   printf '\n'  # Advance countdown to next line
}

#-------------------------------------------------------------------------------

__countdown_config() {
   # Displays countdown if a newer config is found to allow user to quit safely
   #--
   trap __trap_sigint SIGINT     # Trap SIGINT to abort cleanly

   # Warning message
   __info "There is a newer configuration file available!\n\n"

   __warn "It is recommended you generate a new configuration\n" >&2
   __warn "file for use with this program.\n\n" >&2

   __warn "To generate a new configuration file, run:\n" >&2
   __warn "${cyan}redoflacs --new-config${reset}\n\n" >&2

   __warn "The above command will _NOT_ overwrite your\n" >&2
   __warn "current configuration file.\n\n" >&2

   __warn "Waiting 10 seconds before starting program...\n" >&2
   __warn "Ctrl+C (Control-C) to abort...\n" >&2
   __info "Starting in: "

   # 10 second countdown
   for count in {10..1} ; do
      printf "${red}%s ${reset}" "$count"
      read -t1  # Sleep 1
   done
}

#-------------------------------------------------------------------------------

__get_directory_list() {
   # Return a listing of the total base directories housing all the found FLACs
   #--
   declare     previous_dir  current_dir  # Set up local variable(s)
   declare -ga total_dirs                 # Set up global array

   for flac in "$@" ; do
      # Run through total FLAC files array, printing out each unique directory
      #--
      current_dir="${flac%/*}"
      if [[ "${previous_dir}" != "${current_dir}" ]] ; then
         total_dirs+=( "${current_dir}/" )
      fi
      previous_dir="${current_dir}"  # Set current directory to previous
   done
}

#-------------------------------------------------------------------------------

__clear_jobs_fd() {
   # Clear job manager file descriptor (tied to FIFO) by closing and reopening
   #--
   # $1 is the FIFO to tie the file descriptor to
   #--
   exec 3<&- 3>&-  # Close file descriptor
   rm -f "$1"      # Remove FIFO if it exists
   mkfifo "$1"     # Create FIFO
   exec 3<>"$1"    # Open file descriptor read/write
}

#-------------------------------------------------------------------------------

__num_issues() {
   # Return a string detailing the number of issues an operation may have had
   #--
   declare fail_count  # Set up local variable

   read -r fail_count < "${issue_ticks}"  # Read in number of issue ticks

   if (( ${#fail_count} == 1 )) ; then
      printf "%s Issue\n" "${#fail_count}"
   else
      printf "%s Issues\n" "${#fail_count}"
   fi
}

#-------------------------------------------------------------------------------

__process_positional_parameters() {
   # Obtain and process the positional parameters invoked with the script
   #--
   # Set up global variables
   declare -g all  reallyall  create_spectrogram  no_color  directory

   # Set up local variables/arrays
   declare -a args  long_args  short_args  non_args  converted_args
   declare    regex

   # If no arguments are made to the script show usage & short help
   if (( ${#} == 0 )) ; then
      __short_help
      exit 1
   fi

   # If only one argument was called
   if (( ${#} == 1 )) ; then
      case "$1" in
         '--help'|'-h')        __long_help     ; exit 0 ;;
         '--version'|'-v')     __print_version ; exit 0 ;;
         '--new-config'|'-o')  __new_config    ; exit 0 ;;
         *)                    __usage         ; exit 1 ;;
      esac
   fi

   # If only two arguments were called
   if (( ${#} == 2 )) ; then
      case "$1" in
         # The number of jobs cannot be specified without an operation
         '--jobs='[[:digit:]]*' '|'-j'[[:digit:]]*' ')
            __usage
            __error "${cyan}${1}${reset} cannot used without an operation specified.\n" >&2
            exit 1
      esac
   fi

   for i in "${@}" ; do
      # Separate long, short, and non arguments into separate arrays to be
      # converted into short arguments for 'getopts' to process correctly
      #--
      case "$i" in
         '--'*) long_args+=( "${i}" )   ;;
         '-'*)  short_args+=( "${i}" )  ;;
         *)     non_args+=( "${i}" )    ;;
      esac
   done

   # If there isn't a single non-argument (directory), exit
   if (( ${#non_args[@]} != 1 )) ; then
      __usage
      exit 1
   fi

   # Long arguments
   #--
   # If any were called, convert long arguments to short, allowing 'getopts' to
   # process them
   #--
   if [[ -n "${long_args[@]}" ]] ; then
      for i in "${long_args[@]}" ; do
         case "$i" in
            # These arguments are to be called by themselves, so quit
            '--version')              __usage ; exit 1        ;;
            '--help')                 __usage ; exit 1        ;;
            '--new-config')           __usage ; exit 1        ;;

            # Send long arguments to array to process later
            '--aucdtect')             converted_args+=( -a )  ;;
            '--aucdtect-spectrogram') converted_args+=( -A )  ;;
            '--md5check')             converted_args+=( -m )  ;;
            '--compress')             converted_args+=( -c )  ;;
            '--compress-notest')      converted_args+=( -C )  ;;
            '--test')                 converted_args+=( -t )  ;;
            '--replaygain')           converted_args+=( -g )  ;;
            '--replaygain-noforce')   converted_args+=( -G )  ;;
            '--retag')                converted_args+=( -r )  ;;
            '--extract-artwork')      converted_args+=( -e )  ;;
            '--prune')                converted_args+=( -p )  ;;
            '--all')                  converted_args+=( -l )  ;;
            '--reallyall')            converted_args+=( -L )  ;;
            '--no-color')             converted_args+=( -n )  ;;

            '--jobs='*)
               # Enforce we have only digits after '--jobs=', and if so, set the
               # number of $jobs to its value, otherwise exit with a warning
               #--
               regex="[[:digit:]]+$"  # Regular expression
               if [[ "${i##*=}" =~ $regex ]] && (( ${i##*=} != 0 )) ; then
                  jobs="${i##*=}"  # --jobs=11 -> 11
               else
                  __usage
                  __error "${cyan}--jobs${reset} requires a non-zero integer after it (eg. ${cyan}--jobs=11${reset}).\n" >&2
                  exit 1
               fi
            ;;

            # All other arguments are invalid
            *)  invalid_args+=( "${i}" )  ;;
         esac
      done
   fi

   # Short arguments
   #--
   # If any were called, add valid short arguments (using 'getopts') to the same
   # array as long arguments
   #--
   if [[ -n "${short_args[@]}" ]] ; then
      while getopts ":j:LlcCtgGaAmeprnhvo" args "${short_args[@]}" ; do
         case "${args}" in
            # These arguments are to be called by themselves, so quit
            'v') __usage ; exit 1        ;;
            'h') __usage ; exit 1        ;;
            'o') __usage ; exit 1        ;;

            # Send short arguments to array to process later
            'L') converted_args+=( -L )  ;;
            'a') converted_args+=( -a )  ;;
            'A') converted_args+=( -A )  ;;
            'm') converted_args+=( -m )  ;;
            'c') converted_args+=( -c )  ;;
            'C') converted_args+=( -C )  ;;
            't') converted_args+=( -t )  ;;
            'g') converted_args+=( -g )  ;;
            'G') converted_args+=( -G )  ;;
            'r') converted_args+=( -r )  ;;
            'e') converted_args+=( -e )  ;;
            'p') converted_args+=( -p )  ;;
            'l') converted_args+=( -l )  ;;
            'n') converted_args+=( -n )  ;;

            'j')
               # Enforce we have only digits after '-j', and if so, set the
               # number of $jobs to its value, otherwise exit with a warning
               #--
               regex="[[:digit:]]+$"  # Regular expression
               if [[ "${OPTARG}" =~ $regex ]] && (( OPTARG != 0 )) ; then
                  jobs="${OPTARG}"  # OPTARG is the argument after 'j' (j:)
               else
                  __usage
                  __error "${cyan}-j${reset} requires a non-zero integer after it (eg. ${cyan}-j11${reset}).\n" >&2
                  exit 1
               fi
            ;;
            ?)
               # Set invalid argument from getopts into array using
               # ${OPTARG}
               invalid_args+=( "-${OPTARG}" )
            ;;
         esac
      done
   fi

   # Display invalid arguments, if any
   if [[ -n "${invalid_args[@]}" ]] ; then
      __usage
      __error "Invalid option(s): " >&2
      printf "${cyan}%s${reset}\n" "${invalid_args[*]}" >&2
      exit 1
   fi

   # Process converted arguments, setting each operation to run into an array
   #--
   # Run through the catchall arugments first
   for i in "${converted_args[@]}" ; do
      case "${i}" in
         # These are the meta-arguments (do multiple operations)
         '-l')
            all="true"
            operations[1]='md5_check'
            operations[2]='compress_verify'
            operations[5]='replaygain_test'
            operations[6]='replaygain_force_apply'
            operations[7]='retag_analyze'
            operations[8]='retag_apply'
            operations[10]='prune'
         ;;
         '-L')
            reallyall="true"
            create_spectrogram='true'
            operations[0]='aucdtect'
            operations[1]='md5_check'
            operations[2]='compress_verify'
            operations[5]='replaygain_test'
            operations[6]='replaygain_force_apply'
            operations[7]='retag_analyze'
            operations[8]='retag_apply'
            operations[10]='prune'
         ;;
      esac
   done

   # Run through the individual operations
   for i in "${converted_args[@]}" ; do
      case "${i}" in
         # Process individual arguments
         '-a')
            if [[ "${create_spectrogram}" == 'true' || "${operations[0]}" == 'conflict' ]] ; then
               operations[0]='conflict'  # If already set
            else
               operations[0]='aucdtect'
            fi
         ;;
         '-A')
            if [[ -n "${operations[0]}" && -z "${create_spectrogram}" ]] || [[ "${operations[0]}" == 'conflict' ]] ; then
               operations[0]='conflict'  # If already set
            else
               create_spectrogram='true'
               operations[0]='aucdtect'
            fi
         ;;
         '-m') operations[1]='md5_check'         ;;
         '-c') operations[2]='compress_verify'   ;;
         '-C') operations[3]='compress_no_test'  ;;
         '-t') operations[4]='test'              ;;
         '-g')
            if [[ "${operations[6]}" == 'replaygain_apply' || "${operations[6]}" == 'conflict' ]] ; then
               operations[6]='conflict'   # If already set
            else
               operations[5]='replaygain_test'
               operations[6]='replaygain_force_apply'
            fi
         ;;
         '-G')
            if [[ "${operations[6]}" == 'replaygain_force_apply' || "${operations[6]}" == 'conflict' ]] ; then
               operations[6]='conflict'   # If already set
            else
               operations[5]='replaygain_test'
               operations[6]='replaygain_apply'
            fi
         ;;
         '-r')
            operations[7]='retag_analyze'
            operations[8]='retag_apply'
         ;;
         '-e')
            operations[9]='extract_images'
         ;;
         '-p') operations[10]='prune'            ;;
         '-n') no_color="true"                   ;;
      esac
   done

   args=( "${@}" )  # Store arguments into an array to process

   # Obtain the last element in $args[@], which is the directory to process
   #--
   # BASH 4.2 allows negative indices:
   #   directory="${args[-1]%/}"
   directory="${args[$(( ${#args[@]} - 1 ))]%/}"  # Remove ending slash (if any)
}

#-------------------------------------------------------------------------------

__check_missing_programs() {
   # Check for missing programs vital to this script
   #--
   # Set up local variables/arrays
   declare -a missing_commands

   # Add each command that's needed to an array to be displayed
   if ! type -P rm >/dev/null ; then
      missing_commands+=( "   Missing ${cyan}rm${reset}        ->  Part of ${cyan}coreutils${reset}" )
   fi
   if ! type -P stty >/dev/null ; then
      missing_commands+=( "   Missing ${cyan}stty${reset}      ->  Part of ${cyan}coreutils${reset}" )
   fi
   if ! type -P stat >/dev/null ; then
      missing_commands+=( "   Missing ${cyan}stat${reset}      ->  Part of ${cyan}coreutils${reset}" )
   fi
   if ! type -P mkdir >/dev/null ; then
      missing_commands+=( "   Missing ${cyan}mkdir${reset}     ->  Part of ${cyan}coreutils${reset}" )
   fi
   if ! type -P mkfifo >/dev/null ; then
      missing_commands+=( "   Missing ${cyan}mkfifo${reset}    ->  Part of ${cyan}coreutils${reset}" )
   fi
   if ! type -P wc >/dev/null ; then
      missing_commands+=( "   Missing ${cyan}wc${reset}        ->  Part of ${cyan}coreutils${reset}" )
   fi
   if ! type -P metaflac >/dev/null ; then
      missing_commands+=( "   Missing ${cyan}metaflac${reset}  ->  Part of ${cyan}flac${reset}" )
   fi
   if ! type -P flac >/dev/null ; then
      missing_commands+=( "   Missing ${cyan}flac${reset}      ->  Part of ${cyan}flac${reset}" )
   fi

   if [[ -n "${missing_commands[@]}" ]] ; then
      # Display message that system is missing vital programs
      #--
      __error "You seem to be missing one or more necessary programs\n"    >&2
      __error "to run this script reliably.  Below shows the program(s)\n" >&2
      __error "missing, as well as where you can install them from:\n"     >&2
      for i in "${missing_commands[@]}" ; do
         __warn "${i}\n" >&2
      done
      exit 1
   fi

   # Optional binaries
   #--
   # Check for auCDtect if operation was called
   if [[ "${operations[0]}" == 'aucdtect' ]] ; then
      if aucdtect="$(type -P auCDtect)" ; then
         _aucdtect() { "${aucdtect}" "$@" ;}  # Normal typeface
      elif aucdtect="$(type -P aucdtect)" ; then
         _aucdtect() { "${aucdtect}" "$@" ;}  # Alternate spelling
      else
         # auCDtect/aucdtect cannot be found
         __error "It appears ${cyan}auCDtect${reset} is not installed. Please verify you\n" >&2
         __error "have this program installed and can be found in ${cyan}\$PATH${reset}\n" >&2
         exit 1
      fi

      # Make sure auCDtect is executable
      if [[ ! -x "${aucdtect}" ]] ; then
         __error "It appears ${cyan}auCDtect${reset} is not executable.  In order to make\n" >&2
         __error "${cyan}auCDtect${reset} executable, run:\n" >&2
         __error "${cyan}chmod u+x '${aucdtect}'${reset}\n" >&2
         exit 1
      fi
   fi

   # Check for SoX if auCDtect spectrograms were called
   if [[ "${create_spectrogram}" == 'true' ]] ; then
      if sox="$(type -P sox)" ; then
         _sox() { "${sox}" "$@" ;}
      else
         # SoX cannot be found
         __error "It appears ${cyan}SoX${reset} is not installed. Please verify you\n" >&2
         __error "have this program installed and can be found in ${cyan}\$PATH${reset}\n" >&2
         exit 1
      fi
   fi
}

#-------------------------------------------------------------------------------

__check_conflicting_operations() {
   # Check for any conflicting operations/arguments
   #--
   # '-l, --all' and '-L, --reallyall' cannot be called together
   if [[ "${all}" == 'true' && "${reallyall}" == 'true' ]] ; then
      __error "Running both ${cyan}-l, --all${reset} and ${cyan}-L, --reallyall${reset} conflict!\n" >&2
      __error "Please choose one or the other.\n" >&2
      exit 1
   fi

   # Store conflicting arguments if '-l, --all' or '-L, --reallyall' was called
   if [[ "${all}" == 'true' || "${reallyall}" == 'true' ]] ; then
      # __compress_no_test()
      [[ -n "${operations[3]}" ]] && conflicting_args+=( '-C, --compress_notest' )

      case "${operations[6]}" in
         # __replaygain_apply()
         'replaygain_apply')
            conflicting_args+=( '-G, --replaygain-noforce' )
         ;;
      esac

      # Display conflicting arguments and exit, if there were any
      if [[ -n "${conflicting_args[@]}" ]] ; then
         # '-l, --all'
         if [[ "${all}" == 'true' ]] ; then
            __error "The below options conflict with ${cyan}-l, --all${reset}:\n" >&2
         # '-L, --reallyall'
         elif [[ "${reallyall}" == 'true' ]] ; then
            __error "The below options conflict with ${cyan}-L, --reallyall${reset}:\n" >&2
         fi

         # Print each conflicting argument
         for i in "${conflicting_args[@]}" ; do
            __error "  ${cyan}${i}${reset}\n" >&2
         done

         __error "Please remove incompatible options.\n" >&2
         exit 1
      fi
   fi

   # __compress_verify() and __compress_no_test()
   if [[ -n "${operations[2]}" && -n "${operations[3]}" ]] ; then
      __error "Running both ${cyan}-c, --compress${reset} and ${cyan}-C, --compress-notest${reset} conflict!\n" >&2
      __error "Please choose one or the other.\n" >&2
      exit 1
   fi

   # __compress_verify() and __test()
   if [[ -n "${operations[2]}" && -n "${operations[4]}" ]] ; then
      __error "Running both ${cyan}-c, --compress${reset} and ${cyan}-t, --test${reset} conflict!\n" >&2
      __error "Please choose one or the other.\n" >&2
      exit 1
   fi

   # __replaygain_force_apply and __replaygain_apply
   # 'conflict' is set during parameter handling if conflicts will ocurr
   if [[ "${operations[6]}" == 'conflict' ]] ; then
      __error "Running both ${cyan}-g, --replaygain${reset} and ${cyan}-G, --replaygain-noforce${reset} conflict!\n" >&2
      __error "Please choose one or the other.\n" >&2
      exit 1
   fi

   # __aucdtect and __aucdtect w/ spectrogram creation
   # 'conflict' is set during parameter handling if conflicts will ocurr
   if [[ "${operations[0]}" == 'conflict' ]] ; then
      __error "Running both ${cyan}-a, --aucdtect${reset} and ${cyan}-A, --aucdtect-spectrogram${reset} conflict!\n" >&2
      __error "Please choose one or the other.\n" >&2
      exit 1
   fi
}

#-------------------------------------------------------------------------------

__summary() {
   # Display the summary of operations chart
   #--
   # Set up local variables/arrays
   declare     operation  sub_message
   declare -a  operation_keys

   # Title
   printf "\033[$(__row);2H${blue}%s${reset}\n" \
   "---------------------------------------------------"
   printf "                Summary Of Operations\n"
   printf "${reset} ${blue}%s${reset}\n" \
   "-------------------------+-------------------------"

   # Correct order to display operational status to process
   operation_keys=(
      'Validate with auCDtect'
      'Check MD5 Signature'
      'Compress FLACs'
      'Test FLACs'
      '>> Testing'
      '>> Applying'
      '>> Analyzing'
      '>> Re-Tagging'
      'Extracting Artwork'
      'Prune METADATA Blocks'
   )

   for operation in "${operation_keys[@]}" ; do
      # Display each operational line with the status of that operation, if it
      # was called
      #--
      if [[ -n "${operation_summary[$operation]}" ]] ; then
         # Check for sub messages, and apply additional formatting
         if [[ "${operation}" == '>> '* ]] ; then
            if [[ "${operation}" == '>> Testing' ]] ; then
               printf "${yellow}%25s ${blue}|${reset}\n" 'Applying ReplayGain'
            elif [[ "${operation}" == '>> Analyzing' ]] ; then
               printf "${yellow}%25s ${blue}|${reset}\n" 'Retagging FLACs'
            fi

            printf -v sub_message "%25s" "${operation}"  # Store right aligned message

            # Color '>>' as yellow and message as magenta
            printf "${yellow}%s${magenta}%s ${blue}|${reset}" \
               "${sub_message%%>> *}>>" "${sub_message##*>>}"
         else
            printf "${yellow}%25s ${blue}|${reset}" "${operation}"
         fi

         # Colorize the operational status
         case "${operation_summary[$operation]}" in
            'Operation Completed')
               printf " ${green}%s${reset}\n" "${operation_summary[$operation]}"
            ;;
            'Operation Interrupted')
               printf " ${cyan}%s${reset}\n" "${operation_summary[$operation]}"
            ;;
            'Operation Did Not Run')
               printf " ${magenta}%s${reset}\n" "${operation_summary[$operation]}"
            ;;
            *'Issue'*)
               printf " ${red}%s${reset}\n" "${operation_summary[$operation]}"
            ;;
         esac
      fi
   done

   # Last line of chart
   printf " ${blue}%s${reset}\n" \
      "-------------------------+-------------------------"

   # Remove temporary FIFOs and files
   rm -f "${job_fifo}" "${tmp_aucdtect_fd}" "${issue_ticks}"

   printf "\033[?25h"   # Restore cursor
}

#-------------------------------------------------------------------------------

__run_parallel() {
   # Run a given operation with a specified number of jobs
   #--
   # $1 is the operational function to run multiple jobs, which can be:
   #   aucdtect                  md5_check           compress_verify
   #   compress_no_test          test                replaygain_test
   #   replaygain_force_apply    replaygain_apply    retag_analyze
   #   retag_apply               extract_images      prune
   #--
   # Set up local variables/arrays
   declare      item
   declare  -i  row_state  placement  previous_placement  iteration=0

   # Determine the whitespace to make up max length by operation
   case "$1" in
      replaygain_* | retag_*)  spacing='11'  ;;
      *)                       spacing='9'   ;;
   esac

   row_state=$(__row)                       # Current cursor row position state

   for item in "${total_items[@]:0:${jobs}}" ; do
      # Run as many operations (from $total_items[@]) in the background,
      # specified via $jobs
      #--
      placement=$((row_state + iteration))  # Placement of file/dir processed
      ((iteration++))                       # After placement to not print 0
      number_completed="[${iteration}/${#total_items[@]}]"  # eg. [56/213]

      # Max filename allowed (to fit within screen)
      max_length="$(( columns - ${#number_completed} - spacing ))"

      # Fork process
      __$1 "${item}" "$1" "${number_completed}" $((iteration - 1)) &
   done

   # Continue only if there are more items than jobs specified
   if (( ${#total_items[@]} > jobs )) ; then
      while read -r previous_placement ; do
         # An operation is completed with an integer and newline sent to a FIFO.
         # The integer is that row position an operation was on.  For each
         # newline read in, process another file/dir from $total_items[@]
         #--
         # Placement of file/dir relative to previous operation's placement
         placement=$((row_state + previous_placement))

         # If current number of FLACs to process is less than total FLACs
         # found, add another FLAC to process
         if (( iteration < ${#total_items[@]} )) ; then
            item="${total_items[${iteration}]}"  # Current file/dir to process
            ((iteration++))                      # Increase count
            number_completed="[${iteration}/${#total_items[@]}]"  # eg. [56/213]

            # Max filename allowed (to fit within screen)
            max_length="$(( columns - ${#number_completed} - spacing ))"

            # Fork process
            __$1 "${item}" "$1" "${number_completed}" "${previous_placement}" &
         else
            break                         # Prevent read hanging FIFO
         fi
      done <&3                            # Read from FIFO
   fi

   wait  # Wait for children processes
}

#-------------------------------------------------------------------------------

__replaygain_test() {
   # Test FLAC file's for ReplayGain application
   #--
   # $1 is the filename
   # $2 is the operation that's currently being run, of which, can be:
   #   aucdtect                  md5_check           compress_verify
   #   compress_no_test          test                replaygain_test
   #   replaygain_force_apply    replaygain_apply    retag_analyze
   #   retag_apply               extract_images      prune
   # $3 is a string representing number items processed, eg: [43/439]
   # $4 is the current operation's row placement
   #--
   trap '__kill_jobs "$(jobs -rp)"' EXIT

   # Set up local variables
   declare    file_basename
   declare -i file_length

   # Truncate file, if necessary, and grab file information, splitting on
   # Unit Separator (\037)
   IFS=$'\037' read -r file_basename file_length < <(__truncate_filename "$1")

   # Print current FLAC being processed
   __print_item "${file_basename}" "${file_length}" "$3" 'sub'

   # Check if file is a FLAC file (capture output) via obtaining the sample
   # rate of the current file.  The sample rate captured will be tested against
   # later on.  Hide STDERR as we'll test the exit code instead
   current_sample_rate="$(metaflac --show-sample-rate "${1}" 2>/dev/null)"

   # Exit code 1 implies failure (130 is SIGINT)
   if (( ${?} == 1 )) ; then
      # Error with FLAC file, display failed/error
      __print_status 'fail' "${file_basename}" "${file_length}" 'sub'

      # Log FLAC failure
      printf "%s${unit_separator}Not a real FLAC file\n" "${1}" \
         >> "${log_file}"

      printf '.' >> "${issue_ticks}"  # Add one tick to total issues
   else
      # File is OK, test if sample rate is above 48kHz and the version of
      # `metaflac' installed is greater than 1.2.1
      if (( current_sample_rate > 48000 )) ; then

         # Sample rate is greater than 48kHz, so check to make sure the
         # version of `metaflac' is greater than 1.2.1
         if (( $(__metaflac_version) < 3 )) ; then
            # Old version of `metaflac' installed, display skipped
            __print_status 'skip' "${file_basename}" "${file_length}" 'sub'

            # The `metaflac' version installed is NOT greater than 1.2.1 so
            # skip processing current FLAC file, logging why it was skipped
            printf "%s${unit_separator}FLAC 1.3.0 or higher needed for sample rates >48kHz\n" "${1}" \
               >> "${log_file}"

            printf '.' >> "${issue_ticks}"  # Add one tick to total issues
         else
            # FLAC is ok, display ok
            __print_status 'ok' "${file_basename}" "${file_length}" 'sub'

         fi
      else
         # FLAC is ok, display ok
         __print_status 'ok' "${file_basename}" "${file_length}" 'sub'
      fi
   fi
   printf "$4\n" >&3  # Store row position and end operation
}

#-------------------------------------------------------------------------------

__replaygain_apply() {
   # Apply ReplayGain to each directory of FLAC files (if values are missing)
   #--
   # $1 is the directory (includes a slash, ie 'dir/'
   # $2 is the operation that's currently being run, of which, can be:
   #   aucdtect                  md5_check           compress_verify
   #   compress_no_test          test                replaygain_test
   #   replaygain_force_apply    replaygain_apply    retag_analyze
   #   retag_apply               extract_images      prune
   # $3 is a string representing number items processed, eg: [43/439]
   # $4 is the current operation's row placement
   #--
   trap '__kill_jobs "$(jobs -rp)"' EXIT

   # Set up local variables
   declare file_basename percent_complete
   declare -i file_length
   declare -a replaygain_tags

   # Truncate file, if necessary, and grab file information, splitting on
   # Unit Separator (\037)
   IFS=$'\037' read -r file_basename file_length < <(__truncate_filename "$1")

   # Print current FLAC being processed
   __print_item "${file_basename}" "${file_length}" "$3" 'sub'

   # ${j} is a FLAC file -> under a directory, ${1}
   for j in "${1}"*${flac_extension} ; do
      # Grab all of the ReplayGain tags
      mapfile -n0 -t replaygain_tags < \
      <(
         metaflac \
            --show-tag=REPLAYGAIN_REFERENCE_LOUDNESS \
            --show-tag=REPLAYGAIN_TRACK_GAIN \
            --show-tag=REPLAYGAIN_TRACK_PEAK \
            --show-tag=REPLAYGAIN_ALBUM_GAIN \
            --show-tag=REPLAYGAIN_ALBUM_PEAK \
            "${j}"
      )

      # Test if any ReplayGain values are empty (if there are less
      # than 5 values in the replaygain array)
      if (( ${#replaygain_tags[@]} < 5 )) ; then
         # At _least_ one tag is missing from current file, so
         # apply new ReplayGain values
         #
         # Add ReplayGain to FLAC files under directory.  Metaflac
         # automatically removes old ReplayGain values (if any) before
         # proceeding
         metaflac --add-replay-gain "${1}"/*${flac_extension} >/dev/null 2>&1

         # Exit code 130 is SIGINT so only check for exit code '1'
         if (( ${?} == 1 )) ; then
            # Failed applying ReplayGain values, display failed/error
            __print_status 'fail' "${file_basename}" "${file_length}" 'sub'

            # Log ReplayGain error
            printf "%s${unit_separator}Corrupt FLAC(s) or differing sample rates (album ReplayGain)\n" "${1}" \
               >> "${log_file}"

            printf '.' >> "${issue_ticks}"  # Add one tick to total issues

            # Placeholder variable tested after this loop if the loop completes
            # with 'break'
            broke_out_of_loop="true"

            # Break out of loop and on to next directory
            break
         else
            # Applied ReplayGain successfully
            __print_status 'ok' "${file_basename}" "${file_length}" 'sub'
         fi
      else
         # All FLACs have ReplayGain applied
         __print_status 'ok' "${file_basename}" "${file_length}" 'sub'
      fi
   done
   printf "$4\n" >&3  # Store row position and end operation
}

#-------------------------------------------------------------------------------

__replaygain_force_apply() {
   # Apply ReplayGain to each directory of FLAC files (force new values)
   #--
   # $1 is the directory (includes a slash, ie 'dir/'
   # $2 is the operation that's currently being run, of which, can be:
   #   aucdtect                  md5_check           compress_verify
   #   compress_no_test          test                replaygain_test
   #   replaygain_force_apply    replaygain_apply    retag_analyze
   #   retag_apply               extract_images      prune
   # $3 is a string representing number items processed, eg: [43/439]
   # $4 is the current operation's row placement
   #--
   trap '__kill_jobs "$(jobs -rp)"' EXIT

   # Set up local variables
   declare    file_basename  percent_complete
   declare -i file_length

   # Truncate file, if necessary, and grab file information, splitting on
   # Unit Separator (\037)
   IFS=$'\037' read -r file_basename file_length < <(__truncate_filename "$1")

   # Print current FLAC being processed
   __print_item "${file_basename}" "${file_length}" "$3" 'sub'

   # Add ReplayGain to FLAC files under directory
   metaflac --add-replay-gain "${1}"*${flac_extension} >/dev/null 2>&1

   # Exit code 130 is SIGINT so only check for exit code '1'
   if (( ${?} == 1 )) ; then
      # Failed applying ReplayGain values, display failed/error
      __print_status 'fail' "${file_basename}" "${file_length}" 'sub'

      # Log ReplayGain error
      printf "%s${unit_separator}Corrupt FLAC(s) or differing sample rates (album ReplayGain)\n" "${1}" \
         >> "${log_file}"

      printf '.' >> "${issue_ticks}"  # Add one tick to total issues
   else
      # Applied ReplayGain successfully
      __print_status 'ok' "${file_basename}" "${file_length}" 'sub'
   fi
   printf "$4\n" >&3  # Store row position and end operation
}

#-------------------------------------------------------------------------------

__compress_verify() {
   # Compress FLACs with user-defined compression level, verifying its integrity
   #--
   # $1 is the directory
   # $2 is the operation that's currently being run, of which, can be:
   #   aucdtect                  md5_check           compress_verify
   #   compress_no_test          test                replaygain_test
   #   replaygain_force_apply    replaygain_apply    retag_analyze
   #   retag_apply               extract_images      prune
   # $3 is a string representing number items processed, eg: [43/439]
   # $4 is the current operation's row placement
   #--
   trap '__kill_jobs "$(jobs -rp)"' EXIT

   # Set up local variables
   declare    file_basename percent_complete
   declare -i file_length

   # Truncate file, if necessary, and grab file information, splitting on
   # Unit Separator (\037)
   IFS=$'\037' read -r file_basename file_length < <(__truncate_filename "$1")

   # Print current FLAC being processed
   __print_item "${file_basename}" "${file_length}" "$3"

   # Test for COMPRESSION level in FLAC file. Hide error output since
   # we'll be verifying the FLAC file later
   COMPRESSION="$(metaflac --show-tag=COMPRESSION "${1}" 2> /dev/null)"
   COMPRESSION="${COMPRESSION#*=}"

   if (( COMPRESSION != compression_level )) ; then
      flac --no-error-on-compression-fail -f -${compression_level} -V "${1}" 2> >(while read -r -d'%' percent_complete ; do
         # Compress given FLAC file, verifying with a progress bar
         #--
         # Current percent complete
         percent_complete="$( __get_percent_complete "$2" "${percent_complete}" )"

         # Print operation progress bar and percent complete
         __print_progress "$2" "${percent_complete}" "${file_basename}" "${file_length}"
      done) >/dev/null

      # Exit code 1 implies failure (130 is SIGINT)
      if (( ${?} == 1 )) ; then
         # Error with FLAC file, display failed/error
         __print_status 'fail' "${file_basename}" "${file_length}"

         # Log FLAC failure
         printf "%s${unit_separator}Failed verification\n" "${1}" \
            >> "${log_file}"

         printf '.' >> "${issue_ticks}"  # Add one tick to total issues
      else
         metaflac \
            --remove-tag=COMPRESSION \
            --set-tag=COMPRESSION=${compression_level} "${1}"

         # FLAC is ok, display ok
         __print_status 'ok' "${file_basename}" "${file_length}"
      fi
   else
      # If already at compression_level, test the FLAC file instead
      flac -t "${1}" 2> >(while read -r -d'%' percent_complete ; do
         # Test given FLAC file, with a progress bar
         #--
         # Current percent complete
         percent_complete="$( __get_percent_complete 'test' "${percent_complete}" )"

         # Print operation progress bar and percent complete
         __print_progress 'test' "${percent_complete}" "${file_basename}" "${file_length}"
      done) >/dev/null

      # Exit code 1 implies failure (130 is SIGINT)
      if (( ${?} == 1 )) ; then
         # Error with FLAC file, display failed/error
         __print_status 'fail' "${file_basename}" "${file_length}"

         # Log FLAC failure
         printf "%s${unit_separator}Failed verification\n" "${i}" \
            >> "${log_file}"

         printf '.' >> "${issue_ticks}"  # Add one tick to total issues
      else
         # FLAC is ok, display ok
         __print_status 'ok' "${file_basename}" "${file_length}"
      fi
   fi
   printf "$4\n" >&3  # Store row position and end operation
}

#-------------------------------------------------------------------------------

__compress_no_test() {
   # Compress FLACs with user-defined compression level, verifying its integrity
   # and _not_ falling back to __test() if the compression level is already set
   #--
   # $1 is the directory
   # $2 is the operation that's currently being run, of which, can be:
   #   aucdtect                  md5_check           compress_verify
   #   compress_no_test          test                replaygain_test
   #   replaygain_force_apply    replaygain_apply    retag_analyze
   #   retag_apply               extract_images      prune
   # $3 is a string representing number items processed, eg: [43/439]
   # $4 is the current operation's row placement
   #--
   trap '__kill_jobs "$(jobs -rp)"' EXIT

   # Set up local variables
   declare    file_basename percent_complete
   declare -i file_length

   # Truncate file, if necessary, and grab file information, splitting on
   # Unit Separator (\037)
   IFS=$'\037' read -r file_basename file_length < <(__truncate_filename "$1")

   # Print current FLAC being processed
   __print_item "${file_basename}" "${file_length}" "$3"

   # Test for COMPRESSION level in FLAC file. Hide error output since
   # we'll be verifying the FLAC file later
   COMPRESSION="$(metaflac --show-tag=COMPRESSION "${1}" 2> /dev/null)"
   COMPRESSION="${COMPRESSION#*=}"

   if (( COMPRESSION != compression_level )) ; then
      flac --no-error-on-compression-fail -f -${compression_level} -V "${1}" 2> >(while read -r -d'%' percent_complete ; do
         # Compress given FLAC file, verifying with a progress bar
         #--
         # Current percent complete
         percent_complete="$( __get_percent_complete "$2" "${percent_complete}" )"

         # Print operation progress bar and percent complete
         __print_progress "$2" "${percent_complete}" "${file_basename}" "${file_length}"
      done) >/dev/null

      # Exit code 1 implies failure (130 is SIGINT)
      if (( ${?} == 1 )) ; then
         # Error with FLAC file, display failed/error
         __print_status 'fail' "${file_basename}" "${file_length}"

         # Log FLAC failure
         printf "%s${unit_separator}Failed verification\n" "${1}" \
            >> "${log_file}"

         printf '.' >> "${issue_ticks}"  # Add one tick to total issues
      else
         metaflac \
            --remove-tag=COMPRESSION \
            --set-tag=COMPRESSION=${compression_level} "${1}"

         # FLAC is ok, display ok
         __print_status 'ok' "${file_basename}" "${file_length}"
      fi
   else
      # Already at compression_level, print skipped FLAC file
      __print_status 'skip' "${file_basename}" "${file_length}"
   fi
   printf "$4\n" >&3  # Store row position and end operation
}

#-------------------------------------------------------------------------------

__test() {
   # Test FLAC file integrity
   #--
   # $1 is the filename
   # $2 is the operation that's currently being run, of which, can be:
   #   aucdtect                  md5_check           compress_verify
   #   compress_no_test          test                replaygain_test
   #   replaygain_force_apply    replaygain_apply    retag_analyze
   #   retag_apply               extract_images      prune
   # $3 is a string representing number items processed, eg: [43/439]
   # $4 is the current operation's row placement
   #--
   trap '__kill_jobs "$(jobs -rp)"' EXIT

   # Set up local variables
   declare    file_basename percent_complete
   declare -i file_length

   # Truncate file, if necessary, and grab file information, splitting on
   # Unit Separator (\037)
   IFS=$'\037' read -r file_basename file_length < <(__truncate_filename "$1")

   # Print current FLAC being processed
   __print_item "${file_basename}" "${file_length}" "$3"

   flac -t "${1}" 2> >(while read -r -d'%' percent_complete ; do
      # Test given FLAC file, with a progress bar
      #--
      # Current percent complete
      percent_complete="$( __get_percent_complete "$2" "${percent_complete}" )"

      # Print operation progress bar and percent complete
      __print_progress "$2" "${percent_complete}" "${file_basename}" "${file_length}"
   done) >/dev/null

   # Exit code 1 implies failure (130 is SIGINT)
   if (( ${?} == 1 )) ; then
      # Error with FLAC file, display failed/error
      __print_status 'fail' "${file_basename}" "${file_length}"

      # Log FLAC failure
      printf "%s${unit_separator}Failed testing\n" "${i}" >> "${log_file}"

      printf '.' >> "${issue_ticks}"  # Add one tick to total issues
   else
      # FLAC is ok, display ok
      __print_status 'ok' "${file_basename}" "${file_length}"
   fi
   printf "$4\n" >&3  # Store row position and end operation
}

#-------------------------------------------------------------------------------

__aucdtect() {
   # Test FLAC validity with auCDtect
   #--
   # $1 is the filename
   # $2 is the operation that's currently being run, of which, can be:
   #   aucdtect                  md5_check           compress_verify
   #   compress_no_test          test                replaygain_test
   #   replaygain_force_apply    replaygain_apply    retag_analyze
   #   retag_apply               extract_images      prune
   # $3 is a string representing number items processed, eg: [43/439]
   # $4 is the current operation's row placement
   #--
   trap '__kill_jobs "$(jobs -rp)"' EXIT

   # Set up local arrays/variables
   declare    file_basename percent_complete
   declare -i file_length
   declare -a bits_mastering

   # Truncate file, if necessary, and grab file information, splitting on
   # Unit Separator (\037)
   IFS=$'\037' read -r file_basename file_length < <(__truncate_filename "$1")

   # Print current FLAC being processed
   __print_item "${file_basename}" "${file_length}" "$3"

   # Get the bit depth and MASTERING tag of a FLAC file.  Also used to check if
   # FLAC file is real.  Hide STDERR output.  The array indices are:
   #   bits_mastering[0] = bit depth (eg, 16)
   #   bits_mastering[1] = MASTERING tag & value (eg, MASTERING=Lossy)
   bits_mastering=( $(metaflac --show-bps --show-tag=MASTERING "$1" 2>/dev/null) )

   # Exit code 1 implies failure (130 is SIGINT)
   if (( ${?} == 1 )) ; then
      # Error with FLAC file, display failed/error
      __print_status 'fail' "${file_basename}" "${file_length}"

      # Log FLAC failure
      printf "%s${unit_separator}Not a real FLAC file\n" "$1" \
         >> "${log_file}"

      printf '.' >> "${issue_ticks}"  # Add one tick to total issues

   # Skip the FLAC file if it has a bit depth greater
   # than 16 since auCDtect doesn't support audio
   # files with a higher resolution than a CD.
   elif (( ${bits_mastering[0]} > 16 )) ; then
      # Print skipped FLAC
      __print_status 'skip' "${file_basename}" "${file_length}"

      # Log skipped FLAC file
      printf "%s${unit_separator}auCDtect does not support a bit depth >16\n" "$1" \
         >> "${log_file}"

      printf '.' >> "${issue_ticks}"  # Add one tick to total issues

   # Skip the FLAC file if it already has the 'Lossy' value set for the
   # MASTERING tag.  This is only done if the value of 'skip_lossy' is 'true',
   # set in the configuration file.  We make sure to remove 'MASTERING=' before
   # testing the tag field
   elif [[ "${bits_mastering[1]#*=}" == 'Lossy' ]] ; then
      # Print skipped FLAC
      __print_status 'skip' "${file_basename}" "${file_length}"

      # Log skipped FLAC file
      printf "%s${unit_separator}MASTERING=Lossy value found; skipping ('skip_lossy' configuration)\n" "${1}" \
         >> "${log_file}"

      printf '.' >> "${issue_ticks}"  # Add one tick to total issues

   # FLAC checks out, continue processing
   else
      # Print current FLAC being processed
      __print_item "${file_basename}" "${file_length}" "$3" 'decode'

      # The WAV file to be created from current FLAC file
      decoded_wav="${1%${flac_extension}}_redoflacs_$$.wav"

      flac -d "${1}" -o "${decoded_wav}" 2> >(while read -r -d'%' percent_complete ; do
         # Decode FLAC to WAV so auCDtect can read the audio file
         #--
         # Current percent complete
         percent_complete="$( __get_percent_complete 'decode' "${percent_complete}" )"

         # Print operation progress bar and percent complete
         __print_progress 'decode' "${percent_complete}" "${file_basename}" "${file_length}"
      done) >/dev/null

      # Exit code 130 is SIGINT so only check for exit code '1'.  If FLAC file
      # failed decoding to WAV, log error, otherwise continue processing
      if (( ${?} == 1 )) ; then
         # Error with FLAC file, display failed/error
         __print_status 'fail' "${file_basename}" "${file_length}" 'decode'

         # Log FLAC failure
         printf "%s${unit_separator}Failed decoding to WAV\n" "${1}" \
            >> "${log_file}"

         printf '.' >> "${issue_ticks}"  # Add one tick to total issues
      else
         # Decoded FLAC is ok, display ok
         __print_status 'ok' "${file_basename}" "${file_length}" 'decode'

         # Print current FLAC being processed, auCDtect: fast
         __print_item "${file_basename}" "${file_length}" "$3" 'aucdtect_fast'

         # 'export MALLOC_CHECK_' allows the dynamic linked version of
         # `auCDTECT' to run without throwing errors
         export MALLOC_CHECK_="0"

         # The actual auCDtect command with medium accuracy setting (for
         # speed).  STDOUT is sent to file descriptor '4'
         _aucdtect -m20 "${decoded_wav}" 2> >(while read -r -d'%' percent_complete ; do
            # Check FLAC validity by checking decoded WAV via auCDtect (fast)
            #--
            # Current percent complete
            percent_complete="$( __get_percent_complete "$2" "${percent_complete}" )"

            # Print operation progress bar and percent complete
            __print_progress 'aucdtect_fast' "${percent_complete}" "${file_basename}" "${file_length}"
         done) >&4

         # Exit code 130 is SIGINT so only check for exit code '1'
         if (( ${?} == 1 )) ; then
            # Error with FLAC file, display failed/error
            __print_status 'fail' "${file_basename}" "${file_length}" 'aucdtect_fast'

            # Log FLAC failure
            printf "%s${unit_separator}Failed analyzing decoded FLAC\n" "${1}" \
               >> "${log_file}"

            printf '.' >> "${issue_ticks}"  # Add one tick to total issues
         else
            # Grab the conclusion of auCDtect's command
            # Below options prevents hanging FIFO by only reading
            # what is necessary:
            #    -s7:  Discard first seven lines from auCDtect's output
            #    -n2:  Only grab 2 lines from auCDtect's output
            #     -t:  Remove trailing newlines from auCDtect's output
            #    -u4:  Obtain auCDtect's output from file descriptor '4'
            #  array:  Store captured output into 'aucdtect_check_array'
            mapfile -s7 -n2 -t -u4 aucdtect_check_array

            # If there is an issue with the processed FLAC file, run
            # auCDtect once again with highest setting
            if [[ "${aucdtect_check_array[0]}" != 'This track looks like CDDA with probability 100%' ]] ; then
               # Print current FLAC being processed, auCDtect: slow
               __print_item "${file_basename}" "${file_length}" "$3" 'aucdtect_slow'

               # The actual auCDtect command with highest accuracy setting.
               # STDOUT is sent to file descriptor '4'
               _aucdtect -m0 "${decoded_wav}" 2> >(while read -r -d'%' percent_complete ; do
                  # Check FLAC validity by checking decoded WAV via auCDtect (slow)
                  #--
                  # Current percent complete
                  percent_complete="$( __get_percent_complete "$2" "${percent_complete}" )"

                  # Print operation progress bar and percent complete
                  __print_progress 'aucdtect_slow' "${percent_complete}" "${file_basename}" "${file_length}"
               done) >&4

               # Exit code 130 is SIGINT so only check for exit code '1'
               if (( ${?} == 1 )) ; then
                  # Error with FLAC file, display failed/error
                  __print_status 'fail' "${file_basename}" "${file_length}" 'aucdtect_slow'

                  # Log FLAC failure
                  printf "%s${unit_separator}Failed analyzing decoded FLAC\n" "${1}" \
                     >> "${log_file}"

                  printf '.' >> "${issue_ticks}"  # Add one tick to total issues
               else
                  # Grab the conclusion of auCDtect's command
                  # Below options prevents hanging FIFO by only reading
                  # what is necessary:
                  #    -s7:  Discard first seven lines from auCDtect's output
                  #    -n2:  Only grab 2 lines from auCDtect's output
                  #     -t:  Remove trailing newlines from auCDtect's output
                  #    -u4:  Obtain auCDtect's output from file descriptor '4'
                  #  array:  Store captured output into 'aucdtect_check_array'
                  mapfile -s7 -n2 -t -u4 aucdtect_check_array

                  # There is an issue with the processed FLAC file
                  if [[ "${aucdtect_check_array[0]}" != 'This track looks like CDDA with probability 100%' ]] ; then
                     # If user specified '-A, --aucdtect-spectrogram', then
                     # create a spectrogram with SoX and change logging accordingly
                     if [[ "${create_spectrogram}" == 'true' ]] ; then
                        # Check whether to place spectrogram images in user-defined location
                        if [[ -z "${spectrogram_location}" ]] ; then
                           # Obtain basename of current FLAC file
                           flac_file="${1##*/}"

                           # Obtain dirname of current FLAC file
                           spectrogram_dirname="${1%/*}"

                           # Create the spectrogram with '.png' as the
                           # file extension, placed in the same
                           # directory as the current FLAC file
                           spectrogram_picture="${spectrogram_dirname}/[${iteration}] ${flac_file%${flac_extension}}.png"
                        else
                           # Obtain basename of current FLAC file
                           flac_file="${1##*/}"

                           # Create the spectrogram with '.png' as the
                           # file extension, placed in the user-defined
                           # location
                           spectrogram_picture="${spectrogram_location}/[${iteration}] ${flac_file%${flac_extension}}.png"
                        fi

                        # Print current FLAC being processed
                        __print_item "${file_basename}" "${file_length}" "$3" 'spectrogram'

                        # SoX command to create the spectrogram and
                        # place it in spectrogram_picture.  Use the
                        # following arguments to create the highest
                        # resolution spectrograms:
                        #   -x 5000
                        #   -y 1025
                        _sox "${decoded_wav}" \
                           -S \
                           -n spectrogram \
                           -c '' \
                           -t "${i}" \
                           -p 1 \
                           -z 90 \
                           -Z 0 \
                           -q 249 \
                           -w Hann \
                           -x 1800 \
                           -y 513 \
                           -o "${spectrogram_picture}" 2> >(
                              while read -r -d'%' percent_complete ; do
                                 # Create spectrogram PNG image of given FLAC
                                 #--
                                 # Current percent complete
                                 percent_complete="$( __get_percent_complete "$2" "${percent_complete}" )"

                                 # Print operation progress bar and percent complete
                                 __print_progress 'spectrogram' "${percent_complete}" "${file_basename}" "${file_length}"
                              done
                           ) >/dev/null

                        # Error creating spectrogram, display issue
                        __print_status 'issue' "${file_basename}" "${file_length}" 'spectrogram'

                        # Log auCDtect report
                        printf "%s${unit_separator}%s (%s)\n" "$1" "${aucdtect_check_array[0]}" "${spectrogram_picture}" \
                           >> "${log_file}"

                        printf '.' >> "${issue_ticks}"  # Add one tick to total issues
                     else
                        # Issue with FLAC authenticity, display issue
                        __print_status 'issue' "${file_basename}" "${file_length}" 'aucdtect_slow'

                        # Log auCDtect report
                        printf "%s${unit_separator}%s\n" "$1" "${aucdtect_check_array[0]}" \
                           >> "${log_file}"

                        printf '.' >> "${issue_ticks}"  # Add one tick to total issues
                     fi
                  else
                     # FLAC is ok, display ok
                     __print_status 'ok' "${file_basename}" "${file_length}" 'aucdtect_slow'
                  fi
               fi
            else
               # FLAC is ok, display ok
               __print_status 'ok' "${file_basename}" "${file_length}" 'aucdtect_fast'
            fi

            # Remove temporary WAV file
            rm "${decoded_wav}"
         fi
      fi
   fi
   printf "$4\n" >&3  # Store row position and end operation
}

#-------------------------------------------------------------------------------

__md5_check() {
   # Check for valid MD5 checksum in FLAC file
   #--
   # $1 is the filename
   # $2 is the operation that's currently being run, of which, can be:
   #   aucdtect                  md5_check           compress_verify
   #   compress_no_test          test                replaygain_test
   #   replaygain_force_apply    replaygain_apply    retag_analyze
   #   retag_apply               extract_images      prune
   # $3 is a string representing number items processed, eg: [43/439]
   # $4 is the current operation's row placement
   #--
   trap '__kill_jobs "$(jobs -rp)"' EXIT

   # Set up local variables
   declare    file_basename percent_complete md5_sum
   declare -i file_length

   # Truncate file, if necessary, and grab file information, splitting on
   # Unit Separator (\037)
   IFS=$'\037' read -r file_basename file_length < <(__truncate_filename "$1")

   # Print current FLAC being processed
   __print_item "${file_basename}" "${file_length}" "$3"

   # Get the MD5 checksum (hide stderr output).  Also
   # used to check if FLAC file is real
   md5_sum="$(metaflac --show-md5sum "$1" 2>/dev/null)"

   # Exit code 1 implies failure (130 is SIGINT)
   if (( ${?} == 1 )) ; then
      # Error with FLAC file, display failed/error
      __print_status 'fail' "${file_basename}" "${file_length}"

      # Log FLAC failure
      printf "%s${unit_separator}Not a real FLAC file\n" "${1}" \
         >> "${log_file}"

      printf '.' >> "${issue_ticks}"  # Add one tick to total issues
   # FLAC file is real, check for unset MD5 checksum.  We cannot use an
   # arithmetic expression as any amount of 0's will equal the expression
   # below
   elif [[ "${md5_sum}" == "00000000000000000000000000000000" ]] ; then
      # Error with FLAC file, display failed/error
      __print_status 'fail' "${file_basename}" "${file_length}"

      # Log FLAC failure
      printf "%s${unit_separator}Unset MD5 signature (00000000000000000000000000000000)\n" "${1}" \
         >> "${log_file}"

      printf '.' >> "${issue_ticks}"  # Add one tick to total issues
   else
      # FLAC is ok, display ok
      __print_status 'ok' "${file_basename}" "${file_length}"
   fi
   printf "$4\n" >&3  # Store row position and end operation
}

#-------------------------------------------------------------------------------

__retag_analyze() {
   # Check for missing VORBIS tags from a given FLAC
   #--
   # $1 is the filename
   # $2 is the operation that's currently being run, of which, can be:
   #   aucdtect                  md5_check           compress_verify
   #   compress_no_test          test                replaygain_test
   #   replaygain_force_apply    replaygain_apply    retag_analyze
   #   retag_apply               extract_images      prune
   # $3 is a string representing number items processed, eg: [43/439]
   #--
   trap '__kill_jobs "$(jobs -rp)"' EXIT

   # Set up local variables
   declare    file_basename
   declare -i file_length

   # Truncate file, if necessary, and grab file information, splitting on
   # Unit Separator (\037)
   IFS=$'\037' read -r file_basename file_length < <(__truncate_filename "$1")

   # Print current FLAC being processed
   __print_item "${file_basename}" "${file_length}" "$3" 'sub'

   # Check if file is a FLAC file (variable hides output)
   check_flac="$(metaflac --show-md5sum "${1}" 2>&1)"

   # Exit code 1 implies failure (130 is SIGINT)
   if (( ${?} == 1 )) ; then
      # Error with FLAC file, display failed/error
      __print_status 'fail' "${file_basename}" "${file_length}" 'sub'

      # Log FLAC failure
      printf "%s${unit_separator}Not a real FLAC file\n" "${1}" \
         >> "${log_file}"

      printf '.' >> "${issue_ticks}"  # Add one tick to total issues
   else
      # Iterate through each tag field and check if tag is missing
      for j in "${tags[@]}" ; do
         # Check if ALBUMARTIST is in tag array and apply operations on
         # the tag field if it exists
         if [[ "${j}" == "ALBUMARTIST" ]] ; then
            # ALBUMARTIST exists in tag array so allow script to check the
            # various naming conventions within the FLAC files (ie,
            # 'ALBUM ARTIST' or 'ALBUM_ARTIST')

            # "ALBUMARTIST" or "ALBUM ARTIST" or "ALBUM_ARTIST", case-insensitive
            if [[ -n "$(metaflac --show-tag=ALBUMARTIST "${1}")" ]] ; then
               show_tag_list+=( "--show-tag=ALBUMARTIST" )

            elif [[ -n "$(metaflac --show-tag="ALBUM ARTIST" "${1}")" ]] ; then
               show_tag_list+=( "--show-tag='ALBUM ARTIST'" )

            elif [[ -n "$(metaflac --show-tag="ALBUM_ARTIST" "${1}")" ]] ; then
               show_tag_list+=( "--show-tag=ALBUM_ARTIST" )
            fi
         else
            # Build up metaflac '--show-tag=' list
            show_tag_list+=( "--show-tag=${j}" )
         fi
      done

      # Load up all the tag values for current file
      mapfile -n0 -t metaflac_tag_array < \
      <(
         metaflac \
            "${show_tag_list[@]}" \
            "${1}"
      )

      # Take above tag values and create an associative
      # array using TAG_FIELD=TAG_VALUE as the key/value pair
      #
      # Specifically declare an empty associative array
      declare -A temp_tag_array

      # Run through the tag array from above and store
      # the values into a temporary tag array
      for tag_field_value in "${metaflac_tag_array[@]}" ; do
         # This is the tag field (eg. TITLE)
         tag_field="${tag_field_value%%=*}"

         # Enforce the tag field to be uppercase
         # ${tag_field_value} below is the tag value
         temp_tag_array+=( ["${tag_field^^}"]="${tag_field_value#*=}" )
      done

      # Run through the tags array and test each tag value from
      # ${temp_tag_array} with the currently processed tag in ${tag[@]}.  For
      # each match found, test if the tag value is null, reporting any missing
      # tags. Then remove the tag field (index) from the ${temp_tag_array}, so
      # the next iteration is faster and we can check for missing tags (tag
      # fields)
      for j in "${tags[@]}" ; do

         # If the total # of indices in the temporary tag array is above
         # 0, continue testing, else store missing tag (${j}) into the
         # missing tags array
         if (( ${#temp_tag_array[@]} > 0 )) ; then

            # Compare each tag field from the temporary array to ${j},
            # checking if they are equal and if so, check for missing
            # tag values
            for temp_tag_field in "${!temp_tag_array[@]}" ; do
               # Both tag fields are equal
               if [[ "${j}" == "${temp_tag_field}" ]] ; then
                  # Check if tag value is null, logging missing tags if so
                  if [[ -z "${temp_tag_array[${temp_tag_field}]}" ]] ; then
                     missing_tags+="${j}, "
                  fi

                  # Remove the current tag field from the temporary tag
                  # array since it's been matched already
                  unset -v temp_tag_array[${temp_tag_field}]

                  # This variable let's the script know that the current
                  # tag, ${j} has been matched up with a tag field in
                  # ${temp_tag_array[@]}
                  tag_match="true"

                  # Break out of loop since the tag fields have been
                  # matched, continuing on to the next iteration of ${j}
                  break
               fi
            done

            # If there wasn't a tag field in the temporary tag array
            # ( eg. ${temp_tag_array[@]} ) that matched ${j}, the FLAC file
            # must have a missing tag, so log it by throwing the missing tag
            # into the missing tags array
            if [[ "${tag_match}" != "true" ]] ; then
               missing_tags+="${j}, "
            fi

            # Reset the value of tag match (if any) for the next iteration
            # of ${j}
            unset -v tag_match

         # The total # of indices in the temporary tag array is 0, so
         # whatever is left in ${tags[@]} represented by ${j} is logged
         # as missing
         else
            missing_tags+="${j}, "
         fi
      done

      # If missing_tags_array is not empty, there are missing
      # tags in the current file so log output
      if [[ -n "${missing_tags}" ]] ; then
         # Error with FLAC file, display failed/error
         __print_status 'fail' "${file_basename}" "${file_length}" 'sub'

         # Log the missing tags
         printf "%s${unit_separator}Missing tags: ${missing_tags%, }\n" "${1}" \
            >> "${log_file}"

         printf '.' >> "${issue_ticks}"  # Add one tick to total issues
      else
         # There are no missing tags, display ok
         __print_status 'ok' "${file_basename}" "${file_length}" 'sub'
      fi
   fi
   printf "$4\n" >&3  # Store row position and end operation
}

#-------------------------------------------------------------------------------

__retag_apply() {
   # Re-apply the VORBIS tags specified in the config file, removing all others
   #--
   # $1 is the filename
   # $2 is the operation that's currently being run, of which, can be:
   #   aucdtect                  md5_check           compress_verify
   #   compress_no_test          test                replaygain_test
   #   replaygain_force_apply    replaygain_apply    retag_analyze
   #   retag_apply               extract_images      prune
   # $3 is a string representing number items processed, eg: [43/439]
   # $4 is the current operation's row placement
   #--
   trap '__kill_jobs "$(jobs -rp)"' EXIT

   # Set up local variables
   declare    file_basename
   declare -i file_length

   # Truncate file, if necessary, and grab file information, splitting on
   # Unit Separator (\037)
   IFS=$'\037' read -r file_basename file_length < <(__truncate_filename "$1")

   # Print current FLAC being processed
   __print_item "${file_basename}" "${file_length}" "$3" 'sub'

   # Remove and set new tags
   #
   # Iterate through the tag array and set a variable for each tag
   for j in "${tags[@]}" ; do
      # Check if ALBUMARTIST is in tag array and apply operations on
      # the tag field if it exists
      if [[ "${j}" == "ALBUMARTIST" ]] ; then
         # ALBUMARTIST exists in tag array so allow script to check the
         # various naming conventions within the FLAC files (ie,
         # 'ALBUM ARTIST' or 'ALBUM_ARTIST')

         # "ALBUMARTIST"
         if [[ -n "$(metaflac --show-tag=ALBUMARTIST "${1}")" ]] ; then
            show_tag_list+=( "--show-tag=ALBUMARTIST" )

         elif [[ -n "$(metaflac --show-tag="ALBUM ARTIST" "${1}")" ]] ; then
            show_tag_list+=( "--show-tag='ALBUM ARTIST'" )

         elif [[ -n "$(metaflac --show-tag="ALBUM_ARTIST" "${1}")" ]] ; then
            show_tag_list+=( "--show-tag=ALBUM_ARTIST" )
         fi
      else
         # Build up metaflac '--show-tag=' list
         show_tag_list+=( "--show-tag=${j}" )
      fi
   done

   # Load up all the tag values for current file
   mapfile -n0 -t metaflac_tag_array < \
   <(
      metaflac \
         "${show_tag_list[@]}" \
         "${1}"
   )

   # Create a copy of ${metaflac_tag_array[@]} with just the tag fields
   # and force the tag fields to be uppercase
   tag_field_array=( "${metaflac_tag_array[@]%%=*}" )
   tag_field_array=( "${tag_field_array[@]^^}" )

   # Create a copy of ${metaflac_tag_array[@]} with just the tag values
   tag_values_array=( "${metaflac_tag_array[@]#*=}" )

   # Re-create ${metaflac_tag_array[@]}, this time enforcing the tag
   # fields are uppercase
   #
   # Clear ${metaflac_tag_array[@]}
   metaflac_tag_array=()

   # If the user specified 'true' to the 'prepend_zero' option in the
   # configuration file, enforce the TRACKNUMBER and TRACKTOTAL tags to have a
   # '0' prepended before singular numbers
   if [[ "${prepend_zero}" == "true" ]] ; then
      # Prepend a '0' for TRACKNUMBER and TRACKTOTAL
      for j in "${!tag_field_array[@]}" ; do
         # Add in the tag field and value as an index
         if [[ "${tag_field_array[${j}]}" == "TRACKNUMBER" ||
              "${tag_field_array[${j}]}" == "TRACKTOTAL" ]] ; then
            # Format tag value with '0' prepended for single values.  We
            # force arithmetic expansion and explicitly specify base 10
            # in order to prevent octal errors if the value is either '08'
            # or '09'
            prepend_tag_value="$( printf %02d $(( 10#${tag_values_array[${j}]} )) )"

            metaflac_tag_array+=(
               # Tag field (eg. TRACKNUMBER) = Tag value (eg. 03)
               "${tag_field_array[${j}]}=${prepend_tag_value}"
            )
         else
            metaflac_tag_array+=(
               # Tag field (eg. ARTIST) = Tag value (eg. Kamelot)
               "${tag_field_array[${j}]}=${tag_values_array[${j}]}"
            )
         fi
      done
   else
      # ${prepend_zero} is not set as 'true', add each tag field and tag value
      # into ${metaflac_tag_array[@]}
      for j in "${!tag_field_array[@]}" ; do
         # Add in the tag field and value as an index
         metaflac_tag_array+=(
            # Tag field (eg. ARTIST) = Tag value (eg. Kamelot)
            "${tag_field_array[${j}]}=${tag_values_array[${j}]}"
         )
      done
   fi

   # Add the saved tags back, by printing each tag field and value
   # on a separate line to STDOUT.  This will be read in by metaflac.
   # Use process substitution to allow this to finish if user
   # invokes SIGINT
   metaflac --remove-all-tags --import-tags-from=- "${1}" < \
   <(
      # This prints each tag key and value pair
      # (eg. ARTIST=Kamelot)
      printf "%s\n" "${metaflac_tag_array[@]}"
   )

   # Display ok
   __print_status 'ok' "${file_basename}" "${file_length}" 'sub'

   printf "$4\n" >&3  # Store row position and end operation
}

#-------------------------------------------------------------------------------

__extract_images() {
   # Extact embedded artwork from a given FLAC
   #--
   # $1 is the filename
   # $2 is the operation that's currently being run, of which, can be:
   #   aucdtect                  md5_check           compress_verify
   #   compress_no_test          test                replaygain_test
   #   replaygain_force_apply    replaygain_apply    retag_analyze
   #   retag_apply               extract_images      prune
   # $3 is a string representing number items processed, eg: [43/439]
   # $4 is the current operation's row placement
   #--
   trap '__kill_jobs "$(jobs -rp)"' EXIT

   # Set up local variables
   declare -i file_length backup='1'

   # Truncate file, if necessary, and grab file information, splitting on
   # Unit Separator (\037)
   IFS=$'\037' read -r file_basename file_length < <(__truncate_filename "$1")

   # Print current FLAC being processed
   __print_item "${file_basename}" "${file_length}" "$3" 'half'

   # Check if file is a FLAC file (hide output)
   metaflac --show-md5sum "${1}" >/dev/null 2>&1

   # Exit code 1 implies failure (130 is SIGINT)
   if (( ${?} == 1 )) ; then
      # Error with FLAC file, display failed/error
      __print_status 'fail' "${file_basename}" "${file_length}"

      # Log FLAC failure
      printf "%s${unit_separator}Not a real FLAC file\n" "${1}" \
         >> "${log_file}"

      printf '.' >> "${issue_ticks}"  # Add one tick to total issues
   else
      # Find all the artwork blocks available in the current FLAC file, returned
      # as an array: $artwork[@]
      __find_artwork "$1"
 
      # Continue only if there were artwork to be extracted
      if [[ -n "${artwork[@]}" ]] ; then
         # Determine where to put extracted artwork by checking user config
         if [[ -n "${artwork_location}" ]] ; then
            # $artwork_location/file.flac_art
            artwork_directory="${artwork_location}/${1##*/}_art"
         else
            # /path/to/current/flac/file.flac_art
            artwork_directory="${1}_art"
         fi

         # Prevent directory clobbering by creating an incremental version
         until [[ ! -d "${artwork_directory}" ]] ; do
            artwork_directory="${artwork_directory%~*~}~$((backup++))~"
         done

         mkdir -p "${artwork_directory}"  # Create artwork directory

         for image in "${artwork[@]}" ; do
            # Run through all the artwork found in the current FLAC by looking
            # at $artwork[@], of which, each index looks like:
            #   artwork[0]="${block_id}:${art_id}_${art_desc}.${art_ext}"
            # and extract each image by it's METADATA block number
            #--
            # Prevent file clobbering by creating an incremental version
            backup='1'
            extracted_image="${artwork_directory}/${image#*:}"
            until [[ ! -f "${extracted_image}" ]] ; do
               extracted_image="${artwork_directory}/${image#*:}~$((backup++))~"
            done

            # Extract image by the METADATA block number to the art directory
            metaflac \
               --block-number="${image%%:*}" \
               --export-picture-to="${extracted_image}" \
               "$1"
         done
      fi

      # FLAC is ok, display ok
      __print_status 'ok' "${file_basename}" "${file_length}"
   fi
   printf "$4\n" >&3  # Store row position and end operation
}

#-------------------------------------------------------------------------------

__prune() {
   # Prune given FLAC by removing various BLOCKs (defined in user configuration)
   #--
   # $1 is the filename
   # $2 is the operation that's currently being run, of which, can be:
   #   aucdtect                  md5_check           compress_verify
   #   compress_no_test          test                replaygain_test
   #   replaygain_force_apply    replaygain_apply    retag_analyze
   #   retag_apply               extract_images      prune
   # $3 is a string representing number items processed, eg: [43/439]
   # $4 is the current operation's row placement
   #--
   trap '__kill_jobs "$(jobs -rp)"' EXIT

   # Set up local variables
   declare    file_basename
   declare -i file_length

   # Truncate file, if necessary, and grab file information, splitting on
   # Unit Separator (\037)
   IFS=$'\037' read -r file_basename file_length < <(__truncate_filename "$1")

   # Print current FLAC being processed
   __print_item "${file_basename}" "${file_length}" "$3" 'half'

   # Check if file is a FLAC file (hide output)
   metaflac --show-md5sum "${1}" >/dev/null 2>&1

   # Exit code 1 implies failure (130 is SIGINT)
   if (( ${?} == 1 )) ; then
      # Error with FLAC file, display failed/error
      __print_status 'fail' "${file_basename}" "${file_length}"

      # Log FLAC failure
      printf "%s${unit_separator}Not a real FLAC file\n" "${1}" \
         >> "${log_file}"

      printf '.' >> "${issue_ticks}"  # Add one tick to total issues
   else
      # Remove all information but STREAMINFO,VORBIS_COMMENTs, and
      # possibly METADATA_BLOCK_PICTURE
      metaflac --remove --dont-use-padding --except-block-type="${dont_prune_flac_metadata}" "${1}"

      # FLAC is ok, display ok
      __print_status 'ok' "${file_basename}" "${file_length}"
   fi
   printf "$4\n" >&3  # Store row position and end operation
}

#-------------------------------------------------------------------------------
# .: PRE-SCRIPT CHECKS :.
#-------------------------------------------------------------------------------
# Enable BASH 4 globstar
shopt -s globstar

version="0.23_pre"                     # Redoflacs version
flac_extension=".[Ff][Ll][Aa][Cc]"     # FLAC extension (case-insensitive)
unit_separator=$'\037'                 # ASCII unit separator

declare -i script_config_revision='2'  # Script user configuration revision
declare -i max_length                  # Max filename length within terminal
declare -A operation_summary           # Stores all the operational states

# Colors on by default
reset='\033[0m'
invert='\033[7m'
red='\033[31m'
green='\033[32m'
yellow='\033[33m'
blue='\033[34m'
magenta='\033[35m'
cyan='\033[36m'

# Check if user is running under Cygwin and if so, warn user and exit
os_name="$(uname -o)"
if [[ "${os_name}" == "Cygwin" ]] ; then
   __error "This version of redoflacs is meant to be run under\n" >&2
   __error "${cyan}UNIX/Linux/BSD${reset}.  Please use the ${cyan}Windows (Cygwin)${reset}\n" >&2
   __error "version located here:\n" >&2
   __error "${cyan}https://github.com/sirjaren/redoflacsw/tags${reset}\n" >&2

   exit 1
fi

#-------------------------------------------------------------------------------

# Create/source either system or user config
if (( EUID == 0 )) ; then
   config_file="/etc/redoflacs.conf"               # System (root) config
else
   config_file="${HOME}/.config/redoflacs/config"  # User config
fi

# Check if system-wide configuration doesn't exist
if [[ ! -f "${config_file}" ]] ; then
   mkdir -p "${config_file%/*}"  # Create directory if it doesn't exist
   __create_config               # Create configuration file

   __info "A configuration file has been created here:\n"
   __info "${cyan}${config_file}${reset}\n\n"

   __info "Please review it before running this program.\n"

   exit 0
else
   __parse_config                # Parse and source configuration file
fi

#-------------------------------------------------------------------------------

# Generate log file location
#--
# Ensure we don't overwrite an existing log file by incrementing the current PID
# by 1 until the log file that is to be set, doesn't exist
pid="$$"
log_file="${error_log}/redoflacs_${pid}.log"

until [[ ! -f "${log_file}" ]] ; do
   log_file="${error_log}/redoflacs_log_$((pid++)).log"
done

#-------------------------------------------------------------------------------

__process_positional_parameters "${@}"  # Process CLI arguments

#-------------------------------------------------------------------------------

# Disable color if user called '-n, --no-color'
if [[ "${no_color}" == "true" ]] ; then
   blue=""
   green=""
   red=""
   cyan=""
   magenta=""
   yellow=""
fi

#-------------------------------------------------------------------------------

# Make sure we are running BASH 4 or greater
if (( ${BASH_VERSINFO[0]} < 4 )) ; then
   __error "You must be running ${cyan}BASH 4${reset} or greater to use\n" >&2
   __error "this program!\n" >&2
   exit 1
fi

#-------------------------------------------------------------------------------

# Check for any conflicting operations/arguments called and warn user
__check_conflicting_operations

#-------------------------------------------------------------------------------

# For each operation that was selected, add to $operation_summary[@]
for operation in "${operations[@]}" ; do
   __update_operation_status "${operation}" 'Operation Did Not Run'
done
#-------------------------------------------------------------------------------

__check_missing_programs  # Check for missing programs vital to this script

#-------------------------------------------------------------------------------

# Check whether directory exists
if [[ ! -d "${directory}" ]] ; then
   printf " Usage: redoflacs [OPTION] [PATH_TO_FLAC(s)]...\n" >&2
   __error "Please specify a directory!\n" >&2
   exit 1
fi

#-------------------------------------------------------------------------------

# Check for at least 1 FLAC file
read -r find_flacs < <( printf "%s\n" "${directory}"/**/*${flac_extension} )

if [[ ! -f "${find_flacs}" ]] ; then
   __error "There are not any FLAC files to process!\n" >&2
   exit 1
fi

#-------------------------------------------------------------------------------

# If '-e, --extract-artwork' was called, make sure $artwork_location is valid
if [[ "${operations[9]}" == 'extract_images' ]] ; then
   # Check if artwork_location is user-defined
   if [[ -n "${artwork_location}" ]] ; then
      # Put extracted artwork in user-defined location, testing to make sure
      # the directory exists
      if [[ ! -d "${artwork_location}" ]] ; then
         __error "${cyan}${artwork_location}${reset} doesn't exist!\n" >&2
         __error "Please set a valid directory in the configuration file!\n" >&2
         exit 1
      fi
   fi
fi

# If '-A, --aucdtect-spectrogram' was called, make sure $spectrogram_location is
# valid
if [[ "${create_spectrogram}" == "true" ]] ; then
   # Check if spectrogram_location is user-defined
   if [[ -n "${spectrogram_location}" ]] ; then
      # Put spectrograms in user-defined location, testing to make sure the
      # directory exists
      if [[ ! -d "${spectrogram_location}" ]] ; then
         __error "${cyan}${spectrogram_location}${reset} doesn't exist!\n" >&2
         __error "Please set a valid directory in the configuration file!\n" >&2
         exit 1
      fi
   fi
fi

#-------------------------------------------------------------------------------

# If $jobs wasn't set on invocation, check in /proc determine the number of jobs
if [[ -z "${jobs}" ]] ; then
   __find_cores
else
   jobs_display="(User Defined)"
fi

#-------------------------------------------------------------------------------
# .: START SCRIPT :.
#-------------------------------------------------------------------------------
old_stty="$(stty -g)"              # Store current stty settings
stty -ctlecho 2>/dev/null          # Disable ctrl+c '^C'
printf "\033[?25l"                 # Hide cursor
__check_config_version             # Check if script config is newer than user's
job_fifo="/tmp/redoflacs_fifo_$$"  # Job manager FIFO

tmp_aucdtect_fd="/tmp/redoflacs_aucdtect_fifo_$$"    # auCDtect's STDOUT FIFO
trap 'rm -f "${job_fifo}" "${tmp_aucdtect_fd}"' EXIT # Allow for FIFO removal
mkfifo "${tmp_aucdtect_fd}"                          # Create auCDtect FIFO
exec 4<>"${tmp_aucdtect_fd}"                         # Open read/write on fd '4'

issue_ticks="/tmp/redoflacs_issue_file_$$"           # Issues/Errors file

# __retag_apply: Display a countdown
[[ -n "${operations[8]}" ]] && __countdown_metadata

__top_banner                                         # Display top banner
total_items=( "${directory}"/**/*${flac_extension} ) # Total FLACs to process

# This displays '[ ok ]' after 'Finding FLAC files to process...'
printf "%11s${blue}[ ${green}ok${blue} ]${reset}\n" ""

#-------------------------------------------------------------------------------

for operation in "${operations[@]}" ; do
   # Loop through the various operations to run.  All the operations are to be
   # run, in order, which is detailed below:
   #   operations[0]='aucdtect'
   #   operations[1]='md5_check'
   #   operations[2]='compress_verify'
   #   operations[3]='compress_no_test'
   #   operations[4]='test'
   #   operations[5]='replaygain_test'
   #   operations[6]='replaygain_force_apply'   # Conditionally set
   #   operations[6]='replaygain_apply'         # Conditionally set
   #   operations[7]='retag_analyze'
   #   operations[8]='retag_apply'
   #   operations[9]='extract_images'
   #   operations[10]='prune'
   #--
   case "${operation}" in
      'replaygain_'*'apply')
         # Make absolute pathname
         [[ "${directory}" == '.' ]] && directory="${PWD}"

         total_items_backup=( "${total_items[@]}" )  # Total FLACs backup array
         __get_directory_list "${total_items[@]}"    # Returns $total_dirs[@]
         total_items=( "${total_dirs[@]}" )          # Now process directories
      ;;
      'prune')
         # Set which FLAC metadata BLOCKS to remove
         if [[ "${remove_artwork}" == 'true' ]] ; then
            # Remove PICTURE block
            dont_prune_flac_metadata="STREAMINFO,VORBIS_COMMENT"
         else
            # Do not remove PICTURE block
            dont_prune_flac_metadata="STREAMINFO,PICTURE,VORBIS_COMMENT"
         fi
      ;;
   esac

   __message "${operation}"        # Display title message of current operation
   __scroll_terminal "$(__row)"    # Scroll terminal up (if needed)
   __clear_jobs_fd "${job_fifo}"   # Clear job manager file descriptor (3)

   if (( ${#total_items[@]} < jobs )) ; then
      # Set row position to place cursor after completing an operation or trap
      #--
      # If the items to process are less than the number of jobs, add the number
      # of items to the current row position, else add the number of jobs to run
      post_row=$(( $(__row) + ${#total_items[@]} ))
   else
      post_row=$(( $(__row) + jobs ))
   fi

   trap '__trap_sigint "$post_row" "${operation}"' SIGINT # Clean exit on SIGINT
   __run_parallel "${operation}"   # Run a given operation with parallel jobs
   printf "\033[${post_row}H"      # Place cursor after operation ran

   if [[ -f "${log_file}" ]] ; then
      __message_log_exists "${operation}"  # Print out log exists to STDERR
      __create_log "${operation}"          # Create and format log

      # Update status for the current operation
      __update_operation_status "${operation}" "$(__num_issues)"

      __summary                            # Display Summary Of Operations
      exit 1
   fi

   # Update status for the current operation
   __update_operation_status "${operation}" 'Operation Completed'

   # Restore the items to process from directories to FLACs
   [[ "${operation}" == 'replaygain_'*'apply' ]] && total_items=( "${total_items_backup[@]}" )
done

#-------------------------------------------------------------------------------

__summary  # Display Summary Of Operations
